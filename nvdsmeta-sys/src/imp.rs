#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]

/* automatically generated by rust-bindgen 0.60.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const G_ANALYZER_ANALYZING: u32 = 0;
pub const FALSE: u32 = 0;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 31;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 0;
pub const __LONG_DOUBLE_USES_FLOAT128: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const MB_LEN_MAX: u32 = 16;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 131072;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const CHAR_MIN: u32 = 0;
pub const G_GINT16_MODIFIER: &[u8; 2usize] = b"h\0";
pub const G_GINT16_FORMAT: &[u8; 3usize] = b"hi\0";
pub const G_GUINT16_FORMAT: &[u8; 3usize] = b"hu\0";
pub const G_GINT32_MODIFIER: &[u8; 1usize] = b"\0";
pub const G_GINT32_FORMAT: &[u8; 2usize] = b"i\0";
pub const G_GUINT32_FORMAT: &[u8; 2usize] = b"u\0";
pub const G_HAVE_GINT64: u32 = 1;
pub const G_GINT64_MODIFIER: &[u8; 2usize] = b"l\0";
pub const G_GINT64_FORMAT: &[u8; 3usize] = b"li\0";
pub const G_GUINT64_FORMAT: &[u8; 3usize] = b"lu\0";
pub const GLIB_SIZEOF_VOID_P: u32 = 8;
pub const GLIB_SIZEOF_LONG: u32 = 8;
pub const GLIB_SIZEOF_SIZE_T: u32 = 8;
pub const GLIB_SIZEOF_SSIZE_T: u32 = 8;
pub const G_GSIZE_MODIFIER: &[u8; 2usize] = b"l\0";
pub const G_GSSIZE_MODIFIER: &[u8; 2usize] = b"l\0";
pub const G_GSIZE_FORMAT: &[u8; 3usize] = b"lu\0";
pub const G_GSSIZE_FORMAT: &[u8; 3usize] = b"li\0";
pub const G_GOFFSET_MODIFIER: &[u8; 2usize] = b"l\0";
pub const G_GOFFSET_FORMAT: &[u8; 3usize] = b"li\0";
pub const G_POLLFD_FORMAT: &[u8; 3usize] = b"%d\0";
pub const G_GINTPTR_MODIFIER: &[u8; 2usize] = b"l\0";
pub const G_GINTPTR_FORMAT: &[u8; 3usize] = b"li\0";
pub const G_GUINTPTR_FORMAT: &[u8; 3usize] = b"lu\0";
pub const GLIB_MAJOR_VERSION: u32 = 2;
pub const GLIB_MINOR_VERSION: u32 = 64;
pub const GLIB_MICRO_VERSION: u32 = 6;
pub const G_HAVE_ISO_VARARGS: u32 = 1;
pub const G_HAVE_GROWING_STACK: u32 = 0;
pub const G_HAVE_GNUC_VISIBILITY: u32 = 1;
pub const G_HAVE_GNUC_VARARGS: u32 = 1;
pub const G_MODULE_SUFFIX: &[u8; 3usize] = b"so\0";
pub const G_PID_FORMAT: &[u8; 2usize] = b"i\0";
pub const GLIB_SYSDEF_AF_UNIX: u32 = 1;
pub const GLIB_SYSDEF_AF_INET: u32 = 2;
pub const GLIB_SYSDEF_AF_INET6: u32 = 10;
pub const GLIB_SYSDEF_MSG_OOB: u32 = 1;
pub const GLIB_SYSDEF_MSG_PEEK: u32 = 2;
pub const GLIB_SYSDEF_MSG_DONTROUTE: u32 = 4;
pub const G_DIR_SEPARATOR: u8 = 47u8;
pub const G_DIR_SEPARATOR_S: &[u8; 2usize] = b"/\0";
pub const G_SEARCHPATH_SEPARATOR: u8 = 58u8;
pub const G_SEARCHPATH_SEPARATOR_S: &[u8; 2usize] = b":\0";
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __struct_tm_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const __clockid_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __itimerspec_defined: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const G_E: f64 = 2.718281828459045;
pub const G_LN2: f64 = 0.6931471805599453;
pub const G_LN10: f64 = 2.302585092994046;
pub const G_PI: f64 = 3.141592653589793;
pub const G_PI_2: f64 = 1.5707963267948966;
pub const G_PI_4: f64 = 0.7853981633974483;
pub const G_SQRT2: f64 = 1.4142135623730951;
pub const G_LITTLE_ENDIAN: u32 = 1234;
pub const G_BIG_ENDIAN: u32 = 4321;
pub const G_PDP_ENDIAN: u32 = 3412;
pub const G_IEEE754_FLOAT_BIAS: u32 = 127;
pub const G_IEEE754_DOUBLE_BIAS: u32 = 1023;
pub const G_LOG_2_BASE_10: f64 = 0.3010299956639812;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __ENUM_IDTYPE_T: u32 = 1;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __HAVE_FLOAT128: u32 = 1;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 64;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 48;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const _BITS_SIGNUM_H: u32 = 1;
pub const _BITS_SIGNUM_GENERIC_H: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGILL: u32 = 4;
pub const SIGABRT: u32 = 6;
pub const SIGFPE: u32 = 8;
pub const SIGSEGV: u32 = 11;
pub const SIGTERM: u32 = 15;
pub const SIGHUP: u32 = 1;
pub const SIGQUIT: u32 = 3;
pub const SIGTRAP: u32 = 5;
pub const SIGKILL: u32 = 9;
pub const SIGBUS: u32 = 10;
pub const SIGSYS: u32 = 12;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGURG: u32 = 16;
pub const SIGSTOP: u32 = 17;
pub const SIGTSTP: u32 = 18;
pub const SIGCONT: u32 = 19;
pub const SIGCHLD: u32 = 20;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGPOLL: u32 = 23;
pub const SIGXCPU: u32 = 24;
pub const SIGXFSZ: u32 = 25;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGUSR1: u32 = 30;
pub const SIGUSR2: u32 = 31;
pub const SIGWINCH: u32 = 28;
pub const SIGIO: u32 = 23;
pub const SIGIOT: u32 = 6;
pub const SIGCLD: u32 = 20;
pub const __SIGRTMIN: u32 = 32;
pub const __SIGRTMAX: u32 = 32;
pub const _NSIG: u32 = 33;
pub const SIGSTKFLT: u32 = 16;
pub const SIGPWR: u32 = 30;
pub const __sig_atomic_t_defined: u32 = 1;
pub const __siginfo_t_defined: u32 = 1;
pub const __SI_MAX_SIZE: u32 = 128;
pub const _BITS_SIGINFO_ARCH_H: u32 = 1;
pub const __SI_ERRNO_THEN_CODE: u32 = 1;
pub const __SI_HAVE_SIGSYS: u32 = 1;
pub const _BITS_SIGINFO_CONSTS_H: u32 = 1;
pub const __SI_ASYNCIO_AFTER_SIGIO: u32 = 1;
pub const __sigevent_t_defined: u32 = 1;
pub const __SIGEV_MAX_SIZE: u32 = 64;
pub const _BITS_SIGEVENT_CONSTS_H: u32 = 1;
pub const NSIG: u32 = 33;
pub const _BITS_SIGACTION_H: u32 = 1;
pub const SA_NOCLDSTOP: u32 = 1;
pub const SA_NOCLDWAIT: u32 = 2;
pub const SA_SIGINFO: u32 = 4;
pub const SA_ONSTACK: u32 = 134217728;
pub const SA_RESTART: u32 = 268435456;
pub const SA_NODEFER: u32 = 1073741824;
pub const SA_RESETHAND: u32 = 2147483648;
pub const SA_INTERRUPT: u32 = 536870912;
pub const SA_NOMASK: u32 = 1073741824;
pub const SA_ONESHOT: u32 = 2147483648;
pub const SA_STACK: u32 = 134217728;
pub const SIG_BLOCK: u32 = 0;
pub const SIG_UNBLOCK: u32 = 1;
pub const SIG_SETMASK: u32 = 2;
pub const _BITS_SIGCONTEXT_H: u32 = 1;
pub const __BITS_PER_LONG: u32 = 64;
pub const FPSIMD_MAGIC: u32 = 1179680769;
pub const ESR_MAGIC: u32 = 1163088385;
pub const EXTRA_MAGIC: u32 = 1163416577;
pub const SVE_MAGIC: u32 = 1398162689;
pub const __SVE_VQ_BYTES: u32 = 16;
pub const __SVE_VQ_MIN: u32 = 1;
pub const __SVE_VQ_MAX: u32 = 512;
pub const __SVE_VL_MIN: u32 = 16;
pub const __SVE_VL_MAX: u32 = 8192;
pub const __SVE_NUM_ZREGS: u32 = 32;
pub const __SVE_NUM_PREGS: u32 = 16;
pub const __SVE_ZREGS_OFFSET: u32 = 0;
pub const SVE_VQ_BYTES: u32 = 16;
pub const SVE_VQ_MIN: u32 = 1;
pub const SVE_VQ_MAX: u32 = 512;
pub const SVE_VL_MIN: u32 = 16;
pub const SVE_VL_MAX: u32 = 8192;
pub const SVE_NUM_ZREGS: u32 = 32;
pub const SVE_NUM_PREGS: u32 = 16;
pub const __stack_t_defined: u32 = 1;
pub const _SYS_UCONTEXT_H: u32 = 1;
pub const _SYS_PROCFS_H: u32 = 1;
pub const _SYS_TIME_H: u32 = 1;
pub const _SYS_USER_H: u32 = 1;
pub const ELF_PRARGSZ: u32 = 80;
pub const _BITS_SIGSTACK_H: u32 = 1;
pub const MINSIGSTKSZ: u32 = 5120;
pub const SIGSTKSZ: u32 = 16384;
pub const _BITS_SS_FLAGS_H: u32 = 1;
pub const __sigstack_defined: u32 = 1;
pub const _BITS_SIGTHREAD_H: u32 = 1;
pub const G_DATALIST_FLAGS_MASK: u32 = 3;
pub const G_DATE_BAD_JULIAN: u32 = 0;
pub const G_DATE_BAD_DAY: u32 = 0;
pub const G_DATE_BAD_YEAR: u32 = 0;
pub const _DIRENT_H: u32 = 1;
pub const _DIRENT_MATCHES_DIRENT64: u32 = 1;
pub const MAXNAMLEN: u32 = 255;
pub const G_MEM_ALIGN: u32 = 8;
pub const G_HOOK_FLAG_USER_SHIFT: u32 = 4;
pub const G_PRIORITY_HIGH: i32 = -100;
pub const G_PRIORITY_DEFAULT: u32 = 0;
pub const G_PRIORITY_HIGH_IDLE: u32 = 100;
pub const G_PRIORITY_DEFAULT_IDLE: u32 = 200;
pub const G_PRIORITY_LOW: u32 = 300;
pub const G_SOURCE_REMOVE: u32 = 0;
pub const G_UNICHAR_MAX_DECOMPOSITION_LENGTH: u32 = 18;
pub const G_KEY_FILE_DESKTOP_GROUP: &[u8; 14usize] = b"Desktop Entry\0";
pub const G_KEY_FILE_DESKTOP_KEY_TYPE: &[u8; 5usize] = b"Type\0";
pub const G_KEY_FILE_DESKTOP_KEY_VERSION: &[u8; 8usize] = b"Version\0";
pub const G_KEY_FILE_DESKTOP_KEY_NAME: &[u8; 5usize] = b"Name\0";
pub const G_KEY_FILE_DESKTOP_KEY_GENERIC_NAME: &[u8; 12usize] = b"GenericName\0";
pub const G_KEY_FILE_DESKTOP_KEY_NO_DISPLAY: &[u8; 10usize] = b"NoDisplay\0";
pub const G_KEY_FILE_DESKTOP_KEY_COMMENT: &[u8; 8usize] = b"Comment\0";
pub const G_KEY_FILE_DESKTOP_KEY_ICON: &[u8; 5usize] = b"Icon\0";
pub const G_KEY_FILE_DESKTOP_KEY_HIDDEN: &[u8; 7usize] = b"Hidden\0";
pub const G_KEY_FILE_DESKTOP_KEY_ONLY_SHOW_IN: &[u8; 11usize] = b"OnlyShowIn\0";
pub const G_KEY_FILE_DESKTOP_KEY_NOT_SHOW_IN: &[u8; 10usize] = b"NotShowIn\0";
pub const G_KEY_FILE_DESKTOP_KEY_TRY_EXEC: &[u8; 8usize] = b"TryExec\0";
pub const G_KEY_FILE_DESKTOP_KEY_EXEC: &[u8; 5usize] = b"Exec\0";
pub const G_KEY_FILE_DESKTOP_KEY_PATH: &[u8; 5usize] = b"Path\0";
pub const G_KEY_FILE_DESKTOP_KEY_TERMINAL: &[u8; 9usize] = b"Terminal\0";
pub const G_KEY_FILE_DESKTOP_KEY_MIME_TYPE: &[u8; 9usize] = b"MimeType\0";
pub const G_KEY_FILE_DESKTOP_KEY_CATEGORIES: &[u8; 11usize] = b"Categories\0";
pub const G_KEY_FILE_DESKTOP_KEY_STARTUP_NOTIFY: &[u8; 14usize] = b"StartupNotify\0";
pub const G_KEY_FILE_DESKTOP_KEY_STARTUP_WM_CLASS: &[u8; 15usize] = b"StartupWMClass\0";
pub const G_KEY_FILE_DESKTOP_KEY_URL: &[u8; 4usize] = b"URL\0";
pub const G_KEY_FILE_DESKTOP_KEY_DBUS_ACTIVATABLE: &[u8; 16usize] = b"DBusActivatable\0";
pub const G_KEY_FILE_DESKTOP_KEY_ACTIONS: &[u8; 8usize] = b"Actions\0";
pub const G_KEY_FILE_DESKTOP_TYPE_APPLICATION: &[u8; 12usize] = b"Application\0";
pub const G_KEY_FILE_DESKTOP_TYPE_LINK: &[u8; 5usize] = b"Link\0";
pub const G_KEY_FILE_DESKTOP_TYPE_DIRECTORY: &[u8; 10usize] = b"Directory\0";
pub const G_LOG_LEVEL_USER_SHIFT: u32 = 8;
pub const G_OPTION_REMAINING: &[u8; 1usize] = b"\0";
pub const G_CSET_A_2_Z: &[u8; 27usize] = b"ABCDEFGHIJKLMNOPQRSTUVWXYZ\0";
pub const G_CSET_a_2_z: &[u8; 27usize] = b"abcdefghijklmnopqrstuvwxyz\0";
pub const G_CSET_DIGITS: &[u8; 11usize] = b"0123456789\0";
pub const G_CSET_LATINC: [u8; 31usize] = [
    192u8, 193u8, 194u8, 195u8, 196u8, 197u8, 198u8, 199u8, 200u8, 201u8, 202u8, 203u8, 204u8,
    205u8, 206u8, 207u8, 208u8, 209u8, 210u8, 211u8, 212u8, 213u8, 214u8, 216u8, 217u8, 218u8,
    219u8, 220u8, 221u8, 222u8, 0u8,
];
pub const G_CSET_LATINS: [u8; 33usize] = [
    223u8, 224u8, 225u8, 226u8, 227u8, 228u8, 229u8, 230u8, 231u8, 232u8, 233u8, 234u8, 235u8,
    236u8, 237u8, 238u8, 239u8, 240u8, 241u8, 242u8, 243u8, 244u8, 245u8, 246u8, 248u8, 249u8,
    250u8, 251u8, 252u8, 253u8, 254u8, 255u8, 0u8,
];
pub const G_STR_DELIMITERS: &[u8; 8usize] = b"_-|> <.\0";
pub const G_ASCII_DTOSTR_BUF_SIZE: u32 = 39;
pub const _STRING_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const G_TEST_OPTION_ISOLATE_DIRS: &[u8; 13usize] = b"isolate_dirs\0";
pub const G_USEC_PER_SEC: u32 = 1000000;
pub const G_URI_RESERVED_CHARS_GENERIC_DELIMITERS: &[u8; 8usize] = b":/?#[]@\0";
pub const G_URI_RESERVED_CHARS_SUBCOMPONENT_DELIMITERS: &[u8; 12usize] = b"!$&'()*+,;=\0";
pub const G_URI_RESERVED_CHARS_ALLOWED_IN_PATH_ELEMENT: &[u8; 14usize] = b"!$&'()*+,;=:@\0";
pub const G_URI_RESERVED_CHARS_ALLOWED_IN_PATH: &[u8; 15usize] = b"!$&'()*+,;=:@/\0";
pub const G_URI_RESERVED_CHARS_ALLOWED_IN_USERINFO: &[u8; 13usize] = b"!$&'()*+,;=:\0";
pub const G_ALLOC_ONLY: u32 = 1;
pub const G_ALLOC_AND_FREE: u32 = 2;
pub const G_ALLOCATOR_LIST: u32 = 1;
pub const G_ALLOCATOR_SLIST: u32 = 2;
pub const G_ALLOCATOR_NODE: u32 = 3;
pub const _PTHREAD_H: u32 = 1;
pub const _SCHED_H: u32 = 1;
pub const _BITS_SCHED_H: u32 = 1;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const _BITS_TYPES_STRUCT_SCHED_PARAM: u32 = 1;
pub const _BITS_CPU_SET_H: u32 = 1;
pub const __CPU_SETSIZE: u32 = 1024;
pub const _BITS_SETJMP_H: u32 = 1;
pub const PTHREAD_ONCE_INIT: u32 = 0;
pub const PTHREAD_BARRIER_SERIAL_THREAD: i32 = -1;
pub const DS_MAX_POLYGON_POINTS: u32 = 8;
pub const MAX_USER_FIELDS: u32 = 4;
pub const MAX_RESERVED_FIELDS: u32 = 4;
pub const MAX_LABEL_SIZE: u32 = 128;
pub const MAX_ELEMENTS_IN_DISPLAY_META: u32 = 16;
pub const UNTRACKED_OBJECT_ID: i32 = -1;
pub type size_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_uint;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    fn test_field___clang_max_align_nonce1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<max_align_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(max_align_t),
                "::",
                stringify!(__clang_max_align_nonce1)
            )
        );
    }
    test_field___clang_max_align_nonce1();
    fn test_field___clang_max_align_nonce2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<max_align_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(max_align_t),
                "::",
                stringify!(__clang_max_align_nonce2)
            )
        );
    }
    test_field___clang_max_align_nonce2();
}
pub type gint8 = ::std::os::raw::c_schar;
pub type guint8 = ::std::os::raw::c_uchar;
pub type gint16 = ::std::os::raw::c_short;
pub type guint16 = ::std::os::raw::c_ushort;
pub type gint32 = ::std::os::raw::c_int;
pub type guint32 = ::std::os::raw::c_uint;
pub type gint64 = ::std::os::raw::c_long;
pub type guint64 = ::std::os::raw::c_ulong;
pub type gssize = ::std::os::raw::c_long;
pub type gsize = ::std::os::raw::c_ulong;
pub type goffset = gint64;
pub type gintptr = ::std::os::raw::c_long;
pub type guintptr = ::std::os::raw::c_ulong;
pub type GPid = ::std::os::raw::c_int;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_uint;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    fn test_field___val() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__fsid_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__fsid_t),
                "::",
                stringify!(__val)
            )
        );
    }
    test_field___val();
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_int;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type clock_t = __clock_t;
pub type time_t = __time_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    fn test_field_tm_sec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_sec) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_sec)
            )
        );
    }
    test_field_tm_sec();
    fn test_field_tm_min() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_min) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_min)
            )
        );
    }
    test_field_tm_min();
    fn test_field_tm_hour() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_hour) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_hour)
            )
        );
    }
    test_field_tm_hour();
    fn test_field_tm_mday() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_mday) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_mday)
            )
        );
    }
    test_field_tm_mday();
    fn test_field_tm_mon() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_mon) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_mon)
            )
        );
    }
    test_field_tm_mon();
    fn test_field_tm_year() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_year) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_year)
            )
        );
    }
    test_field_tm_year();
    fn test_field_tm_wday() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_wday) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_wday)
            )
        );
    }
    test_field_tm_wday();
    fn test_field_tm_yday() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_yday) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_yday)
            )
        );
    }
    test_field_tm_yday();
    fn test_field_tm_isdst() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_isdst) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_isdst)
            )
        );
    }
    test_field_tm_isdst();
    fn test_field_tm_gmtoff() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_gmtoff) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_gmtoff)
            )
        );
    }
    test_field_tm_gmtoff();
    fn test_field_tm_zone() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_zone) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_zone)
            )
        );
    }
    test_field_tm_zone();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    fn test_field_tv_sec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<timespec>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(timespec),
                "::",
                stringify!(tv_sec)
            )
        );
    }
    test_field_tv_sec();
    fn test_field_tv_nsec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<timespec>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(timespec),
                "::",
                stringify!(tv_nsec)
            )
        );
    }
    test_field_tv_nsec();
}
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(
        ::std::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    fn test_field_it_interval() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<itimerspec>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).it_interval) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(itimerspec),
                "::",
                stringify!(it_interval)
            )
        );
    }
    test_field_it_interval();
    fn test_field_it_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<itimerspec>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).it_value) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(itimerspec),
                "::",
                stringify!(it_value)
            )
        );
    }
    test_field_it_value();
}
pub type pid_t = __pid_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    fn test_field___locales() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__locale_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__locales) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__locale_struct),
                "::",
                stringify!(__locales)
            )
        );
    }
    test_field___locales();
    fn test_field___ctype_b() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__locale_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__ctype_b) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(__locale_struct),
                "::",
                stringify!(__ctype_b)
            )
        );
    }
    test_field___ctype_b();
    fn test_field___ctype_tolower() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__locale_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__ctype_tolower) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(__locale_struct),
                "::",
                stringify!(__ctype_tolower)
            )
        );
    }
    test_field___ctype_tolower();
    fn test_field___ctype_toupper() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__locale_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__ctype_toupper) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(__locale_struct),
                "::",
                stringify!(__ctype_toupper)
            )
        );
    }
    test_field___ctype_toupper();
    fn test_field___names() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__locale_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__names) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(__locale_struct),
                "::",
                stringify!(__names)
            )
        );
    }
    test_field___names();
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: size_t,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
    ) -> size_t;
}
extern "C" {
    pub fn strftime_l(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: size_t,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
        __loc: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asctime_r(
        __tp: *const tm,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        __timer: *const time_t,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut __tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub static mut __daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn dysize(__year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nanosleep(
        __requested_time: *const timespec,
        __remaining: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: ::std::os::raw::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: ::std::os::raw::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timespec_get(
        __ts: *mut timespec,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type gchar = ::std::os::raw::c_char;
pub type gshort = ::std::os::raw::c_short;
pub type glong = ::std::os::raw::c_long;
pub type gint = ::std::os::raw::c_int;
pub type gboolean = gint;
pub type guchar = ::std::os::raw::c_uchar;
pub type gushort = ::std::os::raw::c_ushort;
pub type gulong = ::std::os::raw::c_ulong;
pub type guint = ::std::os::raw::c_uint;
pub type gfloat = f32;
pub type gdouble = f64;
pub type gpointer = *mut ::std::os::raw::c_void;
pub type gconstpointer = *const ::std::os::raw::c_void;
pub type GCompareFunc =
    ::std::option::Option<unsafe extern "C" fn(a: gconstpointer, b: gconstpointer) -> gint>;
pub type GCompareDataFunc = ::std::option::Option<
    unsafe extern "C" fn(a: gconstpointer, b: gconstpointer, user_data: gpointer) -> gint,
>;
pub type GEqualFunc =
    ::std::option::Option<unsafe extern "C" fn(a: gconstpointer, b: gconstpointer) -> gboolean>;
pub type GDestroyNotify = ::std::option::Option<unsafe extern "C" fn(data: gpointer)>;
pub type GFunc = ::std::option::Option<unsafe extern "C" fn(data: gpointer, user_data: gpointer)>;
pub type GHashFunc = ::std::option::Option<unsafe extern "C" fn(key: gconstpointer) -> guint>;
pub type GHFunc = ::std::option::Option<
    unsafe extern "C" fn(key: gpointer, value: gpointer, user_data: gpointer),
>;
#[doc = " GCopyFunc:"]
#[doc = " @src: (not nullable): A pointer to the data which should be copied"]
#[doc = " @data: Additional data"]
#[doc = ""]
#[doc = " A function of this signature is used to copy the node data"]
#[doc = " when doing a deep-copy of a tree."]
#[doc = ""]
#[doc = " Returns: (not nullable): A pointer to the copy"]
#[doc = ""]
#[doc = " Since: 2.4"]
pub type GCopyFunc =
    ::std::option::Option<unsafe extern "C" fn(src: gconstpointer, data: gpointer) -> gpointer>;
#[doc = " GFreeFunc:"]
#[doc = " @data: a data pointer"]
#[doc = ""]
#[doc = " Declares a type of function which takes an arbitrary"]
#[doc = " data pointer argument and has no return value. It is"]
#[doc = " not currently used in GLib or GTK+."]
pub type GFreeFunc = ::std::option::Option<unsafe extern "C" fn(data: gpointer)>;
#[doc = " GTranslateFunc:"]
#[doc = " @str: the untranslated string"]
#[doc = " @data: user data specified when installing the function, e.g."]
#[doc = "  in g_option_group_set_translate_func()"]
#[doc = ""]
#[doc = " The type of functions which are used to translate user-visible"]
#[doc = " strings, for <option>--help</option> output."]
#[doc = ""]
#[doc = " Returns: a translation of the string for the current locale."]
#[doc = "  The returned string is owned by GLib and must not be freed."]
pub type GTranslateFunc =
    ::std::option::Option<unsafe extern "C" fn(str_: *const gchar, data: gpointer) -> *const gchar>;
pub type GDoubleIEEE754 = _GDoubleIEEE754;
pub type GFloatIEEE754 = _GFloatIEEE754;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GFloatIEEE754 {
    pub v_float: gfloat,
    pub mpn: _GFloatIEEE754__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _GFloatIEEE754__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__GFloatIEEE754__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_GFloatIEEE754__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_GFloatIEEE754__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFloatIEEE754__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_GFloatIEEE754__bindgen_ty_1))
    );
}
impl _GFloatIEEE754__bindgen_ty_1 {
    #[inline]
    pub fn mantissa(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set_mantissa(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub fn biased_exponent(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_biased_exponent(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn sign(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sign(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mantissa: guint,
        biased_exponent: guint,
        sign: guint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 23u8, {
            let mantissa: u32 = unsafe { ::std::mem::transmute(mantissa) };
            mantissa as u64
        });
        __bindgen_bitfield_unit.set(23usize, 8u8, {
            let biased_exponent: u32 = unsafe { ::std::mem::transmute(biased_exponent) };
            biased_exponent as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let sign: u32 = unsafe { ::std::mem::transmute(sign) };
            sign as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__GFloatIEEE754() {
    assert_eq!(
        ::std::mem::size_of::<_GFloatIEEE754>(),
        4usize,
        concat!("Size of: ", stringify!(_GFloatIEEE754))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFloatIEEE754>(),
        4usize,
        concat!("Alignment of ", stringify!(_GFloatIEEE754))
    );
    fn test_field_v_float() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GFloatIEEE754>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).v_float) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GFloatIEEE754),
                "::",
                stringify!(v_float)
            )
        );
    }
    test_field_v_float();
    fn test_field_mpn() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GFloatIEEE754>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mpn) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GFloatIEEE754),
                "::",
                stringify!(mpn)
            )
        );
    }
    test_field_mpn();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GDoubleIEEE754 {
    pub v_double: gdouble,
    pub mpn: _GDoubleIEEE754__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _GDoubleIEEE754__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout__GDoubleIEEE754__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_GDoubleIEEE754__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_GDoubleIEEE754__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDoubleIEEE754__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_GDoubleIEEE754__bindgen_ty_1))
    );
}
impl _GDoubleIEEE754__bindgen_ty_1 {
    #[inline]
    pub fn mantissa_low(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_mantissa_low(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn mantissa_high(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_mantissa_high(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn biased_exponent(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(52usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_biased_exponent(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(52usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn sign(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(63usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sign(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(63usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mantissa_low: guint,
        mantissa_high: guint,
        biased_exponent: guint,
        sign: guint,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let mantissa_low: u32 = unsafe { ::std::mem::transmute(mantissa_low) };
            mantissa_low as u64
        });
        __bindgen_bitfield_unit.set(32usize, 20u8, {
            let mantissa_high: u32 = unsafe { ::std::mem::transmute(mantissa_high) };
            mantissa_high as u64
        });
        __bindgen_bitfield_unit.set(52usize, 11u8, {
            let biased_exponent: u32 = unsafe { ::std::mem::transmute(biased_exponent) };
            biased_exponent as u64
        });
        __bindgen_bitfield_unit.set(63usize, 1u8, {
            let sign: u32 = unsafe { ::std::mem::transmute(sign) };
            sign as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__GDoubleIEEE754() {
    assert_eq!(
        ::std::mem::size_of::<_GDoubleIEEE754>(),
        8usize,
        concat!("Size of: ", stringify!(_GDoubleIEEE754))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDoubleIEEE754>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDoubleIEEE754))
    );
    fn test_field_v_double() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GDoubleIEEE754>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).v_double) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GDoubleIEEE754),
                "::",
                stringify!(v_double)
            )
        );
    }
    test_field_v_double();
    fn test_field_mpn() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GDoubleIEEE754>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mpn) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GDoubleIEEE754),
                "::",
                stringify!(mpn)
            )
        );
    }
    test_field_mpn();
}
pub type GTimeVal = _GTimeVal;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTimeVal {
    pub tv_sec: glong,
    pub tv_usec: glong,
}
#[test]
fn bindgen_test_layout__GTimeVal() {
    assert_eq!(
        ::std::mem::size_of::<_GTimeVal>(),
        16usize,
        concat!("Size of: ", stringify!(_GTimeVal))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTimeVal>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTimeVal))
    );
    fn test_field_tv_sec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GTimeVal>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GTimeVal),
                "::",
                stringify!(tv_sec)
            )
        );
    }
    test_field_tv_sec();
    fn test_field_tv_usec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GTimeVal>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_GTimeVal),
                "::",
                stringify!(tv_usec)
            )
        );
    }
    test_field_tv_usec();
}
pub type grefcount = gint;
pub type gatomicrefcount = gint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GBytes {
    _unused: [u8; 0],
}
pub type GBytes = _GBytes;
pub type GArray = _GArray;
pub type GByteArray = _GByteArray;
pub type GPtrArray = _GPtrArray;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GArray {
    pub data: *mut gchar,
    pub len: guint,
}
#[test]
fn bindgen_test_layout__GArray() {
    assert_eq!(
        ::std::mem::size_of::<_GArray>(),
        16usize,
        concat!("Size of: ", stringify!(_GArray))
    );
    assert_eq!(
        ::std::mem::align_of::<_GArray>(),
        8usize,
        concat!("Alignment of ", stringify!(_GArray))
    );
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GArray>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GArray),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_len() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GArray>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_GArray),
                "::",
                stringify!(len)
            )
        );
    }
    test_field_len();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GByteArray {
    pub data: *mut guint8,
    pub len: guint,
}
#[test]
fn bindgen_test_layout__GByteArray() {
    assert_eq!(
        ::std::mem::size_of::<_GByteArray>(),
        16usize,
        concat!("Size of: ", stringify!(_GByteArray))
    );
    assert_eq!(
        ::std::mem::align_of::<_GByteArray>(),
        8usize,
        concat!("Alignment of ", stringify!(_GByteArray))
    );
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GByteArray>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GByteArray),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_len() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GByteArray>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_GByteArray),
                "::",
                stringify!(len)
            )
        );
    }
    test_field_len();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPtrArray {
    pub pdata: *mut gpointer,
    pub len: guint,
}
#[test]
fn bindgen_test_layout__GPtrArray() {
    assert_eq!(
        ::std::mem::size_of::<_GPtrArray>(),
        16usize,
        concat!("Size of: ", stringify!(_GPtrArray))
    );
    assert_eq!(
        ::std::mem::align_of::<_GPtrArray>(),
        8usize,
        concat!("Alignment of ", stringify!(_GPtrArray))
    );
    fn test_field_pdata() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GPtrArray>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pdata) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GPtrArray),
                "::",
                stringify!(pdata)
            )
        );
    }
    test_field_pdata();
    fn test_field_len() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GPtrArray>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_GPtrArray),
                "::",
                stringify!(len)
            )
        );
    }
    test_field_len();
}
extern "C" {
    pub fn g_array_new(
        zero_terminated: gboolean,
        clear_: gboolean,
        element_size: guint,
    ) -> *mut GArray;
}
extern "C" {
    pub fn g_array_steal(array: *mut GArray, len: *mut gsize) -> gpointer;
}
extern "C" {
    pub fn g_array_sized_new(
        zero_terminated: gboolean,
        clear_: gboolean,
        element_size: guint,
        reserved_size: guint,
    ) -> *mut GArray;
}
extern "C" {
    pub fn g_array_copy(array: *mut GArray) -> *mut GArray;
}
extern "C" {
    pub fn g_array_free(array: *mut GArray, free_segment: gboolean) -> *mut gchar;
}
extern "C" {
    pub fn g_array_ref(array: *mut GArray) -> *mut GArray;
}
extern "C" {
    pub fn g_array_unref(array: *mut GArray);
}
extern "C" {
    pub fn g_array_get_element_size(array: *mut GArray) -> guint;
}
extern "C" {
    pub fn g_array_append_vals(array: *mut GArray, data: gconstpointer, len: guint) -> *mut GArray;
}
extern "C" {
    pub fn g_array_prepend_vals(array: *mut GArray, data: gconstpointer, len: guint)
        -> *mut GArray;
}
extern "C" {
    pub fn g_array_insert_vals(
        array: *mut GArray,
        index_: guint,
        data: gconstpointer,
        len: guint,
    ) -> *mut GArray;
}
extern "C" {
    pub fn g_array_set_size(array: *mut GArray, length: guint) -> *mut GArray;
}
extern "C" {
    pub fn g_array_remove_index(array: *mut GArray, index_: guint) -> *mut GArray;
}
extern "C" {
    pub fn g_array_remove_index_fast(array: *mut GArray, index_: guint) -> *mut GArray;
}
extern "C" {
    pub fn g_array_remove_range(array: *mut GArray, index_: guint, length: guint) -> *mut GArray;
}
extern "C" {
    pub fn g_array_sort(array: *mut GArray, compare_func: GCompareFunc);
}
extern "C" {
    pub fn g_array_sort_with_data(
        array: *mut GArray,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_array_binary_search(
        array: *mut GArray,
        target: gconstpointer,
        compare_func: GCompareFunc,
        out_match_index: *mut guint,
    ) -> gboolean;
}
extern "C" {
    pub fn g_array_set_clear_func(array: *mut GArray, clear_func: GDestroyNotify);
}
extern "C" {
    pub fn g_ptr_array_new() -> *mut GPtrArray;
}
extern "C" {
    pub fn g_ptr_array_new_with_free_func(element_free_func: GDestroyNotify) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_ptr_array_steal(array: *mut GPtrArray, len: *mut gsize) -> *mut gpointer;
}
extern "C" {
    pub fn g_ptr_array_copy(
        array: *mut GPtrArray,
        func: GCopyFunc,
        user_data: gpointer,
    ) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_ptr_array_sized_new(reserved_size: guint) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_ptr_array_new_full(
        reserved_size: guint,
        element_free_func: GDestroyNotify,
    ) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_ptr_array_free(array: *mut GPtrArray, free_seg: gboolean) -> *mut gpointer;
}
extern "C" {
    pub fn g_ptr_array_ref(array: *mut GPtrArray) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_ptr_array_unref(array: *mut GPtrArray);
}
extern "C" {
    pub fn g_ptr_array_set_free_func(array: *mut GPtrArray, element_free_func: GDestroyNotify);
}
extern "C" {
    pub fn g_ptr_array_set_size(array: *mut GPtrArray, length: gint);
}
extern "C" {
    pub fn g_ptr_array_remove_index(array: *mut GPtrArray, index_: guint) -> gpointer;
}
extern "C" {
    pub fn g_ptr_array_remove_index_fast(array: *mut GPtrArray, index_: guint) -> gpointer;
}
extern "C" {
    pub fn g_ptr_array_steal_index(array: *mut GPtrArray, index_: guint) -> gpointer;
}
extern "C" {
    pub fn g_ptr_array_steal_index_fast(array: *mut GPtrArray, index_: guint) -> gpointer;
}
extern "C" {
    pub fn g_ptr_array_remove(array: *mut GPtrArray, data: gpointer) -> gboolean;
}
extern "C" {
    pub fn g_ptr_array_remove_fast(array: *mut GPtrArray, data: gpointer) -> gboolean;
}
extern "C" {
    pub fn g_ptr_array_remove_range(
        array: *mut GPtrArray,
        index_: guint,
        length: guint,
    ) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_ptr_array_add(array: *mut GPtrArray, data: gpointer);
}
extern "C" {
    pub fn g_ptr_array_extend(
        array_to_extend: *mut GPtrArray,
        array: *mut GPtrArray,
        func: GCopyFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_ptr_array_extend_and_steal(array_to_extend: *mut GPtrArray, array: *mut GPtrArray);
}
extern "C" {
    pub fn g_ptr_array_insert(array: *mut GPtrArray, index_: gint, data: gpointer);
}
extern "C" {
    pub fn g_ptr_array_sort(array: *mut GPtrArray, compare_func: GCompareFunc);
}
extern "C" {
    pub fn g_ptr_array_sort_with_data(
        array: *mut GPtrArray,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_ptr_array_foreach(array: *mut GPtrArray, func: GFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_ptr_array_find(
        haystack: *mut GPtrArray,
        needle: gconstpointer,
        index_: *mut guint,
    ) -> gboolean;
}
extern "C" {
    pub fn g_ptr_array_find_with_equal_func(
        haystack: *mut GPtrArray,
        needle: gconstpointer,
        equal_func: GEqualFunc,
        index_: *mut guint,
    ) -> gboolean;
}
extern "C" {
    pub fn g_byte_array_new() -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_new_take(data: *mut guint8, len: gsize) -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_steal(array: *mut GByteArray, len: *mut gsize) -> *mut guint8;
}
extern "C" {
    pub fn g_byte_array_sized_new(reserved_size: guint) -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_free(array: *mut GByteArray, free_segment: gboolean) -> *mut guint8;
}
extern "C" {
    pub fn g_byte_array_free_to_bytes(array: *mut GByteArray) -> *mut GBytes;
}
extern "C" {
    pub fn g_byte_array_ref(array: *mut GByteArray) -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_unref(array: *mut GByteArray);
}
extern "C" {
    pub fn g_byte_array_append(
        array: *mut GByteArray,
        data: *const guint8,
        len: guint,
    ) -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_prepend(
        array: *mut GByteArray,
        data: *const guint8,
        len: guint,
    ) -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_set_size(array: *mut GByteArray, length: guint) -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_remove_index(array: *mut GByteArray, index_: guint) -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_remove_index_fast(array: *mut GByteArray, index_: guint)
        -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_remove_range(
        array: *mut GByteArray,
        index_: guint,
        length: guint,
    ) -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_sort(array: *mut GByteArray, compare_func: GCompareFunc);
}
extern "C" {
    pub fn g_byte_array_sort_with_data(
        array: *mut GByteArray,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_atomic_int_get(atomic: *const gint) -> gint;
}
extern "C" {
    pub fn g_atomic_int_set(atomic: *mut gint, newval: gint);
}
extern "C" {
    pub fn g_atomic_int_inc(atomic: *mut gint);
}
extern "C" {
    pub fn g_atomic_int_dec_and_test(atomic: *mut gint) -> gboolean;
}
extern "C" {
    pub fn g_atomic_int_compare_and_exchange(
        atomic: *mut gint,
        oldval: gint,
        newval: gint,
    ) -> gboolean;
}
extern "C" {
    pub fn g_atomic_int_add(atomic: *mut gint, val: gint) -> gint;
}
extern "C" {
    pub fn g_atomic_int_and(atomic: *mut guint, val: guint) -> guint;
}
extern "C" {
    pub fn g_atomic_int_or(atomic: *mut guint, val: guint) -> guint;
}
extern "C" {
    pub fn g_atomic_int_xor(atomic: *mut guint, val: guint) -> guint;
}
extern "C" {
    pub fn g_atomic_pointer_get(atomic: *const ::std::os::raw::c_void) -> gpointer;
}
extern "C" {
    pub fn g_atomic_pointer_set(atomic: *mut ::std::os::raw::c_void, newval: gpointer);
}
extern "C" {
    pub fn g_atomic_pointer_compare_and_exchange(
        atomic: *mut ::std::os::raw::c_void,
        oldval: gpointer,
        newval: gpointer,
    ) -> gboolean;
}
extern "C" {
    pub fn g_atomic_pointer_add(atomic: *mut ::std::os::raw::c_void, val: gssize) -> gssize;
}
extern "C" {
    pub fn g_atomic_pointer_and(atomic: *mut ::std::os::raw::c_void, val: gsize) -> gsize;
}
extern "C" {
    pub fn g_atomic_pointer_or(atomic: *mut ::std::os::raw::c_void, val: gsize) -> gsize;
}
extern "C" {
    pub fn g_atomic_pointer_xor(atomic: *mut ::std::os::raw::c_void, val: gsize) -> gsize;
}
extern "C" {
    pub fn g_atomic_int_exchange_and_add(atomic: *mut gint, val: gint) -> gint;
}
pub type va_list = [u64; 4usize];
pub type __gnuc_va_list = [u64; 4usize];
pub type GQuark = guint32;
extern "C" {
    pub fn g_quark_try_string(string: *const gchar) -> GQuark;
}
extern "C" {
    pub fn g_quark_from_static_string(string: *const gchar) -> GQuark;
}
extern "C" {
    pub fn g_quark_from_string(string: *const gchar) -> GQuark;
}
extern "C" {
    pub fn g_quark_to_string(quark: GQuark) -> *const gchar;
}
extern "C" {
    pub fn g_intern_string(string: *const gchar) -> *const gchar;
}
extern "C" {
    pub fn g_intern_static_string(string: *const gchar) -> *const gchar;
}
#[doc = " GError:"]
#[doc = " @domain: error domain, e.g. #G_FILE_ERROR"]
#[doc = " @code: error code, e.g. %G_FILE_ERROR_NOENT"]
#[doc = " @message: human-readable informative error message"]
#[doc = ""]
#[doc = " The `GError` structure contains information about"]
#[doc = " an error that has occurred."]
pub type GError = _GError;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GError {
    pub domain: GQuark,
    pub code: gint,
    pub message: *mut gchar,
}
#[test]
fn bindgen_test_layout__GError() {
    assert_eq!(
        ::std::mem::size_of::<_GError>(),
        16usize,
        concat!("Size of: ", stringify!(_GError))
    );
    assert_eq!(
        ::std::mem::align_of::<_GError>(),
        8usize,
        concat!("Alignment of ", stringify!(_GError))
    );
    fn test_field_domain() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GError>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).domain) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GError),
                "::",
                stringify!(domain)
            )
        );
    }
    test_field_domain();
    fn test_field_code() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GError>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).code) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_GError),
                "::",
                stringify!(code)
            )
        );
    }
    test_field_code();
    fn test_field_message() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GError>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).message) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_GError),
                "::",
                stringify!(message)
            )
        );
    }
    test_field_message();
}
extern "C" {
    pub fn g_error_new(domain: GQuark, code: gint, format: *const gchar, ...) -> *mut GError;
}
extern "C" {
    pub fn g_error_new_literal(domain: GQuark, code: gint, message: *const gchar) -> *mut GError;
}
extern "C" {
    pub fn g_error_new_valist(
        domain: GQuark,
        code: gint,
        format: *const gchar,
        args: va_list,
    ) -> *mut GError;
}
extern "C" {
    pub fn g_error_free(error: *mut GError);
}
extern "C" {
    pub fn g_error_copy(error: *const GError) -> *mut GError;
}
extern "C" {
    pub fn g_error_matches(error: *const GError, domain: GQuark, code: gint) -> gboolean;
}
extern "C" {
    pub fn g_set_error(
        err: *mut *mut GError,
        domain: GQuark,
        code: gint,
        format: *const gchar,
        ...
    );
}
extern "C" {
    pub fn g_set_error_literal(
        err: *mut *mut GError,
        domain: GQuark,
        code: gint,
        message: *const gchar,
    );
}
extern "C" {
    pub fn g_propagate_error(dest: *mut *mut GError, src: *mut GError);
}
extern "C" {
    pub fn g_clear_error(err: *mut *mut GError);
}
extern "C" {
    pub fn g_prefix_error(err: *mut *mut GError, format: *const gchar, ...);
}
extern "C" {
    pub fn g_propagate_prefixed_error(
        dest: *mut *mut GError,
        src: *mut GError,
        format: *const gchar,
        ...
    );
}
extern "C" {
    pub fn g_get_user_name() -> *const gchar;
}
extern "C" {
    pub fn g_get_real_name() -> *const gchar;
}
extern "C" {
    pub fn g_get_home_dir() -> *const gchar;
}
extern "C" {
    pub fn g_get_tmp_dir() -> *const gchar;
}
extern "C" {
    pub fn g_get_host_name() -> *const gchar;
}
extern "C" {
    pub fn g_get_prgname() -> *const gchar;
}
extern "C" {
    pub fn g_set_prgname(prgname: *const gchar);
}
extern "C" {
    pub fn g_get_application_name() -> *const gchar;
}
extern "C" {
    pub fn g_set_application_name(application_name: *const gchar);
}
extern "C" {
    pub fn g_get_os_info(key_name: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_reload_user_special_dirs_cache();
}
extern "C" {
    pub fn g_get_user_data_dir() -> *const gchar;
}
extern "C" {
    pub fn g_get_user_config_dir() -> *const gchar;
}
extern "C" {
    pub fn g_get_user_cache_dir() -> *const gchar;
}
extern "C" {
    pub fn g_get_system_data_dirs() -> *const *const gchar;
}
extern "C" {
    pub fn g_get_system_config_dirs() -> *const *const gchar;
}
extern "C" {
    pub fn g_get_user_runtime_dir() -> *const gchar;
}
pub const GUserDirectory_G_USER_DIRECTORY_DESKTOP: GUserDirectory = 0;
pub const GUserDirectory_G_USER_DIRECTORY_DOCUMENTS: GUserDirectory = 1;
pub const GUserDirectory_G_USER_DIRECTORY_DOWNLOAD: GUserDirectory = 2;
pub const GUserDirectory_G_USER_DIRECTORY_MUSIC: GUserDirectory = 3;
pub const GUserDirectory_G_USER_DIRECTORY_PICTURES: GUserDirectory = 4;
pub const GUserDirectory_G_USER_DIRECTORY_PUBLIC_SHARE: GUserDirectory = 5;
pub const GUserDirectory_G_USER_DIRECTORY_TEMPLATES: GUserDirectory = 6;
pub const GUserDirectory_G_USER_DIRECTORY_VIDEOS: GUserDirectory = 7;
pub const GUserDirectory_G_USER_N_DIRECTORIES: GUserDirectory = 8;
#[doc = " GUserDirectory:"]
#[doc = " @G_USER_DIRECTORY_DESKTOP: the user's Desktop directory"]
#[doc = " @G_USER_DIRECTORY_DOCUMENTS: the user's Documents directory"]
#[doc = " @G_USER_DIRECTORY_DOWNLOAD: the user's Downloads directory"]
#[doc = " @G_USER_DIRECTORY_MUSIC: the user's Music directory"]
#[doc = " @G_USER_DIRECTORY_PICTURES: the user's Pictures directory"]
#[doc = " @G_USER_DIRECTORY_PUBLIC_SHARE: the user's shared directory"]
#[doc = " @G_USER_DIRECTORY_TEMPLATES: the user's Templates directory"]
#[doc = " @G_USER_DIRECTORY_VIDEOS: the user's Movies directory"]
#[doc = " @G_USER_N_DIRECTORIES: the number of enum values"]
#[doc = ""]
#[doc = " These are logical ids for special directories which are defined"]
#[doc = " depending on the platform used. You should use g_get_user_special_dir()"]
#[doc = " to retrieve the full path associated to the logical id."]
#[doc = ""]
#[doc = " The #GUserDirectory enumeration can be extended at later date. Not"]
#[doc = " every platform has a directory for every logical id in this"]
#[doc = " enumeration."]
#[doc = ""]
#[doc = " Since: 2.14"]
pub type GUserDirectory = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_get_user_special_dir(directory: GUserDirectory) -> *const gchar;
}
#[doc = " GDebugKey:"]
#[doc = " @key: the string"]
#[doc = " @value: the flag"]
#[doc = ""]
#[doc = " Associates a string with a bit flag."]
#[doc = " Used in g_parse_debug_string()."]
pub type GDebugKey = _GDebugKey;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDebugKey {
    pub key: *const gchar,
    pub value: guint,
}
#[test]
fn bindgen_test_layout__GDebugKey() {
    assert_eq!(
        ::std::mem::size_of::<_GDebugKey>(),
        16usize,
        concat!("Size of: ", stringify!(_GDebugKey))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDebugKey>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDebugKey))
    );
    fn test_field_key() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GDebugKey>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GDebugKey),
                "::",
                stringify!(key)
            )
        );
    }
    test_field_key();
    fn test_field_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GDebugKey>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_GDebugKey),
                "::",
                stringify!(value)
            )
        );
    }
    test_field_value();
}
extern "C" {
    pub fn g_parse_debug_string(
        string: *const gchar,
        keys: *const GDebugKey,
        nkeys: guint,
    ) -> guint;
}
extern "C" {
    pub fn g_snprintf(string: *mut gchar, n: gulong, format: *const gchar, ...) -> gint;
}
extern "C" {
    pub fn g_vsnprintf(string: *mut gchar, n: gulong, format: *const gchar, args: va_list) -> gint;
}
extern "C" {
    pub fn g_nullify_pointer(nullify_location: *mut gpointer);
}
pub const GFormatSizeFlags_G_FORMAT_SIZE_DEFAULT: GFormatSizeFlags = 0;
pub const GFormatSizeFlags_G_FORMAT_SIZE_LONG_FORMAT: GFormatSizeFlags = 1;
pub const GFormatSizeFlags_G_FORMAT_SIZE_IEC_UNITS: GFormatSizeFlags = 2;
pub const GFormatSizeFlags_G_FORMAT_SIZE_BITS: GFormatSizeFlags = 4;
pub type GFormatSizeFlags = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_format_size_full(size: guint64, flags: GFormatSizeFlags) -> *mut gchar;
}
extern "C" {
    pub fn g_format_size(size: guint64) -> *mut gchar;
}
extern "C" {
    pub fn g_format_size_for_display(size: goffset) -> *mut gchar;
}
#[doc = " GVoidFunc:"]
#[doc = ""]
#[doc = " Declares a type of function which takes no arguments"]
#[doc = " and has no return value. It is used to specify the type"]
#[doc = " function passed to g_atexit()."]
pub type GVoidFunc = ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    pub fn g_atexit(func: GVoidFunc);
}
extern "C" {
    pub fn g_find_program_in_path(program: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_bit_nth_lsf(mask: gulong, nth_bit: gint) -> gint;
}
extern "C" {
    pub fn g_bit_nth_msf(mask: gulong, nth_bit: gint) -> gint;
}
extern "C" {
    pub fn g_bit_storage(number: gulong) -> guint;
}
pub const idtype_t_P_ALL: idtype_t = 0;
pub const idtype_t_P_PID: idtype_t = 1;
pub const idtype_t_P_PGID: idtype_t = 2;
pub type idtype_t = ::std::os::raw::c_uint;
pub type _Float128 = u128;
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    fn test_field_quot() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<div_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(div_t),
                "::",
                stringify!(quot)
            )
        );
    }
    test_field_quot();
    fn test_field_rem() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<div_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(div_t),
                "::",
                stringify!(rem)
            )
        );
    }
    test_field_rem();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    fn test_field_quot() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ldiv_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ldiv_t),
                "::",
                stringify!(quot)
            )
        );
    }
    test_field_quot();
    fn test_field_rem() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ldiv_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ldiv_t),
                "::",
                stringify!(rem)
            )
        );
    }
    test_field_rem();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    fn test_field_quot() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<lldiv_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(lldiv_t),
                "::",
                stringify!(quot)
            )
        );
    }
    test_field_quot();
    fn test_field_rem() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<lldiv_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(lldiv_t),
                "::",
                stringify!(rem)
            )
        );
    }
    test_field_rem();
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> size_t;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type id_t = __id_t;
pub type ssize_t = __ssize_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    fn test_field___val() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sigset_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__sigset_t),
                "::",
                stringify!(__val)
            )
        );
    }
    test_field___val();
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    fn test_field_tv_sec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<timeval>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(timeval),
                "::",
                stringify!(tv_sec)
            )
        );
    }
    test_field_tv_sec();
    fn test_field_tv_usec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<timeval>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(timeval),
                "::",
                stringify!(tv_usec)
            )
        );
    }
    test_field_tv_usec();
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    fn test_field___fds_bits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fd_set>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__fds_bits) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fd_set),
                "::",
                stringify!(__fds_bits)
            )
        );
    }
    test_field___fds_bits();
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    fn test_field___prev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_internal_list>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__prev) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_internal_list),
                "::",
                stringify!(__prev)
            )
        );
    }
    test_field___prev();
    fn test_field___next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_internal_list>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_internal_list),
                "::",
                stringify!(__next)
            )
        );
    }
    test_field___next();
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    fn test_field___next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_internal_slist>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_internal_slist),
                "::",
                stringify!(__next)
            )
        );
    }
    test_field___next();
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_int,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    fn test_field___lock() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_mutex_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__lock) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__lock)
            )
        );
    }
    test_field___lock();
    fn test_field___count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_mutex_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__count)
            )
        );
    }
    test_field___count();
    fn test_field___owner() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_mutex_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__owner) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__owner)
            )
        );
    }
    test_field___owner();
    fn test_field___nusers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_mutex_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__nusers) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__nusers)
            )
        );
    }
    test_field___nusers();
    fn test_field___kind() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_mutex_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__kind) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__kind)
            )
        );
    }
    test_field___kind();
    fn test_field___spins() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_mutex_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__spins) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__spins)
            )
        );
    }
    test_field___spins();
    fn test_field___list() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_mutex_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__list) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__list)
            )
        );
    }
    test_field___list();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __pad1: ::std::os::raw::c_ulong,
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    fn test_field___readers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__readers) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__readers)
            )
        );
    }
    test_field___readers();
    fn test_field___writers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__writers) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__writers)
            )
        );
    }
    test_field___writers();
    fn test_field___wrphase_futex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__wrphase_futex) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__wrphase_futex)
            )
        );
    }
    test_field___wrphase_futex();
    fn test_field___writers_futex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__writers_futex) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__writers_futex)
            )
        );
    }
    test_field___writers_futex();
    fn test_field___pad3() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pad3) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__pad3)
            )
        );
    }
    test_field___pad3();
    fn test_field___pad4() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pad4) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__pad4)
            )
        );
    }
    test_field___pad4();
    fn test_field___cur_writer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__cur_writer) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__cur_writer)
            )
        );
    }
    test_field___cur_writer();
    fn test_field___shared() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__shared) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__shared)
            )
        );
    }
    test_field___shared();
    fn test_field___pad1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pad1) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__pad1)
            )
        );
    }
    test_field___pad1();
    fn test_field___pad2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pad2) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__pad2)
            )
        );
    }
    test_field___pad2();
    fn test_field___flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__flags) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__flags)
            )
        );
    }
    test_field___flags();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __bindgen_anon_1: __pthread_cond_s__bindgen_ty_1,
    pub __bindgen_anon_2: __pthread_cond_s__bindgen_ty_2,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_1 {
    pub __wseq: ::std::os::raw::c_ulonglong,
    pub __wseq32: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    fn test_field___low() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__low) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(__low)
            )
        );
    }
    test_field___low();
    fn test_field___high() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__high) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(__high)
            )
        );
    }
    test_field___high();
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    fn test_field___wseq() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_cond_s__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__wseq) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s__bindgen_ty_1),
                "::",
                stringify!(__wseq)
            )
        );
    }
    test_field___wseq();
    fn test_field___wseq32() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_cond_s__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__wseq32) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s__bindgen_ty_1),
                "::",
                stringify!(__wseq32)
            )
        );
    }
    test_field___wseq32();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_2 {
    pub __g1_start: ::std::os::raw::c_ulonglong,
    pub __g1_start32: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    fn test_field___low() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__low) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
                "::",
                stringify!(__low)
            )
        );
    }
    test_field___low();
    fn test_field___high() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__high) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
                "::",
                stringify!(__high)
            )
        );
    }
    test_field___high();
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    fn test_field___g1_start() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_cond_s__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__g1_start) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s__bindgen_ty_2),
                "::",
                stringify!(__g1_start)
            )
        );
    }
    test_field___g1_start();
    fn test_field___g1_start32() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_cond_s__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__g1_start32) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s__bindgen_ty_2),
                "::",
                stringify!(__g1_start32)
            )
        );
    }
    test_field___g1_start32();
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    fn test_field___g_refs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_cond_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__g_refs) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s),
                "::",
                stringify!(__g_refs)
            )
        );
    }
    test_field___g_refs();
    fn test_field___g_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_cond_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__g_size) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s),
                "::",
                stringify!(__g_size)
            )
        );
    }
    test_field___g_size();
    fn test_field___g1_orig_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_cond_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__g1_orig_size) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s),
                "::",
                stringify!(__g1_orig_size)
            )
        );
    }
    test_field___g1_orig_size();
    fn test_field___wrefs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_cond_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__wrefs) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s),
                "::",
                stringify!(__wrefs)
            )
        );
    }
    test_field___wrefs();
    fn test_field___g_signals() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_cond_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__g_signals) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s),
                "::",
                stringify!(__g_signals)
            )
        );
    }
    test_field___g_signals();
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    fn test_field___size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_mutexattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_mutexattr_t),
                "::",
                stringify!(__size)
            )
        );
    }
    test_field___size();
    fn test_field___align() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_mutexattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_mutexattr_t),
                "::",
                stringify!(__align)
            )
        );
    }
    test_field___align();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    fn test_field___size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_condattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_condattr_t),
                "::",
                stringify!(__size)
            )
        );
    }
    test_field___size();
    fn test_field___align() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_condattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_condattr_t),
                "::",
                stringify!(__align)
            )
        );
    }
    test_field___align();
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 64usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        64usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    fn test_field___size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_attr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_attr_t),
                "::",
                stringify!(__size)
            )
        );
    }
    test_field___size();
    fn test_field___align() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_attr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_attr_t),
                "::",
                stringify!(__align)
            )
        );
    }
    test_field___align();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    fn test_field___data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_mutex_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_mutex_t),
                "::",
                stringify!(__data)
            )
        );
    }
    test_field___data();
    fn test_field___size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_mutex_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_mutex_t),
                "::",
                stringify!(__size)
            )
        );
    }
    test_field___size();
    fn test_field___align() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_mutex_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_mutex_t),
                "::",
                stringify!(__align)
            )
        );
    }
    test_field___align();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    fn test_field___data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_cond_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_cond_t),
                "::",
                stringify!(__data)
            )
        );
    }
    test_field___data();
    fn test_field___size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_cond_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_cond_t),
                "::",
                stringify!(__size)
            )
        );
    }
    test_field___size();
    fn test_field___align() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_cond_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_cond_t),
                "::",
                stringify!(__align)
            )
        );
    }
    test_field___align();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    fn test_field___data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_rwlock_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_rwlock_t),
                "::",
                stringify!(__data)
            )
        );
    }
    test_field___data();
    fn test_field___size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_rwlock_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_rwlock_t),
                "::",
                stringify!(__size)
            )
        );
    }
    test_field___size();
    fn test_field___align() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_rwlock_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_rwlock_t),
                "::",
                stringify!(__align)
            )
        );
    }
    test_field___align();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    fn test_field___size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_rwlockattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_rwlockattr_t),
                "::",
                stringify!(__size)
            )
        );
    }
    test_field___size();
    fn test_field___align() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_rwlockattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_rwlockattr_t),
                "::",
                stringify!(__align)
            )
        );
    }
    test_field___align();
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    fn test_field___size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_barrier_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_barrier_t),
                "::",
                stringify!(__size)
            )
        );
    }
    test_field___size();
    fn test_field___align() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_barrier_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_barrier_t),
                "::",
                stringify!(__align)
            )
        );
    }
    test_field___align();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    fn test_field___size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_barrierattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_barrierattr_t),
                "::",
                stringify!(__size)
            )
        );
    }
    test_field___size();
    fn test_field___align() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_barrierattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_barrierattr_t),
                "::",
                stringify!(__align)
            )
        );
    }
    test_field___align();
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    assert_eq!(
        ::std::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::std::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    fn test_field_fptr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<random_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fptr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(random_data),
                "::",
                stringify!(fptr)
            )
        );
    }
    test_field_fptr();
    fn test_field_rptr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<random_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rptr) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(random_data),
                "::",
                stringify!(rptr)
            )
        );
    }
    test_field_rptr();
    fn test_field_state() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<random_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(random_data),
                "::",
                stringify!(state)
            )
        );
    }
    test_field_state();
    fn test_field_rand_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<random_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rand_type) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(random_data),
                "::",
                stringify!(rand_type)
            )
        );
    }
    test_field_rand_type();
    fn test_field_rand_deg() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<random_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rand_deg) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(random_data),
                "::",
                stringify!(rand_deg)
            )
        );
    }
    test_field_rand_deg();
    fn test_field_rand_sep() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<random_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rand_sep) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(random_data),
                "::",
                stringify!(rand_sep)
            )
        );
    }
    test_field_rand_sep();
    fn test_field_end_ptr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<random_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).end_ptr) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(random_data),
                "::",
                stringify!(end_ptr)
            )
        );
    }
    test_field_end_ptr();
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: size_t,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    assert_eq!(
        ::std::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::std::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    fn test_field___x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<drand48_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__x) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(drand48_data),
                "::",
                stringify!(__x)
            )
        );
    }
    test_field___x();
    fn test_field___old_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<drand48_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__old_x) as usize - ptr as usize
            },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(drand48_data),
                "::",
                stringify!(__old_x)
            )
        );
    }
    test_field___old_x();
    fn test_field___c() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<drand48_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__c) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(drand48_data),
                "::",
                stringify!(__c)
            )
        );
    }
    test_field___c();
    fn test_field___init() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<drand48_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__init) as usize - ptr as usize
            },
            14usize,
            concat!(
                "Offset of field: ",
                stringify!(drand48_data),
                "::",
                stringify!(__init)
            )
        );
    }
    test_field___init();
    fn test_field___a() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<drand48_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__a) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(drand48_data),
                "::",
                stringify!(__a)
            )
        );
    }
    test_field___a();
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: size_t,
        __size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: size_t,
        __size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(__alignment: size_t, __size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(
        __pwcs: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn wcstombs(
        __s: *mut ::std::os::raw::c_char,
        __pwcs: *const wchar_t,
        __n: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn g_thread_error_quark() -> GQuark;
}
pub const GThreadError_G_THREAD_ERROR_AGAIN: GThreadError = 0;
pub type GThreadError = ::std::os::raw::c_uint;
pub type GThreadFunc = ::std::option::Option<unsafe extern "C" fn(data: gpointer) -> gpointer>;
pub type GThread = _GThread;
pub type GMutex = _GMutex;
pub type GRecMutex = _GRecMutex;
pub type GRWLock = _GRWLock;
pub type GCond = _GCond;
pub type GPrivate = _GPrivate;
pub type GOnce = _GOnce;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GMutex {
    pub p: gpointer,
    pub i: [guint; 2usize],
}
#[test]
fn bindgen_test_layout__GMutex() {
    assert_eq!(
        ::std::mem::size_of::<_GMutex>(),
        8usize,
        concat!("Size of: ", stringify!(_GMutex))
    );
    assert_eq!(
        ::std::mem::align_of::<_GMutex>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMutex))
    );
    fn test_field_p() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GMutex>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GMutex),
                "::",
                stringify!(p)
            )
        );
    }
    test_field_p();
    fn test_field_i() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GMutex>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).i) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GMutex),
                "::",
                stringify!(i)
            )
        );
    }
    test_field_i();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRWLock {
    pub p: gpointer,
    pub i: [guint; 2usize],
}
#[test]
fn bindgen_test_layout__GRWLock() {
    assert_eq!(
        ::std::mem::size_of::<_GRWLock>(),
        16usize,
        concat!("Size of: ", stringify!(_GRWLock))
    );
    assert_eq!(
        ::std::mem::align_of::<_GRWLock>(),
        8usize,
        concat!("Alignment of ", stringify!(_GRWLock))
    );
    fn test_field_p() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GRWLock>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GRWLock),
                "::",
                stringify!(p)
            )
        );
    }
    test_field_p();
    fn test_field_i() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GRWLock>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).i) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_GRWLock),
                "::",
                stringify!(i)
            )
        );
    }
    test_field_i();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCond {
    pub p: gpointer,
    pub i: [guint; 2usize],
}
#[test]
fn bindgen_test_layout__GCond() {
    assert_eq!(
        ::std::mem::size_of::<_GCond>(),
        16usize,
        concat!("Size of: ", stringify!(_GCond))
    );
    assert_eq!(
        ::std::mem::align_of::<_GCond>(),
        8usize,
        concat!("Alignment of ", stringify!(_GCond))
    );
    fn test_field_p() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GCond>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(_GCond), "::", stringify!(p))
        );
    }
    test_field_p();
    fn test_field_i() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GCond>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).i) as usize - ptr as usize
            },
            8usize,
            concat!("Offset of field: ", stringify!(_GCond), "::", stringify!(i))
        );
    }
    test_field_i();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRecMutex {
    pub p: gpointer,
    pub i: [guint; 2usize],
}
#[test]
fn bindgen_test_layout__GRecMutex() {
    assert_eq!(
        ::std::mem::size_of::<_GRecMutex>(),
        16usize,
        concat!("Size of: ", stringify!(_GRecMutex))
    );
    assert_eq!(
        ::std::mem::align_of::<_GRecMutex>(),
        8usize,
        concat!("Alignment of ", stringify!(_GRecMutex))
    );
    fn test_field_p() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GRecMutex>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GRecMutex),
                "::",
                stringify!(p)
            )
        );
    }
    test_field_p();
    fn test_field_i() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GRecMutex>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).i) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_GRecMutex),
                "::",
                stringify!(i)
            )
        );
    }
    test_field_i();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPrivate {
    pub p: gpointer,
    pub notify: GDestroyNotify,
    pub future: [gpointer; 2usize],
}
#[test]
fn bindgen_test_layout__GPrivate() {
    assert_eq!(
        ::std::mem::size_of::<_GPrivate>(),
        32usize,
        concat!("Size of: ", stringify!(_GPrivate))
    );
    assert_eq!(
        ::std::mem::align_of::<_GPrivate>(),
        8usize,
        concat!("Alignment of ", stringify!(_GPrivate))
    );
    fn test_field_p() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GPrivate>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GPrivate),
                "::",
                stringify!(p)
            )
        );
    }
    test_field_p();
    fn test_field_notify() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GPrivate>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).notify) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_GPrivate),
                "::",
                stringify!(notify)
            )
        );
    }
    test_field_notify();
    fn test_field_future() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GPrivate>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).future) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_GPrivate),
                "::",
                stringify!(future)
            )
        );
    }
    test_field_future();
}
pub const GOnceStatus_G_ONCE_STATUS_NOTCALLED: GOnceStatus = 0;
pub const GOnceStatus_G_ONCE_STATUS_PROGRESS: GOnceStatus = 1;
pub const GOnceStatus_G_ONCE_STATUS_READY: GOnceStatus = 2;
pub type GOnceStatus = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GOnce {
    pub status: GOnceStatus,
    pub retval: gpointer,
}
#[test]
fn bindgen_test_layout__GOnce() {
    assert_eq!(
        ::std::mem::size_of::<_GOnce>(),
        16usize,
        concat!("Size of: ", stringify!(_GOnce))
    );
    assert_eq!(
        ::std::mem::align_of::<_GOnce>(),
        8usize,
        concat!("Alignment of ", stringify!(_GOnce))
    );
    fn test_field_status() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GOnce>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GOnce),
                "::",
                stringify!(status)
            )
        );
    }
    test_field_status();
    fn test_field_retval() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GOnce>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).retval) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_GOnce),
                "::",
                stringify!(retval)
            )
        );
    }
    test_field_retval();
}
extern "C" {
    pub fn g_thread_ref(thread: *mut GThread) -> *mut GThread;
}
extern "C" {
    pub fn g_thread_unref(thread: *mut GThread);
}
extern "C" {
    pub fn g_thread_new(name: *const gchar, func: GThreadFunc, data: gpointer) -> *mut GThread;
}
extern "C" {
    pub fn g_thread_try_new(
        name: *const gchar,
        func: GThreadFunc,
        data: gpointer,
        error: *mut *mut GError,
    ) -> *mut GThread;
}
extern "C" {
    pub fn g_thread_self() -> *mut GThread;
}
extern "C" {
    pub fn g_thread_exit(retval: gpointer);
}
extern "C" {
    pub fn g_thread_join(thread: *mut GThread) -> gpointer;
}
extern "C" {
    pub fn g_thread_yield();
}
extern "C" {
    pub fn g_mutex_init(mutex: *mut GMutex);
}
extern "C" {
    pub fn g_mutex_clear(mutex: *mut GMutex);
}
extern "C" {
    pub fn g_mutex_lock(mutex: *mut GMutex);
}
extern "C" {
    pub fn g_mutex_trylock(mutex: *mut GMutex) -> gboolean;
}
extern "C" {
    pub fn g_mutex_unlock(mutex: *mut GMutex);
}
extern "C" {
    pub fn g_rw_lock_init(rw_lock: *mut GRWLock);
}
extern "C" {
    pub fn g_rw_lock_clear(rw_lock: *mut GRWLock);
}
extern "C" {
    pub fn g_rw_lock_writer_lock(rw_lock: *mut GRWLock);
}
extern "C" {
    pub fn g_rw_lock_writer_trylock(rw_lock: *mut GRWLock) -> gboolean;
}
extern "C" {
    pub fn g_rw_lock_writer_unlock(rw_lock: *mut GRWLock);
}
extern "C" {
    pub fn g_rw_lock_reader_lock(rw_lock: *mut GRWLock);
}
extern "C" {
    pub fn g_rw_lock_reader_trylock(rw_lock: *mut GRWLock) -> gboolean;
}
extern "C" {
    pub fn g_rw_lock_reader_unlock(rw_lock: *mut GRWLock);
}
extern "C" {
    pub fn g_rec_mutex_init(rec_mutex: *mut GRecMutex);
}
extern "C" {
    pub fn g_rec_mutex_clear(rec_mutex: *mut GRecMutex);
}
extern "C" {
    pub fn g_rec_mutex_lock(rec_mutex: *mut GRecMutex);
}
extern "C" {
    pub fn g_rec_mutex_trylock(rec_mutex: *mut GRecMutex) -> gboolean;
}
extern "C" {
    pub fn g_rec_mutex_unlock(rec_mutex: *mut GRecMutex);
}
extern "C" {
    pub fn g_cond_init(cond: *mut GCond);
}
extern "C" {
    pub fn g_cond_clear(cond: *mut GCond);
}
extern "C" {
    pub fn g_cond_wait(cond: *mut GCond, mutex: *mut GMutex);
}
extern "C" {
    pub fn g_cond_signal(cond: *mut GCond);
}
extern "C" {
    pub fn g_cond_broadcast(cond: *mut GCond);
}
extern "C" {
    pub fn g_cond_wait_until(cond: *mut GCond, mutex: *mut GMutex, end_time: gint64) -> gboolean;
}
extern "C" {
    pub fn g_private_get(key: *mut GPrivate) -> gpointer;
}
extern "C" {
    pub fn g_private_set(key: *mut GPrivate, value: gpointer);
}
extern "C" {
    pub fn g_private_replace(key: *mut GPrivate, value: gpointer);
}
extern "C" {
    pub fn g_once_impl(once: *mut GOnce, func: GThreadFunc, arg: gpointer) -> gpointer;
}
extern "C" {
    pub fn g_once_init_enter(location: *mut ::std::os::raw::c_void) -> gboolean;
}
extern "C" {
    pub fn g_once_init_leave(location: *mut ::std::os::raw::c_void, result: gsize);
}
extern "C" {
    pub fn g_get_num_processors() -> guint;
}
#[doc = " GMutexLocker:"]
#[doc = ""]
#[doc = " Opaque type. See g_mutex_locker_new() for details."]
#[doc = " Since: 2.44"]
pub type GMutexLocker = ::std::os::raw::c_void;
#[doc = " GRecMutexLocker:"]
#[doc = ""]
#[doc = " Opaque type. See g_rec_mutex_locker_new() for details."]
#[doc = " Since: 2.60"]
pub type GRecMutexLocker = ::std::os::raw::c_void;
#[doc = " GRWLockWriterLocker:"]
#[doc = ""]
#[doc = " Opaque type. See g_rw_lock_writer_locker_new() for details."]
#[doc = " Since: 2.62"]
pub type GRWLockWriterLocker = ::std::os::raw::c_void;
#[doc = " GRWLockReaderLocker:"]
#[doc = ""]
#[doc = " Opaque type. See g_rw_lock_reader_locker_new() for details."]
#[doc = " Since: 2.62"]
pub type GRWLockReaderLocker = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GAsyncQueue {
    _unused: [u8; 0],
}
pub type GAsyncQueue = _GAsyncQueue;
extern "C" {
    pub fn g_async_queue_new() -> *mut GAsyncQueue;
}
extern "C" {
    pub fn g_async_queue_new_full(item_free_func: GDestroyNotify) -> *mut GAsyncQueue;
}
extern "C" {
    pub fn g_async_queue_lock(queue: *mut GAsyncQueue);
}
extern "C" {
    pub fn g_async_queue_unlock(queue: *mut GAsyncQueue);
}
extern "C" {
    pub fn g_async_queue_ref(queue: *mut GAsyncQueue) -> *mut GAsyncQueue;
}
extern "C" {
    pub fn g_async_queue_unref(queue: *mut GAsyncQueue);
}
extern "C" {
    pub fn g_async_queue_ref_unlocked(queue: *mut GAsyncQueue);
}
extern "C" {
    pub fn g_async_queue_unref_and_unlock(queue: *mut GAsyncQueue);
}
extern "C" {
    pub fn g_async_queue_push(queue: *mut GAsyncQueue, data: gpointer);
}
extern "C" {
    pub fn g_async_queue_push_unlocked(queue: *mut GAsyncQueue, data: gpointer);
}
extern "C" {
    pub fn g_async_queue_push_sorted(
        queue: *mut GAsyncQueue,
        data: gpointer,
        func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_async_queue_push_sorted_unlocked(
        queue: *mut GAsyncQueue,
        data: gpointer,
        func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_async_queue_pop(queue: *mut GAsyncQueue) -> gpointer;
}
extern "C" {
    pub fn g_async_queue_pop_unlocked(queue: *mut GAsyncQueue) -> gpointer;
}
extern "C" {
    pub fn g_async_queue_try_pop(queue: *mut GAsyncQueue) -> gpointer;
}
extern "C" {
    pub fn g_async_queue_try_pop_unlocked(queue: *mut GAsyncQueue) -> gpointer;
}
extern "C" {
    pub fn g_async_queue_timeout_pop(queue: *mut GAsyncQueue, timeout: guint64) -> gpointer;
}
extern "C" {
    pub fn g_async_queue_timeout_pop_unlocked(
        queue: *mut GAsyncQueue,
        timeout: guint64,
    ) -> gpointer;
}
extern "C" {
    pub fn g_async_queue_length(queue: *mut GAsyncQueue) -> gint;
}
extern "C" {
    pub fn g_async_queue_length_unlocked(queue: *mut GAsyncQueue) -> gint;
}
extern "C" {
    pub fn g_async_queue_sort(queue: *mut GAsyncQueue, func: GCompareDataFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_async_queue_sort_unlocked(
        queue: *mut GAsyncQueue,
        func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_async_queue_remove(queue: *mut GAsyncQueue, item: gpointer) -> gboolean;
}
extern "C" {
    pub fn g_async_queue_remove_unlocked(queue: *mut GAsyncQueue, item: gpointer) -> gboolean;
}
extern "C" {
    pub fn g_async_queue_push_front(queue: *mut GAsyncQueue, item: gpointer);
}
extern "C" {
    pub fn g_async_queue_push_front_unlocked(queue: *mut GAsyncQueue, item: gpointer);
}
extern "C" {
    pub fn g_async_queue_timed_pop(queue: *mut GAsyncQueue, end_time: *mut GTimeVal) -> gpointer;
}
extern "C" {
    pub fn g_async_queue_timed_pop_unlocked(
        queue: *mut GAsyncQueue,
        end_time: *mut GTimeVal,
    ) -> gpointer;
}
pub type sig_atomic_t = __sig_atomic_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ::std::os::raw::c_int,
    pub sival_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_sigval() {
    assert_eq!(
        ::std::mem::size_of::<sigval>(),
        8usize,
        concat!("Size of: ", stringify!(sigval))
    );
    assert_eq!(
        ::std::mem::align_of::<sigval>(),
        8usize,
        concat!("Alignment of ", stringify!(sigval))
    );
    fn test_field_sival_int() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigval>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sival_int) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sigval),
                "::",
                stringify!(sival_int)
            )
        );
    }
    test_field_sival_int();
    fn test_field_sival_ptr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigval>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sival_ptr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sigval),
                "::",
                stringify!(sival_ptr)
            )
        );
    }
    test_field_sival_ptr();
}
pub type __sigval_t = sigval;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t {
    pub si_signo: ::std::os::raw::c_int,
    pub si_errno: ::std::os::raw::c_int,
    pub si_code: ::std::os::raw::c_int,
    pub __pad0: ::std::os::raw::c_int,
    pub _sifields: siginfo_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union siginfo_t__bindgen_ty_1 {
    pub _pad: [::std::os::raw::c_int; 28usize],
    pub _kill: siginfo_t__bindgen_ty_1__bindgen_ty_1,
    pub _timer: siginfo_t__bindgen_ty_1__bindgen_ty_2,
    pub _rt: siginfo_t__bindgen_ty_1__bindgen_ty_3,
    pub _sigchld: siginfo_t__bindgen_ty_1__bindgen_ty_4,
    pub _sigfault: siginfo_t__bindgen_ty_1__bindgen_ty_5,
    pub _sigpoll: siginfo_t__bindgen_ty_1__bindgen_ty_6,
    pub _sigsys: siginfo_t__bindgen_ty_1__bindgen_ty_7,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_1 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    fn test_field_si_pid() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<siginfo_t__bindgen_ty_1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_pid) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(si_pid)
            )
        );
    }
    test_field_si_pid();
    fn test_field_si_uid() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<siginfo_t__bindgen_ty_1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_uid) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(si_uid)
            )
        );
    }
    test_field_si_uid();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_2 {
    pub si_tid: ::std::os::raw::c_int,
    pub si_overrun: ::std::os::raw::c_int,
    pub si_sigval: __sigval_t,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_2>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2)
        )
    );
    fn test_field_si_tid() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<siginfo_t__bindgen_ty_1__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_tid) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(si_tid)
            )
        );
    }
    test_field_si_tid();
    fn test_field_si_overrun() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<siginfo_t__bindgen_ty_1__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_overrun) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(si_overrun)
            )
        );
    }
    test_field_si_overrun();
    fn test_field_si_sigval() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<siginfo_t__bindgen_ty_1__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_sigval) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(si_sigval)
            )
        );
    }
    test_field_si_sigval();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_3 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_sigval: __sigval_t,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_3>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_3)
        )
    );
    fn test_field_si_pid() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<siginfo_t__bindgen_ty_1__bindgen_ty_3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_pid) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_3),
                "::",
                stringify!(si_pid)
            )
        );
    }
    test_field_si_pid();
    fn test_field_si_uid() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<siginfo_t__bindgen_ty_1__bindgen_ty_3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_uid) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_3),
                "::",
                stringify!(si_uid)
            )
        );
    }
    test_field_si_uid();
    fn test_field_si_sigval() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<siginfo_t__bindgen_ty_1__bindgen_ty_3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_sigval) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_3),
                "::",
                stringify!(si_sigval)
            )
        );
    }
    test_field_si_sigval();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_4 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_status: ::std::os::raw::c_int,
    pub si_utime: __clock_t,
    pub si_stime: __clock_t,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_4>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4)
        )
    );
    fn test_field_si_pid() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<siginfo_t__bindgen_ty_1__bindgen_ty_4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_pid) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4),
                "::",
                stringify!(si_pid)
            )
        );
    }
    test_field_si_pid();
    fn test_field_si_uid() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<siginfo_t__bindgen_ty_1__bindgen_ty_4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_uid) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4),
                "::",
                stringify!(si_uid)
            )
        );
    }
    test_field_si_uid();
    fn test_field_si_status() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<siginfo_t__bindgen_ty_1__bindgen_ty_4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_status) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4),
                "::",
                stringify!(si_status)
            )
        );
    }
    test_field_si_status();
    fn test_field_si_utime() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<siginfo_t__bindgen_ty_1__bindgen_ty_4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_utime) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4),
                "::",
                stringify!(si_utime)
            )
        );
    }
    test_field_si_utime();
    fn test_field_si_stime() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<siginfo_t__bindgen_ty_1__bindgen_ty_4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_stime) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4),
                "::",
                stringify!(si_stime)
            )
        );
    }
    test_field_si_stime();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_5 {
    pub si_addr: *mut ::std::os::raw::c_void,
    pub si_addr_lsb: ::std::os::raw::c_short,
    pub _bounds: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
    pub _addr_bnd: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
    pub _pkey: __uint32_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    pub _lower: *mut ::std::os::raw::c_void,
    pub _upper: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1)
        )
    );
    fn test_field__lower() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._lower) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(_lower)
            )
        );
    }
    test_field__lower();
    fn test_field__upper() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._upper) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(_upper)
            )
        );
    }
    test_field__upper();
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1)
        )
    );
    fn test_field__addr_bnd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._addr_bnd) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1),
                "::",
                stringify!(_addr_bnd)
            )
        );
    }
    test_field__addr_bnd();
    fn test_field__pkey() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._pkey) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1),
                "::",
                stringify!(_pkey)
            )
        );
    }
    test_field__pkey();
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_5() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5)
        )
    );
    fn test_field_si_addr() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<siginfo_t__bindgen_ty_1__bindgen_ty_5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_addr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5),
                "::",
                stringify!(si_addr)
            )
        );
    }
    test_field_si_addr();
    fn test_field_si_addr_lsb() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<siginfo_t__bindgen_ty_1__bindgen_ty_5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_addr_lsb) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5),
                "::",
                stringify!(si_addr_lsb)
            )
        );
    }
    test_field_si_addr_lsb();
    fn test_field__bounds() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<siginfo_t__bindgen_ty_1__bindgen_ty_5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._bounds) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5),
                "::",
                stringify!(_bounds)
            )
        );
    }
    test_field__bounds();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_6 {
    pub si_band: ::std::os::raw::c_long,
    pub si_fd: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_6() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_6>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_6)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_6>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_6)
        )
    );
    fn test_field_si_band() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<siginfo_t__bindgen_ty_1__bindgen_ty_6>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_band) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_6),
                "::",
                stringify!(si_band)
            )
        );
    }
    test_field_si_band();
    fn test_field_si_fd() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<siginfo_t__bindgen_ty_1__bindgen_ty_6>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_fd) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_6),
                "::",
                stringify!(si_fd)
            )
        );
    }
    test_field_si_fd();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_7 {
    pub _call_addr: *mut ::std::os::raw::c_void,
    pub _syscall: ::std::os::raw::c_int,
    pub _arch: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_7() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_7>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_7)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_7>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_7)
        )
    );
    fn test_field__call_addr() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<siginfo_t__bindgen_ty_1__bindgen_ty_7>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._call_addr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_7),
                "::",
                stringify!(_call_addr)
            )
        );
    }
    test_field__call_addr();
    fn test_field__syscall() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<siginfo_t__bindgen_ty_1__bindgen_ty_7>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._syscall) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_7),
                "::",
                stringify!(_syscall)
            )
        );
    }
    test_field__syscall();
    fn test_field__arch() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<siginfo_t__bindgen_ty_1__bindgen_ty_7>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._arch) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_7),
                "::",
                stringify!(_arch)
            )
        );
    }
    test_field__arch();
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1>(),
        112usize,
        concat!("Size of: ", stringify!(siginfo_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(siginfo_t__bindgen_ty_1))
    );
    fn test_field__pad() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<siginfo_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._pad) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t__bindgen_ty_1),
                "::",
                stringify!(_pad)
            )
        );
    }
    test_field__pad();
    fn test_field__kill() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<siginfo_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._kill) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t__bindgen_ty_1),
                "::",
                stringify!(_kill)
            )
        );
    }
    test_field__kill();
    fn test_field__timer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<siginfo_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._timer) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t__bindgen_ty_1),
                "::",
                stringify!(_timer)
            )
        );
    }
    test_field__timer();
    fn test_field__rt() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<siginfo_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._rt) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t__bindgen_ty_1),
                "::",
                stringify!(_rt)
            )
        );
    }
    test_field__rt();
    fn test_field__sigchld() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<siginfo_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._sigchld) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t__bindgen_ty_1),
                "::",
                stringify!(_sigchld)
            )
        );
    }
    test_field__sigchld();
    fn test_field__sigfault() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<siginfo_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._sigfault) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t__bindgen_ty_1),
                "::",
                stringify!(_sigfault)
            )
        );
    }
    test_field__sigfault();
    fn test_field__sigpoll() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<siginfo_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._sigpoll) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t__bindgen_ty_1),
                "::",
                stringify!(_sigpoll)
            )
        );
    }
    test_field__sigpoll();
    fn test_field__sigsys() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<siginfo_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._sigsys) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t__bindgen_ty_1),
                "::",
                stringify!(_sigsys)
            )
        );
    }
    test_field__sigsys();
}
#[test]
fn bindgen_test_layout_siginfo_t() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t>(),
        128usize,
        concat!("Size of: ", stringify!(siginfo_t))
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t>(),
        8usize,
        concat!("Alignment of ", stringify!(siginfo_t))
    );
    fn test_field_si_signo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<siginfo_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_signo) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t),
                "::",
                stringify!(si_signo)
            )
        );
    }
    test_field_si_signo();
    fn test_field_si_errno() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<siginfo_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_errno) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t),
                "::",
                stringify!(si_errno)
            )
        );
    }
    test_field_si_errno();
    fn test_field_si_code() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<siginfo_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_code) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t),
                "::",
                stringify!(si_code)
            )
        );
    }
    test_field_si_code();
    fn test_field___pad0() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<siginfo_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pad0) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t),
                "::",
                stringify!(__pad0)
            )
        );
    }
    test_field___pad0();
    fn test_field__sifields() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<siginfo_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._sifields) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t),
                "::",
                stringify!(_sifields)
            )
        );
    }
    test_field__sifields();
}
pub const SI_ASYNCNL: _bindgen_ty_1 = -60;
pub const SI_DETHREAD: _bindgen_ty_1 = -7;
pub const SI_TKILL: _bindgen_ty_1 = -6;
pub const SI_SIGIO: _bindgen_ty_1 = -5;
pub const SI_ASYNCIO: _bindgen_ty_1 = -4;
pub const SI_MESGQ: _bindgen_ty_1 = -3;
pub const SI_TIMER: _bindgen_ty_1 = -2;
pub const SI_QUEUE: _bindgen_ty_1 = -1;
pub const SI_USER: _bindgen_ty_1 = 0;
pub const SI_KERNEL: _bindgen_ty_1 = 128;
pub type _bindgen_ty_1 = ::std::os::raw::c_int;
pub const ILL_ILLOPC: _bindgen_ty_2 = 1;
pub const ILL_ILLOPN: _bindgen_ty_2 = 2;
pub const ILL_ILLADR: _bindgen_ty_2 = 3;
pub const ILL_ILLTRP: _bindgen_ty_2 = 4;
pub const ILL_PRVOPC: _bindgen_ty_2 = 5;
pub const ILL_PRVREG: _bindgen_ty_2 = 6;
pub const ILL_COPROC: _bindgen_ty_2 = 7;
pub const ILL_BADSTK: _bindgen_ty_2 = 8;
pub const ILL_BADIADDR: _bindgen_ty_2 = 9;
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
pub const FPE_INTDIV: _bindgen_ty_3 = 1;
pub const FPE_INTOVF: _bindgen_ty_3 = 2;
pub const FPE_FLTDIV: _bindgen_ty_3 = 3;
pub const FPE_FLTOVF: _bindgen_ty_3 = 4;
pub const FPE_FLTUND: _bindgen_ty_3 = 5;
pub const FPE_FLTRES: _bindgen_ty_3 = 6;
pub const FPE_FLTINV: _bindgen_ty_3 = 7;
pub const FPE_FLTSUB: _bindgen_ty_3 = 8;
pub const FPE_FLTUNK: _bindgen_ty_3 = 14;
pub const FPE_CONDTRAP: _bindgen_ty_3 = 15;
pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
pub const SEGV_MAPERR: _bindgen_ty_4 = 1;
pub const SEGV_ACCERR: _bindgen_ty_4 = 2;
pub const SEGV_BNDERR: _bindgen_ty_4 = 3;
pub const SEGV_PKUERR: _bindgen_ty_4 = 4;
pub const SEGV_ACCADI: _bindgen_ty_4 = 5;
pub const SEGV_ADIDERR: _bindgen_ty_4 = 6;
pub const SEGV_ADIPERR: _bindgen_ty_4 = 7;
pub type _bindgen_ty_4 = ::std::os::raw::c_uint;
pub const BUS_ADRALN: _bindgen_ty_5 = 1;
pub const BUS_ADRERR: _bindgen_ty_5 = 2;
pub const BUS_OBJERR: _bindgen_ty_5 = 3;
pub const BUS_MCEERR_AR: _bindgen_ty_5 = 4;
pub const BUS_MCEERR_AO: _bindgen_ty_5 = 5;
pub type _bindgen_ty_5 = ::std::os::raw::c_uint;
pub const CLD_EXITED: _bindgen_ty_6 = 1;
pub const CLD_KILLED: _bindgen_ty_6 = 2;
pub const CLD_DUMPED: _bindgen_ty_6 = 3;
pub const CLD_TRAPPED: _bindgen_ty_6 = 4;
pub const CLD_STOPPED: _bindgen_ty_6 = 5;
pub const CLD_CONTINUED: _bindgen_ty_6 = 6;
pub type _bindgen_ty_6 = ::std::os::raw::c_uint;
pub const POLL_IN: _bindgen_ty_7 = 1;
pub const POLL_OUT: _bindgen_ty_7 = 2;
pub const POLL_MSG: _bindgen_ty_7 = 3;
pub const POLL_ERR: _bindgen_ty_7 = 4;
pub const POLL_PRI: _bindgen_ty_7 = 5;
pub const POLL_HUP: _bindgen_ty_7 = 6;
pub type _bindgen_ty_7 = ::std::os::raw::c_uint;
pub type sigval_t = __sigval_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_value: __sigval_t,
    pub sigev_signo: ::std::os::raw::c_int,
    pub sigev_notify: ::std::os::raw::c_int,
    pub _sigev_un: sigevent__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigevent__bindgen_ty_1 {
    pub _pad: [::std::os::raw::c_int; 12usize],
    pub _tid: __pid_t,
    pub _sigev_thread: sigevent__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent__bindgen_ty_1__bindgen_ty_1 {
    pub _function: ::std::option::Option<unsafe extern "C" fn(arg1: __sigval_t)>,
    pub _attribute: *mut pthread_attr_t,
}
#[test]
fn bindgen_test_layout_sigevent__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<sigevent__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1)
        )
    );
    fn test_field__function() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<sigevent__bindgen_ty_1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._function) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sigevent__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(_function)
            )
        );
    }
    test_field__function();
    fn test_field__attribute() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<sigevent__bindgen_ty_1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._attribute) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(sigevent__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(_attribute)
            )
        );
    }
    test_field__attribute();
}
#[test]
fn bindgen_test_layout_sigevent__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<sigevent__bindgen_ty_1>(),
        48usize,
        concat!("Size of: ", stringify!(sigevent__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(sigevent__bindgen_ty_1))
    );
    fn test_field__pad() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigevent__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._pad) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sigevent__bindgen_ty_1),
                "::",
                stringify!(_pad)
            )
        );
    }
    test_field__pad();
    fn test_field__tid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigevent__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._tid) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sigevent__bindgen_ty_1),
                "::",
                stringify!(_tid)
            )
        );
    }
    test_field__tid();
    fn test_field__sigev_thread() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigevent__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._sigev_thread) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sigevent__bindgen_ty_1),
                "::",
                stringify!(_sigev_thread)
            )
        );
    }
    test_field__sigev_thread();
}
#[test]
fn bindgen_test_layout_sigevent() {
    assert_eq!(
        ::std::mem::size_of::<sigevent>(),
        64usize,
        concat!("Size of: ", stringify!(sigevent))
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent>(),
        8usize,
        concat!("Alignment of ", stringify!(sigevent))
    );
    fn test_field_sigev_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigevent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sigev_value) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sigevent),
                "::",
                stringify!(sigev_value)
            )
        );
    }
    test_field_sigev_value();
    fn test_field_sigev_signo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigevent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sigev_signo) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(sigevent),
                "::",
                stringify!(sigev_signo)
            )
        );
    }
    test_field_sigev_signo();
    fn test_field_sigev_notify() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigevent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sigev_notify) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(sigevent),
                "::",
                stringify!(sigev_notify)
            )
        );
    }
    test_field_sigev_notify();
    fn test_field__sigev_un() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigevent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._sigev_un) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(sigevent),
                "::",
                stringify!(_sigev_un)
            )
        );
    }
    test_field__sigev_un();
}
pub type sigevent_t = sigevent;
pub const SIGEV_SIGNAL: _bindgen_ty_8 = 0;
pub const SIGEV_NONE: _bindgen_ty_8 = 1;
pub const SIGEV_THREAD: _bindgen_ty_8 = 2;
pub const SIGEV_THREAD_ID: _bindgen_ty_8 = 4;
pub type _bindgen_ty_8 = ::std::os::raw::c_uint;
pub type __sighandler_t = ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
extern "C" {
    pub fn __sysv_signal(__sig: ::std::os::raw::c_int, __handler: __sighandler_t)
        -> __sighandler_t;
}
extern "C" {
    pub fn signal(__sig: ::std::os::raw::c_int, __handler: __sighandler_t) -> __sighandler_t;
}
extern "C" {
    pub fn kill(__pid: __pid_t, __sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn killpg(__pgrp: __pid_t, __sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn raise(__sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ssignal(__sig: ::std::os::raw::c_int, __handler: __sighandler_t) -> __sighandler_t;
}
extern "C" {
    pub fn gsignal(__sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn psignal(__sig: ::std::os::raw::c_int, __s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn psiginfo(__pinfo: *const siginfo_t, __s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn sigblock(__mask: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigsetmask(__mask: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn siggetmask() -> ::std::os::raw::c_int;
}
pub type sig_t = __sighandler_t;
extern "C" {
    pub fn sigemptyset(__set: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigfillset(__set: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigaddset(__set: *mut sigset_t, __signo: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigdelset(__set: *mut sigset_t, __signo: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigismember(
        __set: *const sigset_t,
        __signo: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigaction {
    pub __sigaction_handler: sigaction__bindgen_ty_1,
    pub sa_mask: __sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
    pub sa_restorer: ::std::option::Option<unsafe extern "C" fn()>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigaction__bindgen_ty_1 {
    pub sa_handler: __sighandler_t,
    pub sa_sigaction: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut siginfo_t,
            arg3: *mut ::std::os::raw::c_void,
        ),
    >,
}
#[test]
fn bindgen_test_layout_sigaction__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<sigaction__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(sigaction__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaction__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaction__bindgen_ty_1))
    );
    fn test_field_sa_handler() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigaction__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sa_handler) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sigaction__bindgen_ty_1),
                "::",
                stringify!(sa_handler)
            )
        );
    }
    test_field_sa_handler();
    fn test_field_sa_sigaction() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigaction__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sa_sigaction) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sigaction__bindgen_ty_1),
                "::",
                stringify!(sa_sigaction)
            )
        );
    }
    test_field_sa_sigaction();
}
#[test]
fn bindgen_test_layout_sigaction() {
    assert_eq!(
        ::std::mem::size_of::<sigaction>(),
        152usize,
        concat!("Size of: ", stringify!(sigaction))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaction))
    );
    fn test_field___sigaction_handler() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigaction>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__sigaction_handler) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sigaction),
                "::",
                stringify!(__sigaction_handler)
            )
        );
    }
    test_field___sigaction_handler();
    fn test_field_sa_mask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigaction>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sa_mask) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(sigaction),
                "::",
                stringify!(sa_mask)
            )
        );
    }
    test_field_sa_mask();
    fn test_field_sa_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigaction>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sa_flags) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(sigaction),
                "::",
                stringify!(sa_flags)
            )
        );
    }
    test_field_sa_flags();
    fn test_field_sa_restorer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigaction>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sa_restorer) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(sigaction),
                "::",
                stringify!(sa_restorer)
            )
        );
    }
    test_field_sa_restorer();
}
extern "C" {
    pub fn sigprocmask(
        __how: ::std::os::raw::c_int,
        __set: *const sigset_t,
        __oset: *mut sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigsuspend(__set: *const sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigaction(
        __sig: ::std::os::raw::c_int,
        __act: *const sigaction,
        __oact: *mut sigaction,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigpending(__set: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigwait(
        __set: *const sigset_t,
        __sig: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigwaitinfo(__set: *const sigset_t, __info: *mut siginfo_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigtimedwait(
        __set: *const sigset_t,
        __info: *mut siginfo_t,
        __timeout: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigqueue(
        __pid: __pid_t,
        __sig: ::std::os::raw::c_int,
        __val: sigval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static _sys_siglist: [*const ::std::os::raw::c_char; 65usize];
}
extern "C" {
    pub static sys_siglist: [*const ::std::os::raw::c_char; 65usize];
}
pub type __s8 = ::std::os::raw::c_schar;
pub type __u8 = ::std::os::raw::c_uchar;
pub type __s16 = ::std::os::raw::c_short;
pub type __u16 = ::std::os::raw::c_ushort;
pub type __s32 = ::std::os::raw::c_int;
pub type __u32 = ::std::os::raw::c_uint;
pub type __s64 = ::std::os::raw::c_longlong;
pub type __u64 = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_fd_set {
    pub fds_bits: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___kernel_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(__kernel_fd_set))
    );
    fn test_field_fds_bits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__kernel_fd_set>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fds_bits) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__kernel_fd_set),
                "::",
                stringify!(fds_bits)
            )
        );
    }
    test_field_fds_bits();
}
pub type __kernel_sighandler_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
pub type __kernel_key_t = ::std::os::raw::c_int;
pub type __kernel_mqd_t = ::std::os::raw::c_int;
pub type __kernel_old_uid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_gid_t = ::std::os::raw::c_ushort;
pub type __kernel_long_t = ::std::os::raw::c_long;
pub type __kernel_ulong_t = ::std::os::raw::c_ulong;
pub type __kernel_ino_t = __kernel_ulong_t;
pub type __kernel_mode_t = ::std::os::raw::c_uint;
pub type __kernel_pid_t = ::std::os::raw::c_int;
pub type __kernel_ipc_pid_t = ::std::os::raw::c_int;
pub type __kernel_uid_t = ::std::os::raw::c_uint;
pub type __kernel_gid_t = ::std::os::raw::c_uint;
pub type __kernel_suseconds_t = __kernel_long_t;
pub type __kernel_daddr_t = ::std::os::raw::c_int;
pub type __kernel_uid32_t = ::std::os::raw::c_uint;
pub type __kernel_gid32_t = ::std::os::raw::c_uint;
pub type __kernel_old_dev_t = ::std::os::raw::c_uint;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __kernel_ssize_t = __kernel_long_t;
pub type __kernel_ptrdiff_t = __kernel_long_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_fsid_t {
    pub val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___kernel_fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__kernel_fsid_t))
    );
    fn test_field_val() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__kernel_fsid_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).val) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__kernel_fsid_t),
                "::",
                stringify!(val)
            )
        );
    }
    test_field_val();
}
pub type __kernel_off_t = __kernel_long_t;
pub type __kernel_loff_t = ::std::os::raw::c_longlong;
pub type __kernel_time_t = __kernel_long_t;
pub type __kernel_time64_t = ::std::os::raw::c_longlong;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = ::std::os::raw::c_int;
pub type __kernel_clockid_t = ::std::os::raw::c_int;
pub type __kernel_caddr_t = *mut ::std::os::raw::c_char;
pub type __kernel_uid16_t = ::std::os::raw::c_ushort;
pub type __kernel_gid16_t = ::std::os::raw::c_ushort;
pub type __le16 = __u16;
pub type __be16 = __u16;
pub type __le32 = __u32;
pub type __be32 = __u32;
pub type __le64 = __u64;
pub type __be64 = __u64;
pub type __sum16 = __u16;
pub type __wsum = __u32;
pub type __poll_t = ::std::os::raw::c_uint;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct sigcontext {
    pub fault_address: __u64,
    pub regs: [__u64; 31usize],
    pub sp: __u64,
    pub pc: __u64,
    pub pstate: __u64,
    pub __bindgen_padding_0: [u8; 8usize],
    pub __reserved: [__u8; 4096usize],
}
#[test]
fn bindgen_test_layout_sigcontext() {
    assert_eq!(
        ::std::mem::size_of::<sigcontext>(),
        4384usize,
        concat!("Size of: ", stringify!(sigcontext))
    );
    assert_eq!(
        ::std::mem::align_of::<sigcontext>(),
        16usize,
        concat!("Alignment of ", stringify!(sigcontext))
    );
    fn test_field_fault_address() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigcontext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fault_address) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sigcontext),
                "::",
                stringify!(fault_address)
            )
        );
    }
    test_field_fault_address();
    fn test_field_regs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigcontext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).regs) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(sigcontext),
                "::",
                stringify!(regs)
            )
        );
    }
    test_field_regs();
    fn test_field_sp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigcontext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sp) as usize - ptr as usize
            },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(sigcontext),
                "::",
                stringify!(sp)
            )
        );
    }
    test_field_sp();
    fn test_field_pc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigcontext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pc) as usize - ptr as usize
            },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(sigcontext),
                "::",
                stringify!(pc)
            )
        );
    }
    test_field_pc();
    fn test_field_pstate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigcontext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pstate) as usize - ptr as usize
            },
            272usize,
            concat!(
                "Offset of field: ",
                stringify!(sigcontext),
                "::",
                stringify!(pstate)
            )
        );
    }
    test_field_pstate();
    fn test_field___reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigcontext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__reserved) as usize - ptr as usize
            },
            288usize,
            concat!(
                "Offset of field: ",
                stringify!(sigcontext),
                "::",
                stringify!(__reserved)
            )
        );
    }
    test_field___reserved();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _aarch64_ctx {
    pub magic: __u32,
    pub size: __u32,
}
#[test]
fn bindgen_test_layout__aarch64_ctx() {
    assert_eq!(
        ::std::mem::size_of::<_aarch64_ctx>(),
        8usize,
        concat!("Size of: ", stringify!(_aarch64_ctx))
    );
    assert_eq!(
        ::std::mem::align_of::<_aarch64_ctx>(),
        4usize,
        concat!("Alignment of ", stringify!(_aarch64_ctx))
    );
    fn test_field_magic() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_aarch64_ctx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_aarch64_ctx),
                "::",
                stringify!(magic)
            )
        );
    }
    test_field_magic();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_aarch64_ctx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_aarch64_ctx),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct fpsimd_context {
    pub head: _aarch64_ctx,
    pub fpsr: __u32,
    pub fpcr: __u32,
    pub vregs: [__uint128_t; 32usize],
}
#[test]
fn bindgen_test_layout_fpsimd_context() {
    assert_eq!(
        ::std::mem::size_of::<fpsimd_context>(),
        528usize,
        concat!("Size of: ", stringify!(fpsimd_context))
    );
    assert_eq!(
        ::std::mem::align_of::<fpsimd_context>(),
        16usize,
        concat!("Alignment of ", stringify!(fpsimd_context))
    );
    fn test_field_head() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fpsimd_context>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).head) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fpsimd_context),
                "::",
                stringify!(head)
            )
        );
    }
    test_field_head();
    fn test_field_fpsr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fpsimd_context>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fpsr) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fpsimd_context),
                "::",
                stringify!(fpsr)
            )
        );
    }
    test_field_fpsr();
    fn test_field_fpcr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fpsimd_context>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fpcr) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(fpsimd_context),
                "::",
                stringify!(fpcr)
            )
        );
    }
    test_field_fpcr();
    fn test_field_vregs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fpsimd_context>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vregs) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(fpsimd_context),
                "::",
                stringify!(vregs)
            )
        );
    }
    test_field_vregs();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esr_context {
    pub head: _aarch64_ctx,
    pub esr: __u64,
}
#[test]
fn bindgen_test_layout_esr_context() {
    assert_eq!(
        ::std::mem::size_of::<esr_context>(),
        16usize,
        concat!("Size of: ", stringify!(esr_context))
    );
    assert_eq!(
        ::std::mem::align_of::<esr_context>(),
        8usize,
        concat!("Alignment of ", stringify!(esr_context))
    );
    fn test_field_head() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<esr_context>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).head) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(esr_context),
                "::",
                stringify!(head)
            )
        );
    }
    test_field_head();
    fn test_field_esr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<esr_context>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).esr) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(esr_context),
                "::",
                stringify!(esr)
            )
        );
    }
    test_field_esr();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct extra_context {
    pub head: _aarch64_ctx,
    pub datap: __u64,
    pub size: __u32,
    pub __reserved: [__u32; 3usize],
}
#[test]
fn bindgen_test_layout_extra_context() {
    assert_eq!(
        ::std::mem::size_of::<extra_context>(),
        32usize,
        concat!("Size of: ", stringify!(extra_context))
    );
    assert_eq!(
        ::std::mem::align_of::<extra_context>(),
        8usize,
        concat!("Alignment of ", stringify!(extra_context))
    );
    fn test_field_head() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extra_context>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).head) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(extra_context),
                "::",
                stringify!(head)
            )
        );
    }
    test_field_head();
    fn test_field_datap() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extra_context>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).datap) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(extra_context),
                "::",
                stringify!(datap)
            )
        );
    }
    test_field_datap();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extra_context>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(extra_context),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field___reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extra_context>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__reserved) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(extra_context),
                "::",
                stringify!(__reserved)
            )
        );
    }
    test_field___reserved();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sve_context {
    pub head: _aarch64_ctx,
    pub vl: __u16,
    pub __reserved: [__u16; 3usize],
}
#[test]
fn bindgen_test_layout_sve_context() {
    assert_eq!(
        ::std::mem::size_of::<sve_context>(),
        16usize,
        concat!("Size of: ", stringify!(sve_context))
    );
    assert_eq!(
        ::std::mem::align_of::<sve_context>(),
        4usize,
        concat!("Alignment of ", stringify!(sve_context))
    );
    fn test_field_head() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sve_context>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).head) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sve_context),
                "::",
                stringify!(head)
            )
        );
    }
    test_field_head();
    fn test_field_vl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sve_context>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vl) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(sve_context),
                "::",
                stringify!(vl)
            )
        );
    }
    test_field_vl();
    fn test_field___reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sve_context>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__reserved) as usize - ptr as usize
            },
            10usize,
            concat!(
                "Offset of field: ",
                stringify!(sve_context),
                "::",
                stringify!(__reserved)
            )
        );
    }
    test_field___reserved();
}
extern "C" {
    pub fn sigreturn(__scp: *mut sigcontext) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_t {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_flags: ::std::os::raw::c_int,
    pub ss_size: size_t,
}
#[test]
fn bindgen_test_layout_stack_t() {
    assert_eq!(
        ::std::mem::size_of::<stack_t>(),
        24usize,
        concat!("Size of: ", stringify!(stack_t))
    );
    assert_eq!(
        ::std::mem::align_of::<stack_t>(),
        8usize,
        concat!("Alignment of ", stringify!(stack_t))
    );
    fn test_field_ss_sp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<stack_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ss_sp) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(stack_t),
                "::",
                stringify!(ss_sp)
            )
        );
    }
    test_field_ss_sp();
    fn test_field_ss_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<stack_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ss_flags) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(stack_t),
                "::",
                stringify!(ss_flags)
            )
        );
    }
    test_field_ss_flags();
    fn test_field_ss_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<stack_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ss_size) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(stack_t),
                "::",
                stringify!(ss_size)
            )
        );
    }
    test_field_ss_size();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timezone {
    pub tz_minuteswest: ::std::os::raw::c_int,
    pub tz_dsttime: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_timezone() {
    assert_eq!(
        ::std::mem::size_of::<timezone>(),
        8usize,
        concat!("Size of: ", stringify!(timezone))
    );
    assert_eq!(
        ::std::mem::align_of::<timezone>(),
        4usize,
        concat!("Alignment of ", stringify!(timezone))
    );
    fn test_field_tz_minuteswest() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<timezone>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tz_minuteswest) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(timezone),
                "::",
                stringify!(tz_minuteswest)
            )
        );
    }
    test_field_tz_minuteswest();
    fn test_field_tz_dsttime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<timezone>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tz_dsttime) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(timezone),
                "::",
                stringify!(tz_dsttime)
            )
        );
    }
    test_field_tz_dsttime();
}
extern "C" {
    pub fn gettimeofday(
        __tv: *mut timeval,
        __tz: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn settimeofday(__tv: *const timeval, __tz: *const timezone) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn adjtime(__delta: *const timeval, __olddelta: *mut timeval) -> ::std::os::raw::c_int;
}
pub const __itimer_which_ITIMER_REAL: __itimer_which = 0;
pub const __itimer_which_ITIMER_VIRTUAL: __itimer_which = 1;
pub const __itimer_which_ITIMER_PROF: __itimer_which = 2;
pub type __itimer_which = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
#[test]
fn bindgen_test_layout_itimerval() {
    assert_eq!(
        ::std::mem::size_of::<itimerval>(),
        32usize,
        concat!("Size of: ", stringify!(itimerval))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerval>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerval))
    );
    fn test_field_it_interval() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<itimerval>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).it_interval) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(itimerval),
                "::",
                stringify!(it_interval)
            )
        );
    }
    test_field_it_interval();
    fn test_field_it_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<itimerval>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).it_value) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(itimerval),
                "::",
                stringify!(it_value)
            )
        );
    }
    test_field_it_value();
}
pub type __itimer_which_t = ::std::os::raw::c_int;
extern "C" {
    pub fn getitimer(__which: __itimer_which_t, __value: *mut itimerval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setitimer(
        __which: __itimer_which_t,
        __new: *const itimerval,
        __old: *mut itimerval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn utimes(
        __file: *const ::std::os::raw::c_char,
        __tvp: *const timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lutimes(
        __file: *const ::std::os::raw::c_char,
        __tvp: *const timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn futimes(__fd: ::std::os::raw::c_int, __tvp: *const timeval) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct user_regs_struct {
    pub regs: [::std::os::raw::c_ulonglong; 31usize],
    pub sp: ::std::os::raw::c_ulonglong,
    pub pc: ::std::os::raw::c_ulonglong,
    pub pstate: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_user_regs_struct() {
    assert_eq!(
        ::std::mem::size_of::<user_regs_struct>(),
        272usize,
        concat!("Size of: ", stringify!(user_regs_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<user_regs_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(user_regs_struct))
    );
    fn test_field_regs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<user_regs_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).regs) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(user_regs_struct),
                "::",
                stringify!(regs)
            )
        );
    }
    test_field_regs();
    fn test_field_sp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<user_regs_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sp) as usize - ptr as usize
            },
            248usize,
            concat!(
                "Offset of field: ",
                stringify!(user_regs_struct),
                "::",
                stringify!(sp)
            )
        );
    }
    test_field_sp();
    fn test_field_pc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<user_regs_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pc) as usize - ptr as usize
            },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(user_regs_struct),
                "::",
                stringify!(pc)
            )
        );
    }
    test_field_pc();
    fn test_field_pstate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<user_regs_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pstate) as usize - ptr as usize
            },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(user_regs_struct),
                "::",
                stringify!(pstate)
            )
        );
    }
    test_field_pstate();
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct user_fpsimd_struct {
    pub vregs: [__uint128_t; 32usize],
    pub fpsr: ::std::os::raw::c_uint,
    pub fpcr: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_user_fpsimd_struct() {
    assert_eq!(
        ::std::mem::size_of::<user_fpsimd_struct>(),
        528usize,
        concat!("Size of: ", stringify!(user_fpsimd_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<user_fpsimd_struct>(),
        16usize,
        concat!("Alignment of ", stringify!(user_fpsimd_struct))
    );
    fn test_field_vregs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<user_fpsimd_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vregs) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(user_fpsimd_struct),
                "::",
                stringify!(vregs)
            )
        );
    }
    test_field_vregs();
    fn test_field_fpsr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<user_fpsimd_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fpsr) as usize - ptr as usize
            },
            512usize,
            concat!(
                "Offset of field: ",
                stringify!(user_fpsimd_struct),
                "::",
                stringify!(fpsr)
            )
        );
    }
    test_field_fpsr();
    fn test_field_fpcr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<user_fpsimd_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fpcr) as usize - ptr as usize
            },
            516usize,
            concat!(
                "Offset of field: ",
                stringify!(user_fpsimd_struct),
                "::",
                stringify!(fpcr)
            )
        );
    }
    test_field_fpcr();
}
pub type elf_greg_t = __uint64_t;
pub type elf_gregset_t = [elf_greg_t; 34usize];
pub type elf_fpregset_t = user_fpsimd_struct;
pub type __pr_uid_t = ::std::os::raw::c_uint;
pub type __pr_gid_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct elf_siginfo {
    pub si_signo: ::std::os::raw::c_int,
    pub si_code: ::std::os::raw::c_int,
    pub si_errno: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_elf_siginfo() {
    assert_eq!(
        ::std::mem::size_of::<elf_siginfo>(),
        12usize,
        concat!("Size of: ", stringify!(elf_siginfo))
    );
    assert_eq!(
        ::std::mem::align_of::<elf_siginfo>(),
        4usize,
        concat!("Alignment of ", stringify!(elf_siginfo))
    );
    fn test_field_si_signo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<elf_siginfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_signo) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(elf_siginfo),
                "::",
                stringify!(si_signo)
            )
        );
    }
    test_field_si_signo();
    fn test_field_si_code() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<elf_siginfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_code) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(elf_siginfo),
                "::",
                stringify!(si_code)
            )
        );
    }
    test_field_si_code();
    fn test_field_si_errno() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<elf_siginfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_errno) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(elf_siginfo),
                "::",
                stringify!(si_errno)
            )
        );
    }
    test_field_si_errno();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct elf_prstatus {
    pub pr_info: elf_siginfo,
    pub pr_cursig: ::std::os::raw::c_short,
    pub pr_sigpend: ::std::os::raw::c_ulong,
    pub pr_sighold: ::std::os::raw::c_ulong,
    pub pr_pid: __pid_t,
    pub pr_ppid: __pid_t,
    pub pr_pgrp: __pid_t,
    pub pr_sid: __pid_t,
    pub pr_utime: timeval,
    pub pr_stime: timeval,
    pub pr_cutime: timeval,
    pub pr_cstime: timeval,
    pub pr_reg: elf_gregset_t,
    pub pr_fpvalid: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_elf_prstatus() {
    assert_eq!(
        ::std::mem::size_of::<elf_prstatus>(),
        392usize,
        concat!("Size of: ", stringify!(elf_prstatus))
    );
    assert_eq!(
        ::std::mem::align_of::<elf_prstatus>(),
        8usize,
        concat!("Alignment of ", stringify!(elf_prstatus))
    );
    fn test_field_pr_info() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<elf_prstatus>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pr_info) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(elf_prstatus),
                "::",
                stringify!(pr_info)
            )
        );
    }
    test_field_pr_info();
    fn test_field_pr_cursig() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<elf_prstatus>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pr_cursig) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(elf_prstatus),
                "::",
                stringify!(pr_cursig)
            )
        );
    }
    test_field_pr_cursig();
    fn test_field_pr_sigpend() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<elf_prstatus>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pr_sigpend) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(elf_prstatus),
                "::",
                stringify!(pr_sigpend)
            )
        );
    }
    test_field_pr_sigpend();
    fn test_field_pr_sighold() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<elf_prstatus>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pr_sighold) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(elf_prstatus),
                "::",
                stringify!(pr_sighold)
            )
        );
    }
    test_field_pr_sighold();
    fn test_field_pr_pid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<elf_prstatus>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pr_pid) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(elf_prstatus),
                "::",
                stringify!(pr_pid)
            )
        );
    }
    test_field_pr_pid();
    fn test_field_pr_ppid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<elf_prstatus>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pr_ppid) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(elf_prstatus),
                "::",
                stringify!(pr_ppid)
            )
        );
    }
    test_field_pr_ppid();
    fn test_field_pr_pgrp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<elf_prstatus>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pr_pgrp) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(elf_prstatus),
                "::",
                stringify!(pr_pgrp)
            )
        );
    }
    test_field_pr_pgrp();
    fn test_field_pr_sid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<elf_prstatus>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pr_sid) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(elf_prstatus),
                "::",
                stringify!(pr_sid)
            )
        );
    }
    test_field_pr_sid();
    fn test_field_pr_utime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<elf_prstatus>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pr_utime) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(elf_prstatus),
                "::",
                stringify!(pr_utime)
            )
        );
    }
    test_field_pr_utime();
    fn test_field_pr_stime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<elf_prstatus>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pr_stime) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(elf_prstatus),
                "::",
                stringify!(pr_stime)
            )
        );
    }
    test_field_pr_stime();
    fn test_field_pr_cutime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<elf_prstatus>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pr_cutime) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(elf_prstatus),
                "::",
                stringify!(pr_cutime)
            )
        );
    }
    test_field_pr_cutime();
    fn test_field_pr_cstime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<elf_prstatus>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pr_cstime) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(elf_prstatus),
                "::",
                stringify!(pr_cstime)
            )
        );
    }
    test_field_pr_cstime();
    fn test_field_pr_reg() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<elf_prstatus>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pr_reg) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(elf_prstatus),
                "::",
                stringify!(pr_reg)
            )
        );
    }
    test_field_pr_reg();
    fn test_field_pr_fpvalid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<elf_prstatus>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pr_fpvalid) as usize - ptr as usize
            },
            384usize,
            concat!(
                "Offset of field: ",
                stringify!(elf_prstatus),
                "::",
                stringify!(pr_fpvalid)
            )
        );
    }
    test_field_pr_fpvalid();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct elf_prpsinfo {
    pub pr_state: ::std::os::raw::c_char,
    pub pr_sname: ::std::os::raw::c_char,
    pub pr_zomb: ::std::os::raw::c_char,
    pub pr_nice: ::std::os::raw::c_char,
    pub pr_flag: ::std::os::raw::c_ulong,
    pub pr_uid: __pr_uid_t,
    pub pr_gid: __pr_gid_t,
    pub pr_pid: ::std::os::raw::c_int,
    pub pr_ppid: ::std::os::raw::c_int,
    pub pr_pgrp: ::std::os::raw::c_int,
    pub pr_sid: ::std::os::raw::c_int,
    pub pr_fname: [::std::os::raw::c_char; 16usize],
    pub pr_psargs: [::std::os::raw::c_char; 80usize],
}
#[test]
fn bindgen_test_layout_elf_prpsinfo() {
    assert_eq!(
        ::std::mem::size_of::<elf_prpsinfo>(),
        136usize,
        concat!("Size of: ", stringify!(elf_prpsinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<elf_prpsinfo>(),
        8usize,
        concat!("Alignment of ", stringify!(elf_prpsinfo))
    );
    fn test_field_pr_state() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<elf_prpsinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pr_state) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(elf_prpsinfo),
                "::",
                stringify!(pr_state)
            )
        );
    }
    test_field_pr_state();
    fn test_field_pr_sname() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<elf_prpsinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pr_sname) as usize - ptr as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(elf_prpsinfo),
                "::",
                stringify!(pr_sname)
            )
        );
    }
    test_field_pr_sname();
    fn test_field_pr_zomb() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<elf_prpsinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pr_zomb) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(elf_prpsinfo),
                "::",
                stringify!(pr_zomb)
            )
        );
    }
    test_field_pr_zomb();
    fn test_field_pr_nice() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<elf_prpsinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pr_nice) as usize - ptr as usize
            },
            3usize,
            concat!(
                "Offset of field: ",
                stringify!(elf_prpsinfo),
                "::",
                stringify!(pr_nice)
            )
        );
    }
    test_field_pr_nice();
    fn test_field_pr_flag() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<elf_prpsinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pr_flag) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(elf_prpsinfo),
                "::",
                stringify!(pr_flag)
            )
        );
    }
    test_field_pr_flag();
    fn test_field_pr_uid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<elf_prpsinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pr_uid) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(elf_prpsinfo),
                "::",
                stringify!(pr_uid)
            )
        );
    }
    test_field_pr_uid();
    fn test_field_pr_gid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<elf_prpsinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pr_gid) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(elf_prpsinfo),
                "::",
                stringify!(pr_gid)
            )
        );
    }
    test_field_pr_gid();
    fn test_field_pr_pid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<elf_prpsinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pr_pid) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(elf_prpsinfo),
                "::",
                stringify!(pr_pid)
            )
        );
    }
    test_field_pr_pid();
    fn test_field_pr_ppid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<elf_prpsinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pr_ppid) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(elf_prpsinfo),
                "::",
                stringify!(pr_ppid)
            )
        );
    }
    test_field_pr_ppid();
    fn test_field_pr_pgrp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<elf_prpsinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pr_pgrp) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(elf_prpsinfo),
                "::",
                stringify!(pr_pgrp)
            )
        );
    }
    test_field_pr_pgrp();
    fn test_field_pr_sid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<elf_prpsinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pr_sid) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(elf_prpsinfo),
                "::",
                stringify!(pr_sid)
            )
        );
    }
    test_field_pr_sid();
    fn test_field_pr_fname() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<elf_prpsinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pr_fname) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(elf_prpsinfo),
                "::",
                stringify!(pr_fname)
            )
        );
    }
    test_field_pr_fname();
    fn test_field_pr_psargs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<elf_prpsinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pr_psargs) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(elf_prpsinfo),
                "::",
                stringify!(pr_psargs)
            )
        );
    }
    test_field_pr_psargs();
}
pub type psaddr_t = *mut ::std::os::raw::c_void;
pub type __prgregset_t = elf_gregset_t;
pub type __prfpregset_t = elf_fpregset_t;
pub type prgregset_t = __prgregset_t;
pub type prfpregset_t = __prfpregset_t;
pub type lwpid_t = __pid_t;
pub type prstatus_t = elf_prstatus;
pub type prpsinfo_t = elf_prpsinfo;
pub type greg_t = elf_greg_t;
pub type gregset_t = elf_gregset_t;
pub type fpregset_t = elf_fpregset_t;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct mcontext_t {
    pub fault_address: ::std::os::raw::c_ulonglong,
    pub regs: [::std::os::raw::c_ulonglong; 31usize],
    pub sp: ::std::os::raw::c_ulonglong,
    pub pc: ::std::os::raw::c_ulonglong,
    pub pstate: ::std::os::raw::c_ulonglong,
    pub __bindgen_padding_0: [u8; 8usize],
    pub __reserved: [::std::os::raw::c_uchar; 4096usize],
}
#[test]
fn bindgen_test_layout_mcontext_t() {
    assert_eq!(
        ::std::mem::size_of::<mcontext_t>(),
        4384usize,
        concat!("Size of: ", stringify!(mcontext_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mcontext_t>(),
        16usize,
        concat!("Alignment of ", stringify!(mcontext_t))
    );
    fn test_field_fault_address() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mcontext_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fault_address) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mcontext_t),
                "::",
                stringify!(fault_address)
            )
        );
    }
    test_field_fault_address();
    fn test_field_regs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mcontext_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).regs) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(mcontext_t),
                "::",
                stringify!(regs)
            )
        );
    }
    test_field_regs();
    fn test_field_sp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mcontext_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sp) as usize - ptr as usize
            },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(mcontext_t),
                "::",
                stringify!(sp)
            )
        );
    }
    test_field_sp();
    fn test_field_pc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mcontext_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pc) as usize - ptr as usize
            },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(mcontext_t),
                "::",
                stringify!(pc)
            )
        );
    }
    test_field_pc();
    fn test_field_pstate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mcontext_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pstate) as usize - ptr as usize
            },
            272usize,
            concat!(
                "Offset of field: ",
                stringify!(mcontext_t),
                "::",
                stringify!(pstate)
            )
        );
    }
    test_field_pstate();
    fn test_field___reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mcontext_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__reserved) as usize - ptr as usize
            },
            288usize,
            concat!(
                "Offset of field: ",
                stringify!(mcontext_t),
                "::",
                stringify!(__reserved)
            )
        );
    }
    test_field___reserved();
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct ucontext_t {
    pub uc_flags: ::std::os::raw::c_ulong,
    pub uc_link: *mut ucontext_t,
    pub uc_stack: stack_t,
    pub uc_sigmask: sigset_t,
    pub __bindgen_padding_0: u64,
    pub uc_mcontext: mcontext_t,
}
#[test]
fn bindgen_test_layout_ucontext_t() {
    assert_eq!(
        ::std::mem::size_of::<ucontext_t>(),
        4560usize,
        concat!("Size of: ", stringify!(ucontext_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ucontext_t>(),
        16usize,
        concat!("Alignment of ", stringify!(ucontext_t))
    );
    fn test_field_uc_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ucontext_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uc_flags) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ucontext_t),
                "::",
                stringify!(uc_flags)
            )
        );
    }
    test_field_uc_flags();
    fn test_field_uc_link() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ucontext_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uc_link) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ucontext_t),
                "::",
                stringify!(uc_link)
            )
        );
    }
    test_field_uc_link();
    fn test_field_uc_stack() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ucontext_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uc_stack) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(ucontext_t),
                "::",
                stringify!(uc_stack)
            )
        );
    }
    test_field_uc_stack();
    fn test_field_uc_sigmask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ucontext_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uc_sigmask) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(ucontext_t),
                "::",
                stringify!(uc_sigmask)
            )
        );
    }
    test_field_uc_sigmask();
    fn test_field_uc_mcontext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ucontext_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uc_mcontext) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(ucontext_t),
                "::",
                stringify!(uc_mcontext)
            )
        );
    }
    test_field_uc_mcontext();
}
extern "C" {
    pub fn siginterrupt(
        __sig: ::std::os::raw::c_int,
        __interrupt: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub const SS_ONSTACK: _bindgen_ty_9 = 1;
pub const SS_DISABLE: _bindgen_ty_9 = 2;
pub type _bindgen_ty_9 = ::std::os::raw::c_uint;
extern "C" {
    pub fn sigaltstack(__ss: *const stack_t, __oss: *mut stack_t) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_onstack: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigstack() {
    assert_eq!(
        ::std::mem::size_of::<sigstack>(),
        16usize,
        concat!("Size of: ", stringify!(sigstack))
    );
    assert_eq!(
        ::std::mem::align_of::<sigstack>(),
        8usize,
        concat!("Alignment of ", stringify!(sigstack))
    );
    fn test_field_ss_sp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigstack>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ss_sp) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sigstack),
                "::",
                stringify!(ss_sp)
            )
        );
    }
    test_field_ss_sp();
    fn test_field_ss_onstack() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigstack>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ss_onstack) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(sigstack),
                "::",
                stringify!(ss_onstack)
            )
        );
    }
    test_field_ss_onstack();
}
extern "C" {
    pub fn sigstack(__ss: *mut sigstack, __oss: *mut sigstack) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_sigmask(
        __how: ::std::os::raw::c_int,
        __newmask: *const __sigset_t,
        __oldmask: *mut __sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_kill(
        __threadid: pthread_t,
        __signo: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __libc_current_sigrtmin() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __libc_current_sigrtmax() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn g_on_error_query(prg_name: *const gchar);
}
extern "C" {
    pub fn g_on_error_stack_trace(prg_name: *const gchar);
}
extern "C" {
    pub fn g_base64_encode_step(
        in_: *const guchar,
        len: gsize,
        break_lines: gboolean,
        out: *mut gchar,
        state: *mut gint,
        save: *mut gint,
    ) -> gsize;
}
extern "C" {
    pub fn g_base64_encode_close(
        break_lines: gboolean,
        out: *mut gchar,
        state: *mut gint,
        save: *mut gint,
    ) -> gsize;
}
extern "C" {
    pub fn g_base64_encode(data: *const guchar, len: gsize) -> *mut gchar;
}
extern "C" {
    pub fn g_base64_decode_step(
        in_: *const gchar,
        len: gsize,
        out: *mut guchar,
        state: *mut gint,
        save: *mut guint,
    ) -> gsize;
}
extern "C" {
    pub fn g_base64_decode(text: *const gchar, out_len: *mut gsize) -> *mut guchar;
}
extern "C" {
    pub fn g_base64_decode_inplace(text: *mut gchar, out_len: *mut gsize) -> *mut guchar;
}
extern "C" {
    pub fn g_bit_lock(address: *mut gint, lock_bit: gint);
}
extern "C" {
    pub fn g_bit_trylock(address: *mut gint, lock_bit: gint) -> gboolean;
}
extern "C" {
    pub fn g_bit_unlock(address: *mut gint, lock_bit: gint);
}
extern "C" {
    pub fn g_pointer_bit_lock(address: *mut ::std::os::raw::c_void, lock_bit: gint);
}
extern "C" {
    pub fn g_pointer_bit_trylock(address: *mut ::std::os::raw::c_void, lock_bit: gint) -> gboolean;
}
extern "C" {
    pub fn g_pointer_bit_unlock(address: *mut ::std::os::raw::c_void, lock_bit: gint);
}
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_INVALID_URI: GBookmarkFileError = 0;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_INVALID_VALUE: GBookmarkFileError = 1;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED: GBookmarkFileError = 2;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND: GBookmarkFileError = 3;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_READ: GBookmarkFileError = 4;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_UNKNOWN_ENCODING: GBookmarkFileError = 5;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_WRITE: GBookmarkFileError = 6;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_FILE_NOT_FOUND: GBookmarkFileError = 7;
#[doc = " GBookmarkFileError:"]
#[doc = " @G_BOOKMARK_FILE_ERROR_INVALID_URI: URI was ill-formed"]
#[doc = " @G_BOOKMARK_FILE_ERROR_INVALID_VALUE: a requested field was not found"]
#[doc = " @G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED: a requested application did"]
#[doc = "     not register a bookmark"]
#[doc = " @G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND: a requested URI was not found"]
#[doc = " @G_BOOKMARK_FILE_ERROR_READ: document was ill formed"]
#[doc = " @G_BOOKMARK_FILE_ERROR_UNKNOWN_ENCODING: the text being parsed was"]
#[doc = "     in an unknown encoding"]
#[doc = " @G_BOOKMARK_FILE_ERROR_WRITE: an error occurred while writing"]
#[doc = " @G_BOOKMARK_FILE_ERROR_FILE_NOT_FOUND: requested file was not found"]
#[doc = ""]
#[doc = " Error codes returned by bookmark file parsing."]
pub type GBookmarkFileError = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_bookmark_file_error_quark() -> GQuark;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GBookmarkFile {
    _unused: [u8; 0],
}
#[doc = " GBookmarkFile:"]
#[doc = ""]
#[doc = " The `GBookmarkFile` structure contains only"]
#[doc = " private data and should not be directly accessed."]
pub type GBookmarkFile = _GBookmarkFile;
extern "C" {
    pub fn g_bookmark_file_new() -> *mut GBookmarkFile;
}
extern "C" {
    pub fn g_bookmark_file_free(bookmark: *mut GBookmarkFile);
}
extern "C" {
    pub fn g_bookmark_file_load_from_file(
        bookmark: *mut GBookmarkFile,
        filename: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_load_from_data(
        bookmark: *mut GBookmarkFile,
        data: *const gchar,
        length: gsize,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_load_from_data_dirs(
        bookmark: *mut GBookmarkFile,
        file: *const gchar,
        full_path: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_to_data(
        bookmark: *mut GBookmarkFile,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_bookmark_file_to_file(
        bookmark: *mut GBookmarkFile,
        filename: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_set_title(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        title: *const gchar,
    );
}
extern "C" {
    pub fn g_bookmark_file_get_title(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_bookmark_file_set_description(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        description: *const gchar,
    );
}
extern "C" {
    pub fn g_bookmark_file_get_description(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_bookmark_file_set_mime_type(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        mime_type: *const gchar,
    );
}
extern "C" {
    pub fn g_bookmark_file_get_mime_type(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_bookmark_file_set_groups(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        groups: *mut *const gchar,
        length: gsize,
    );
}
extern "C" {
    pub fn g_bookmark_file_add_group(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        group: *const gchar,
    );
}
extern "C" {
    pub fn g_bookmark_file_has_group(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        group: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_get_groups(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_bookmark_file_add_application(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        name: *const gchar,
        exec: *const gchar,
    );
}
extern "C" {
    pub fn g_bookmark_file_has_application(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        name: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_get_applications(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_bookmark_file_set_app_info(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        name: *const gchar,
        exec: *const gchar,
        count: gint,
        stamp: time_t,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_get_app_info(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        name: *const gchar,
        exec: *mut *mut gchar,
        count: *mut guint,
        stamp: *mut time_t,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_set_is_private(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        is_private: gboolean,
    );
}
extern "C" {
    pub fn g_bookmark_file_get_is_private(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_set_icon(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        href: *const gchar,
        mime_type: *const gchar,
    );
}
extern "C" {
    pub fn g_bookmark_file_get_icon(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        href: *mut *mut gchar,
        mime_type: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_set_added(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        added: time_t,
    );
}
extern "C" {
    pub fn g_bookmark_file_get_added(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> time_t;
}
extern "C" {
    pub fn g_bookmark_file_set_modified(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        modified: time_t,
    );
}
extern "C" {
    pub fn g_bookmark_file_get_modified(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> time_t;
}
extern "C" {
    pub fn g_bookmark_file_set_visited(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        visited: time_t,
    );
}
extern "C" {
    pub fn g_bookmark_file_get_visited(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> time_t;
}
extern "C" {
    pub fn g_bookmark_file_has_item(bookmark: *mut GBookmarkFile, uri: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_get_size(bookmark: *mut GBookmarkFile) -> gint;
}
extern "C" {
    pub fn g_bookmark_file_get_uris(
        bookmark: *mut GBookmarkFile,
        length: *mut gsize,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_bookmark_file_remove_group(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        group: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_remove_application(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        name: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_remove_item(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_move_item(
        bookmark: *mut GBookmarkFile,
        old_uri: *const gchar,
        new_uri: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bytes_new(data: gconstpointer, size: gsize) -> *mut GBytes;
}
extern "C" {
    pub fn g_bytes_new_take(data: gpointer, size: gsize) -> *mut GBytes;
}
extern "C" {
    pub fn g_bytes_new_static(data: gconstpointer, size: gsize) -> *mut GBytes;
}
extern "C" {
    pub fn g_bytes_new_with_free_func(
        data: gconstpointer,
        size: gsize,
        free_func: GDestroyNotify,
        user_data: gpointer,
    ) -> *mut GBytes;
}
extern "C" {
    pub fn g_bytes_new_from_bytes(bytes: *mut GBytes, offset: gsize, length: gsize) -> *mut GBytes;
}
extern "C" {
    pub fn g_bytes_get_data(bytes: *mut GBytes, size: *mut gsize) -> gconstpointer;
}
extern "C" {
    pub fn g_bytes_get_size(bytes: *mut GBytes) -> gsize;
}
extern "C" {
    pub fn g_bytes_ref(bytes: *mut GBytes) -> *mut GBytes;
}
extern "C" {
    pub fn g_bytes_unref(bytes: *mut GBytes);
}
extern "C" {
    pub fn g_bytes_unref_to_data(bytes: *mut GBytes, size: *mut gsize) -> gpointer;
}
extern "C" {
    pub fn g_bytes_unref_to_array(bytes: *mut GBytes) -> *mut GByteArray;
}
extern "C" {
    pub fn g_bytes_hash(bytes: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_bytes_equal(bytes1: gconstpointer, bytes2: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_bytes_compare(bytes1: gconstpointer, bytes2: gconstpointer) -> gint;
}
extern "C" {
    pub fn g_get_charset(charset: *mut *const ::std::os::raw::c_char) -> gboolean;
}
extern "C" {
    pub fn g_get_codeset() -> *mut gchar;
}
extern "C" {
    pub fn g_get_console_charset(charset: *mut *const ::std::os::raw::c_char) -> gboolean;
}
extern "C" {
    pub fn g_get_language_names() -> *const *const gchar;
}
extern "C" {
    pub fn g_get_language_names_with_category(category_name: *const gchar) -> *const *const gchar;
}
extern "C" {
    pub fn g_get_locale_variants(locale: *const gchar) -> *mut *mut gchar;
}
pub const GChecksumType_G_CHECKSUM_MD5: GChecksumType = 0;
pub const GChecksumType_G_CHECKSUM_SHA1: GChecksumType = 1;
pub const GChecksumType_G_CHECKSUM_SHA256: GChecksumType = 2;
pub const GChecksumType_G_CHECKSUM_SHA512: GChecksumType = 3;
pub const GChecksumType_G_CHECKSUM_SHA384: GChecksumType = 4;
#[doc = " GChecksumType:"]
#[doc = " @G_CHECKSUM_MD5: Use the MD5 hashing algorithm"]
#[doc = " @G_CHECKSUM_SHA1: Use the SHA-1 hashing algorithm"]
#[doc = " @G_CHECKSUM_SHA256: Use the SHA-256 hashing algorithm"]
#[doc = " @G_CHECKSUM_SHA384: Use the SHA-384 hashing algorithm (Since: 2.51)"]
#[doc = " @G_CHECKSUM_SHA512: Use the SHA-512 hashing algorithm (Since: 2.36)"]
#[doc = ""]
#[doc = " The hashing algorithm to be used by #GChecksum when performing the"]
#[doc = " digest of some data."]
#[doc = ""]
#[doc = " Note that the #GChecksumType enumeration may be extended at a later"]
#[doc = " date to include new hashing algorithm types."]
#[doc = ""]
#[doc = " Since: 2.16"]
pub type GChecksumType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GChecksum {
    _unused: [u8; 0],
}
#[doc = " GChecksum:"]
#[doc = ""]
#[doc = " An opaque structure representing a checksumming operation."]
#[doc = " To create a new GChecksum, use g_checksum_new(). To free"]
#[doc = " a GChecksum, use g_checksum_free()."]
#[doc = ""]
#[doc = " Since: 2.16"]
pub type GChecksum = _GChecksum;
extern "C" {
    pub fn g_checksum_type_get_length(checksum_type: GChecksumType) -> gssize;
}
extern "C" {
    pub fn g_checksum_new(checksum_type: GChecksumType) -> *mut GChecksum;
}
extern "C" {
    pub fn g_checksum_reset(checksum: *mut GChecksum);
}
extern "C" {
    pub fn g_checksum_copy(checksum: *const GChecksum) -> *mut GChecksum;
}
extern "C" {
    pub fn g_checksum_free(checksum: *mut GChecksum);
}
extern "C" {
    pub fn g_checksum_update(checksum: *mut GChecksum, data: *const guchar, length: gssize);
}
extern "C" {
    pub fn g_checksum_get_string(checksum: *mut GChecksum) -> *const gchar;
}
extern "C" {
    pub fn g_checksum_get_digest(
        checksum: *mut GChecksum,
        buffer: *mut guint8,
        digest_len: *mut gsize,
    );
}
extern "C" {
    pub fn g_compute_checksum_for_data(
        checksum_type: GChecksumType,
        data: *const guchar,
        length: gsize,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_compute_checksum_for_string(
        checksum_type: GChecksumType,
        str_: *const gchar,
        length: gssize,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_compute_checksum_for_bytes(
        checksum_type: GChecksumType,
        data: *mut GBytes,
    ) -> *mut gchar;
}
pub const GConvertError_G_CONVERT_ERROR_NO_CONVERSION: GConvertError = 0;
pub const GConvertError_G_CONVERT_ERROR_ILLEGAL_SEQUENCE: GConvertError = 1;
pub const GConvertError_G_CONVERT_ERROR_FAILED: GConvertError = 2;
pub const GConvertError_G_CONVERT_ERROR_PARTIAL_INPUT: GConvertError = 3;
pub const GConvertError_G_CONVERT_ERROR_BAD_URI: GConvertError = 4;
pub const GConvertError_G_CONVERT_ERROR_NOT_ABSOLUTE_PATH: GConvertError = 5;
pub const GConvertError_G_CONVERT_ERROR_NO_MEMORY: GConvertError = 6;
pub const GConvertError_G_CONVERT_ERROR_EMBEDDED_NUL: GConvertError = 7;
#[doc = " GConvertError:"]
#[doc = " @G_CONVERT_ERROR_NO_CONVERSION: Conversion between the requested character"]
#[doc = "     sets is not supported."]
#[doc = " @G_CONVERT_ERROR_ILLEGAL_SEQUENCE: Invalid byte sequence in conversion input;"]
#[doc = "    or the character sequence could not be represented in the target"]
#[doc = "    character set."]
#[doc = " @G_CONVERT_ERROR_FAILED: Conversion failed for some reason."]
#[doc = " @G_CONVERT_ERROR_PARTIAL_INPUT: Partial character sequence at end of input."]
#[doc = " @G_CONVERT_ERROR_BAD_URI: URI is invalid."]
#[doc = " @G_CONVERT_ERROR_NOT_ABSOLUTE_PATH: Pathname is not an absolute path."]
#[doc = " @G_CONVERT_ERROR_NO_MEMORY: No memory available. Since: 2.40"]
#[doc = " @G_CONVERT_ERROR_EMBEDDED_NUL: An embedded NUL character is present in"]
#[doc = "     conversion output where a NUL-terminated string is expected."]
#[doc = "     Since: 2.56"]
#[doc = ""]
#[doc = " Error codes returned by character set conversion routines."]
pub type GConvertError = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_convert_error_quark() -> GQuark;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIConv {
    _unused: [u8; 0],
}
#[doc = " GIConv: (skip)"]
#[doc = ""]
#[doc = " The GIConv struct wraps an iconv() conversion descriptor. It contains"]
#[doc = " private data and should only be accessed using the following functions."]
pub type GIConv = *mut _GIConv;
extern "C" {
    pub fn g_iconv_open(to_codeset: *const gchar, from_codeset: *const gchar) -> GIConv;
}
extern "C" {
    pub fn g_iconv(
        converter: GIConv,
        inbuf: *mut *mut gchar,
        inbytes_left: *mut gsize,
        outbuf: *mut *mut gchar,
        outbytes_left: *mut gsize,
    ) -> gsize;
}
extern "C" {
    pub fn g_iconv_close(converter: GIConv) -> gint;
}
extern "C" {
    pub fn g_convert(
        str_: *const gchar,
        len: gssize,
        to_codeset: *const gchar,
        from_codeset: *const gchar,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_convert_with_iconv(
        str_: *const gchar,
        len: gssize,
        converter: GIConv,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_convert_with_fallback(
        str_: *const gchar,
        len: gssize,
        to_codeset: *const gchar,
        from_codeset: *const gchar,
        fallback: *const gchar,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_locale_to_utf8(
        opsysstring: *const gchar,
        len: gssize,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_locale_from_utf8(
        utf8string: *const gchar,
        len: gssize,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_filename_to_utf8(
        opsysstring: *const gchar,
        len: gssize,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_filename_from_utf8(
        utf8string: *const gchar,
        len: gssize,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_filename_from_uri(
        uri: *const gchar,
        hostname: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_filename_to_uri(
        filename: *const gchar,
        hostname: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_filename_display_name(filename: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_get_filename_charsets(filename_charsets: *mut *mut *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_filename_display_basename(filename: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_uri_list_extract_uris(uri_list: *const gchar) -> *mut *mut gchar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GData {
    _unused: [u8; 0],
}
pub type GData = _GData;
pub type GDataForeachFunc = ::std::option::Option<
    unsafe extern "C" fn(key_id: GQuark, data: gpointer, user_data: gpointer),
>;
extern "C" {
    pub fn g_datalist_init(datalist: *mut *mut GData);
}
extern "C" {
    pub fn g_datalist_clear(datalist: *mut *mut GData);
}
extern "C" {
    pub fn g_datalist_id_get_data(datalist: *mut *mut GData, key_id: GQuark) -> gpointer;
}
extern "C" {
    pub fn g_datalist_id_set_data_full(
        datalist: *mut *mut GData,
        key_id: GQuark,
        data: gpointer,
        destroy_func: GDestroyNotify,
    );
}
pub type GDuplicateFunc =
    ::std::option::Option<unsafe extern "C" fn(data: gpointer, user_data: gpointer) -> gpointer>;
extern "C" {
    pub fn g_datalist_id_dup_data(
        datalist: *mut *mut GData,
        key_id: GQuark,
        dup_func: GDuplicateFunc,
        user_data: gpointer,
    ) -> gpointer;
}
extern "C" {
    pub fn g_datalist_id_replace_data(
        datalist: *mut *mut GData,
        key_id: GQuark,
        oldval: gpointer,
        newval: gpointer,
        destroy: GDestroyNotify,
        old_destroy: *mut GDestroyNotify,
    ) -> gboolean;
}
extern "C" {
    pub fn g_datalist_id_remove_no_notify(datalist: *mut *mut GData, key_id: GQuark) -> gpointer;
}
extern "C" {
    pub fn g_datalist_foreach(
        datalist: *mut *mut GData,
        func: GDataForeachFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_datalist_set_flags(datalist: *mut *mut GData, flags: guint);
}
extern "C" {
    pub fn g_datalist_unset_flags(datalist: *mut *mut GData, flags: guint);
}
extern "C" {
    pub fn g_datalist_get_flags(datalist: *mut *mut GData) -> guint;
}
extern "C" {
    pub fn g_dataset_destroy(dataset_location: gconstpointer);
}
extern "C" {
    pub fn g_dataset_id_get_data(dataset_location: gconstpointer, key_id: GQuark) -> gpointer;
}
extern "C" {
    pub fn g_datalist_get_data(datalist: *mut *mut GData, key: *const gchar) -> gpointer;
}
extern "C" {
    pub fn g_dataset_id_set_data_full(
        dataset_location: gconstpointer,
        key_id: GQuark,
        data: gpointer,
        destroy_func: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_dataset_id_remove_no_notify(
        dataset_location: gconstpointer,
        key_id: GQuark,
    ) -> gpointer;
}
extern "C" {
    pub fn g_dataset_foreach(
        dataset_location: gconstpointer,
        func: GDataForeachFunc,
        user_data: gpointer,
    );
}
pub type GTime = gint32;
pub type GDateYear = guint16;
pub type GDateDay = guint8;
pub type GDate = _GDate;
pub const GDateDMY_G_DATE_DAY: GDateDMY = 0;
pub const GDateDMY_G_DATE_MONTH: GDateDMY = 1;
pub const GDateDMY_G_DATE_YEAR: GDateDMY = 2;
pub type GDateDMY = ::std::os::raw::c_uint;
pub const GDateWeekday_G_DATE_BAD_WEEKDAY: GDateWeekday = 0;
pub const GDateWeekday_G_DATE_MONDAY: GDateWeekday = 1;
pub const GDateWeekday_G_DATE_TUESDAY: GDateWeekday = 2;
pub const GDateWeekday_G_DATE_WEDNESDAY: GDateWeekday = 3;
pub const GDateWeekday_G_DATE_THURSDAY: GDateWeekday = 4;
pub const GDateWeekday_G_DATE_FRIDAY: GDateWeekday = 5;
pub const GDateWeekday_G_DATE_SATURDAY: GDateWeekday = 6;
pub const GDateWeekday_G_DATE_SUNDAY: GDateWeekday = 7;
pub type GDateWeekday = ::std::os::raw::c_uint;
pub const GDateMonth_G_DATE_BAD_MONTH: GDateMonth = 0;
pub const GDateMonth_G_DATE_JANUARY: GDateMonth = 1;
pub const GDateMonth_G_DATE_FEBRUARY: GDateMonth = 2;
pub const GDateMonth_G_DATE_MARCH: GDateMonth = 3;
pub const GDateMonth_G_DATE_APRIL: GDateMonth = 4;
pub const GDateMonth_G_DATE_MAY: GDateMonth = 5;
pub const GDateMonth_G_DATE_JUNE: GDateMonth = 6;
pub const GDateMonth_G_DATE_JULY: GDateMonth = 7;
pub const GDateMonth_G_DATE_AUGUST: GDateMonth = 8;
pub const GDateMonth_G_DATE_SEPTEMBER: GDateMonth = 9;
pub const GDateMonth_G_DATE_OCTOBER: GDateMonth = 10;
pub const GDateMonth_G_DATE_NOVEMBER: GDateMonth = 11;
pub const GDateMonth_G_DATE_DECEMBER: GDateMonth = 12;
pub type GDateMonth = ::std::os::raw::c_uint;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _GDate {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout__GDate() {
    assert_eq!(
        ::std::mem::size_of::<_GDate>(),
        8usize,
        concat!("Size of: ", stringify!(_GDate))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDate>(),
        4usize,
        concat!("Alignment of ", stringify!(_GDate))
    );
}
impl _GDate {
    #[inline]
    pub fn julian_days(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_julian_days(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn julian(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_julian(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dmy(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(33usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dmy(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(33usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn day(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(34usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_day(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(34usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn month(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_month(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn year(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(44usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_year(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(44usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        julian_days: guint,
        julian: guint,
        dmy: guint,
        day: guint,
        month: guint,
        year: guint,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let julian_days: u32 = unsafe { ::std::mem::transmute(julian_days) };
            julian_days as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let julian: u32 = unsafe { ::std::mem::transmute(julian) };
            julian as u64
        });
        __bindgen_bitfield_unit.set(33usize, 1u8, {
            let dmy: u32 = unsafe { ::std::mem::transmute(dmy) };
            dmy as u64
        });
        __bindgen_bitfield_unit.set(34usize, 6u8, {
            let day: u32 = unsafe { ::std::mem::transmute(day) };
            day as u64
        });
        __bindgen_bitfield_unit.set(40usize, 4u8, {
            let month: u32 = unsafe { ::std::mem::transmute(month) };
            month as u64
        });
        __bindgen_bitfield_unit.set(44usize, 16u8, {
            let year: u32 = unsafe { ::std::mem::transmute(year) };
            year as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn g_date_new() -> *mut GDate;
}
extern "C" {
    pub fn g_date_new_dmy(day: GDateDay, month: GDateMonth, year: GDateYear) -> *mut GDate;
}
extern "C" {
    pub fn g_date_new_julian(julian_day: guint32) -> *mut GDate;
}
extern "C" {
    pub fn g_date_free(date: *mut GDate);
}
extern "C" {
    pub fn g_date_copy(date: *const GDate) -> *mut GDate;
}
extern "C" {
    pub fn g_date_valid(date: *const GDate) -> gboolean;
}
extern "C" {
    pub fn g_date_valid_day(day: GDateDay) -> gboolean;
}
extern "C" {
    pub fn g_date_valid_month(month: GDateMonth) -> gboolean;
}
extern "C" {
    pub fn g_date_valid_year(year: GDateYear) -> gboolean;
}
extern "C" {
    pub fn g_date_valid_weekday(weekday: GDateWeekday) -> gboolean;
}
extern "C" {
    pub fn g_date_valid_julian(julian_date: guint32) -> gboolean;
}
extern "C" {
    pub fn g_date_valid_dmy(day: GDateDay, month: GDateMonth, year: GDateYear) -> gboolean;
}
extern "C" {
    pub fn g_date_get_weekday(date: *const GDate) -> GDateWeekday;
}
extern "C" {
    pub fn g_date_get_month(date: *const GDate) -> GDateMonth;
}
extern "C" {
    pub fn g_date_get_year(date: *const GDate) -> GDateYear;
}
extern "C" {
    pub fn g_date_get_day(date: *const GDate) -> GDateDay;
}
extern "C" {
    pub fn g_date_get_julian(date: *const GDate) -> guint32;
}
extern "C" {
    pub fn g_date_get_day_of_year(date: *const GDate) -> guint;
}
extern "C" {
    pub fn g_date_get_monday_week_of_year(date: *const GDate) -> guint;
}
extern "C" {
    pub fn g_date_get_sunday_week_of_year(date: *const GDate) -> guint;
}
extern "C" {
    pub fn g_date_get_iso8601_week_of_year(date: *const GDate) -> guint;
}
extern "C" {
    pub fn g_date_clear(date: *mut GDate, n_dates: guint);
}
extern "C" {
    pub fn g_date_set_parse(date: *mut GDate, str_: *const gchar);
}
extern "C" {
    pub fn g_date_set_time_t(date: *mut GDate, timet: time_t);
}
extern "C" {
    pub fn g_date_set_time_val(date: *mut GDate, timeval: *mut GTimeVal);
}
extern "C" {
    pub fn g_date_set_time(date: *mut GDate, time_: GTime);
}
extern "C" {
    pub fn g_date_set_month(date: *mut GDate, month: GDateMonth);
}
extern "C" {
    pub fn g_date_set_day(date: *mut GDate, day: GDateDay);
}
extern "C" {
    pub fn g_date_set_year(date: *mut GDate, year: GDateYear);
}
extern "C" {
    pub fn g_date_set_dmy(date: *mut GDate, day: GDateDay, month: GDateMonth, y: GDateYear);
}
extern "C" {
    pub fn g_date_set_julian(date: *mut GDate, julian_date: guint32);
}
extern "C" {
    pub fn g_date_is_first_of_month(date: *const GDate) -> gboolean;
}
extern "C" {
    pub fn g_date_is_last_of_month(date: *const GDate) -> gboolean;
}
extern "C" {
    pub fn g_date_add_days(date: *mut GDate, n_days: guint);
}
extern "C" {
    pub fn g_date_subtract_days(date: *mut GDate, n_days: guint);
}
extern "C" {
    pub fn g_date_add_months(date: *mut GDate, n_months: guint);
}
extern "C" {
    pub fn g_date_subtract_months(date: *mut GDate, n_months: guint);
}
extern "C" {
    pub fn g_date_add_years(date: *mut GDate, n_years: guint);
}
extern "C" {
    pub fn g_date_subtract_years(date: *mut GDate, n_years: guint);
}
extern "C" {
    pub fn g_date_is_leap_year(year: GDateYear) -> gboolean;
}
extern "C" {
    pub fn g_date_get_days_in_month(month: GDateMonth, year: GDateYear) -> guint8;
}
extern "C" {
    pub fn g_date_get_monday_weeks_in_year(year: GDateYear) -> guint8;
}
extern "C" {
    pub fn g_date_get_sunday_weeks_in_year(year: GDateYear) -> guint8;
}
extern "C" {
    pub fn g_date_days_between(date1: *const GDate, date2: *const GDate) -> gint;
}
extern "C" {
    pub fn g_date_compare(lhs: *const GDate, rhs: *const GDate) -> gint;
}
extern "C" {
    pub fn g_date_to_struct_tm(date: *const GDate, tm: *mut tm);
}
extern "C" {
    pub fn g_date_clamp(date: *mut GDate, min_date: *const GDate, max_date: *const GDate);
}
extern "C" {
    pub fn g_date_order(date1: *mut GDate, date2: *mut GDate);
}
extern "C" {
    pub fn g_date_strftime(
        s: *mut gchar,
        slen: gsize,
        format: *const gchar,
        date: *const GDate,
    ) -> gsize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTimeZone {
    _unused: [u8; 0],
}
pub type GTimeZone = _GTimeZone;
pub const GTimeType_G_TIME_TYPE_STANDARD: GTimeType = 0;
pub const GTimeType_G_TIME_TYPE_DAYLIGHT: GTimeType = 1;
pub const GTimeType_G_TIME_TYPE_UNIVERSAL: GTimeType = 2;
#[doc = " GTimeType:"]
#[doc = " @G_TIME_TYPE_STANDARD: the time is in local standard time"]
#[doc = " @G_TIME_TYPE_DAYLIGHT: the time is in local daylight time"]
#[doc = " @G_TIME_TYPE_UNIVERSAL: the time is in UTC"]
#[doc = ""]
#[doc = " Disambiguates a given time in two ways."]
#[doc = ""]
#[doc = " First, specifies if the given time is in universal or local time."]
#[doc = ""]
#[doc = " Second, if the time is in local time, specifies if it is local"]
#[doc = " standard time or local daylight time.  This is important for the case"]
#[doc = " where the same local time occurs twice (during daylight savings time"]
#[doc = " transitions, for example)."]
pub type GTimeType = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_time_zone_new(identifier: *const gchar) -> *mut GTimeZone;
}
extern "C" {
    pub fn g_time_zone_new_utc() -> *mut GTimeZone;
}
extern "C" {
    pub fn g_time_zone_new_local() -> *mut GTimeZone;
}
extern "C" {
    pub fn g_time_zone_new_offset(seconds: gint32) -> *mut GTimeZone;
}
extern "C" {
    pub fn g_time_zone_ref(tz: *mut GTimeZone) -> *mut GTimeZone;
}
extern "C" {
    pub fn g_time_zone_unref(tz: *mut GTimeZone);
}
extern "C" {
    pub fn g_time_zone_find_interval(tz: *mut GTimeZone, type_: GTimeType, time_: gint64) -> gint;
}
extern "C" {
    pub fn g_time_zone_adjust_time(
        tz: *mut GTimeZone,
        type_: GTimeType,
        time_: *mut gint64,
    ) -> gint;
}
extern "C" {
    pub fn g_time_zone_get_abbreviation(tz: *mut GTimeZone, interval: gint) -> *const gchar;
}
extern "C" {
    pub fn g_time_zone_get_offset(tz: *mut GTimeZone, interval: gint) -> gint32;
}
extern "C" {
    pub fn g_time_zone_is_dst(tz: *mut GTimeZone, interval: gint) -> gboolean;
}
extern "C" {
    pub fn g_time_zone_get_identifier(tz: *mut GTimeZone) -> *const gchar;
}
#[doc = " GTimeSpan:"]
#[doc = ""]
#[doc = " A value representing an interval of time, in microseconds."]
#[doc = ""]
#[doc = " Since: 2.26"]
pub type GTimeSpan = gint64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDateTime {
    _unused: [u8; 0],
}
#[doc = " GDateTime:"]
#[doc = ""]
#[doc = " `GDateTime` is an opaque structure whose members"]
#[doc = " cannot be accessed directly."]
#[doc = ""]
#[doc = " Since: 2.26"]
pub type GDateTime = _GDateTime;
extern "C" {
    pub fn g_date_time_unref(datetime: *mut GDateTime);
}
extern "C" {
    pub fn g_date_time_ref(datetime: *mut GDateTime) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_now(tz: *mut GTimeZone) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_now_local() -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_now_utc() -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_from_unix_local(t: gint64) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_from_unix_utc(t: gint64) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_from_timeval_local(tv: *const GTimeVal) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_from_timeval_utc(tv: *const GTimeVal) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_from_iso8601(
        text: *const gchar,
        default_tz: *mut GTimeZone,
    ) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new(
        tz: *mut GTimeZone,
        year: gint,
        month: gint,
        day: gint,
        hour: gint,
        minute: gint,
        seconds: gdouble,
    ) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_local(
        year: gint,
        month: gint,
        day: gint,
        hour: gint,
        minute: gint,
        seconds: gdouble,
    ) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_utc(
        year: gint,
        month: gint,
        day: gint,
        hour: gint,
        minute: gint,
        seconds: gdouble,
    ) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_add(datetime: *mut GDateTime, timespan: GTimeSpan) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_add_years(datetime: *mut GDateTime, years: gint) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_add_months(datetime: *mut GDateTime, months: gint) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_add_weeks(datetime: *mut GDateTime, weeks: gint) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_add_days(datetime: *mut GDateTime, days: gint) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_add_hours(datetime: *mut GDateTime, hours: gint) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_add_minutes(datetime: *mut GDateTime, minutes: gint) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_add_seconds(datetime: *mut GDateTime, seconds: gdouble) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_add_full(
        datetime: *mut GDateTime,
        years: gint,
        months: gint,
        days: gint,
        hours: gint,
        minutes: gint,
        seconds: gdouble,
    ) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_compare(dt1: gconstpointer, dt2: gconstpointer) -> gint;
}
extern "C" {
    pub fn g_date_time_difference(end: *mut GDateTime, begin: *mut GDateTime) -> GTimeSpan;
}
extern "C" {
    pub fn g_date_time_hash(datetime: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_date_time_equal(dt1: gconstpointer, dt2: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_date_time_get_ymd(
        datetime: *mut GDateTime,
        year: *mut gint,
        month: *mut gint,
        day: *mut gint,
    );
}
extern "C" {
    pub fn g_date_time_get_year(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_month(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_day_of_month(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_week_numbering_year(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_week_of_year(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_day_of_week(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_day_of_year(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_hour(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_minute(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_second(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_microsecond(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_seconds(datetime: *mut GDateTime) -> gdouble;
}
extern "C" {
    pub fn g_date_time_to_unix(datetime: *mut GDateTime) -> gint64;
}
extern "C" {
    pub fn g_date_time_to_timeval(datetime: *mut GDateTime, tv: *mut GTimeVal) -> gboolean;
}
extern "C" {
    pub fn g_date_time_get_utc_offset(datetime: *mut GDateTime) -> GTimeSpan;
}
extern "C" {
    pub fn g_date_time_get_timezone(datetime: *mut GDateTime) -> *mut GTimeZone;
}
extern "C" {
    pub fn g_date_time_get_timezone_abbreviation(datetime: *mut GDateTime) -> *const gchar;
}
extern "C" {
    pub fn g_date_time_is_daylight_savings(datetime: *mut GDateTime) -> gboolean;
}
extern "C" {
    pub fn g_date_time_to_timezone(datetime: *mut GDateTime, tz: *mut GTimeZone) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_to_local(datetime: *mut GDateTime) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_to_utc(datetime: *mut GDateTime) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_format(datetime: *mut GDateTime, format: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_date_time_format_iso8601(datetime: *mut GDateTime) -> *mut gchar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dirent {
    pub d_ino: __ino_t,
    pub d_off: __off_t,
    pub d_reclen: ::std::os::raw::c_ushort,
    pub d_type: ::std::os::raw::c_uchar,
    pub d_name: [::std::os::raw::c_char; 256usize],
}
#[test]
fn bindgen_test_layout_dirent() {
    assert_eq!(
        ::std::mem::size_of::<dirent>(),
        280usize,
        concat!("Size of: ", stringify!(dirent))
    );
    assert_eq!(
        ::std::mem::align_of::<dirent>(),
        8usize,
        concat!("Alignment of ", stringify!(dirent))
    );
    fn test_field_d_ino() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dirent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).d_ino) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(dirent),
                "::",
                stringify!(d_ino)
            )
        );
    }
    test_field_d_ino();
    fn test_field_d_off() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dirent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).d_off) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(dirent),
                "::",
                stringify!(d_off)
            )
        );
    }
    test_field_d_off();
    fn test_field_d_reclen() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dirent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).d_reclen) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(dirent),
                "::",
                stringify!(d_reclen)
            )
        );
    }
    test_field_d_reclen();
    fn test_field_d_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dirent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).d_type) as usize - ptr as usize
            },
            18usize,
            concat!(
                "Offset of field: ",
                stringify!(dirent),
                "::",
                stringify!(d_type)
            )
        );
    }
    test_field_d_type();
    fn test_field_d_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dirent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).d_name) as usize - ptr as usize
            },
            19usize,
            concat!(
                "Offset of field: ",
                stringify!(dirent),
                "::",
                stringify!(d_name)
            )
        );
    }
    test_field_d_name();
}
pub const DT_UNKNOWN: _bindgen_ty_10 = 0;
pub const DT_FIFO: _bindgen_ty_10 = 1;
pub const DT_CHR: _bindgen_ty_10 = 2;
pub const DT_DIR: _bindgen_ty_10 = 4;
pub const DT_BLK: _bindgen_ty_10 = 6;
pub const DT_REG: _bindgen_ty_10 = 8;
pub const DT_LNK: _bindgen_ty_10 = 10;
pub const DT_SOCK: _bindgen_ty_10 = 12;
pub const DT_WHT: _bindgen_ty_10 = 14;
pub type _bindgen_ty_10 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __dirstream {
    _unused: [u8; 0],
}
pub type DIR = __dirstream;
extern "C" {
    pub fn opendir(__name: *const ::std::os::raw::c_char) -> *mut DIR;
}
extern "C" {
    pub fn fdopendir(__fd: ::std::os::raw::c_int) -> *mut DIR;
}
extern "C" {
    pub fn closedir(__dirp: *mut DIR) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn readdir(__dirp: *mut DIR) -> *mut dirent;
}
extern "C" {
    pub fn readdir_r(
        __dirp: *mut DIR,
        __entry: *mut dirent,
        __result: *mut *mut dirent,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rewinddir(__dirp: *mut DIR);
}
extern "C" {
    pub fn seekdir(__dirp: *mut DIR, __pos: ::std::os::raw::c_long);
}
extern "C" {
    pub fn telldir(__dirp: *mut DIR) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn dirfd(__dirp: *mut DIR) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scandir(
        __dir: *const ::std::os::raw::c_char,
        __namelist: *mut *mut *mut dirent,
        __selector: ::std::option::Option<
            unsafe extern "C" fn(arg1: *const dirent) -> ::std::os::raw::c_int,
        >,
        __cmp: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut *const dirent,
                arg2: *mut *const dirent,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alphasort(__e1: *mut *const dirent, __e2: *mut *const dirent) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdirentries(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __nbytes: size_t,
        __basep: *mut __off_t,
    ) -> __ssize_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDir {
    _unused: [u8; 0],
}
pub type GDir = _GDir;
extern "C" {
    pub fn g_dir_open(path: *const gchar, flags: guint, error: *mut *mut GError) -> *mut GDir;
}
extern "C" {
    pub fn g_dir_read_name(dir: *mut GDir) -> *const gchar;
}
extern "C" {
    pub fn g_dir_rewind(dir: *mut GDir);
}
extern "C" {
    pub fn g_dir_close(dir: *mut GDir);
}
extern "C" {
    pub fn g_getenv(variable: *const gchar) -> *const gchar;
}
extern "C" {
    pub fn g_setenv(variable: *const gchar, value: *const gchar, overwrite: gboolean) -> gboolean;
}
extern "C" {
    pub fn g_unsetenv(variable: *const gchar);
}
extern "C" {
    pub fn g_listenv() -> *mut *mut gchar;
}
extern "C" {
    pub fn g_get_environ() -> *mut *mut gchar;
}
extern "C" {
    pub fn g_environ_getenv(envp: *mut *mut gchar, variable: *const gchar) -> *const gchar;
}
extern "C" {
    pub fn g_environ_setenv(
        envp: *mut *mut gchar,
        variable: *const gchar,
        value: *const gchar,
        overwrite: gboolean,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_environ_unsetenv(envp: *mut *mut gchar, variable: *const gchar) -> *mut *mut gchar;
}
pub const GFileError_G_FILE_ERROR_EXIST: GFileError = 0;
pub const GFileError_G_FILE_ERROR_ISDIR: GFileError = 1;
pub const GFileError_G_FILE_ERROR_ACCES: GFileError = 2;
pub const GFileError_G_FILE_ERROR_NAMETOOLONG: GFileError = 3;
pub const GFileError_G_FILE_ERROR_NOENT: GFileError = 4;
pub const GFileError_G_FILE_ERROR_NOTDIR: GFileError = 5;
pub const GFileError_G_FILE_ERROR_NXIO: GFileError = 6;
pub const GFileError_G_FILE_ERROR_NODEV: GFileError = 7;
pub const GFileError_G_FILE_ERROR_ROFS: GFileError = 8;
pub const GFileError_G_FILE_ERROR_TXTBSY: GFileError = 9;
pub const GFileError_G_FILE_ERROR_FAULT: GFileError = 10;
pub const GFileError_G_FILE_ERROR_LOOP: GFileError = 11;
pub const GFileError_G_FILE_ERROR_NOSPC: GFileError = 12;
pub const GFileError_G_FILE_ERROR_NOMEM: GFileError = 13;
pub const GFileError_G_FILE_ERROR_MFILE: GFileError = 14;
pub const GFileError_G_FILE_ERROR_NFILE: GFileError = 15;
pub const GFileError_G_FILE_ERROR_BADF: GFileError = 16;
pub const GFileError_G_FILE_ERROR_INVAL: GFileError = 17;
pub const GFileError_G_FILE_ERROR_PIPE: GFileError = 18;
pub const GFileError_G_FILE_ERROR_AGAIN: GFileError = 19;
pub const GFileError_G_FILE_ERROR_INTR: GFileError = 20;
pub const GFileError_G_FILE_ERROR_IO: GFileError = 21;
pub const GFileError_G_FILE_ERROR_PERM: GFileError = 22;
pub const GFileError_G_FILE_ERROR_NOSYS: GFileError = 23;
pub const GFileError_G_FILE_ERROR_FAILED: GFileError = 24;
pub type GFileError = ::std::os::raw::c_uint;
pub const GFileTest_G_FILE_TEST_IS_REGULAR: GFileTest = 1;
pub const GFileTest_G_FILE_TEST_IS_SYMLINK: GFileTest = 2;
pub const GFileTest_G_FILE_TEST_IS_DIR: GFileTest = 4;
pub const GFileTest_G_FILE_TEST_IS_EXECUTABLE: GFileTest = 8;
pub const GFileTest_G_FILE_TEST_EXISTS: GFileTest = 16;
pub type GFileTest = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_file_error_quark() -> GQuark;
}
extern "C" {
    pub fn g_file_error_from_errno(err_no: gint) -> GFileError;
}
extern "C" {
    pub fn g_file_test(filename: *const gchar, test: GFileTest) -> gboolean;
}
extern "C" {
    pub fn g_file_get_contents(
        filename: *const gchar,
        contents: *mut *mut gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_set_contents(
        filename: *const gchar,
        contents: *const gchar,
        length: gssize,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_read_link(filename: *const gchar, error: *mut *mut GError) -> *mut gchar;
}
extern "C" {
    pub fn g_mkdtemp(tmpl: *mut gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_mkdtemp_full(tmpl: *mut gchar, mode: gint) -> *mut gchar;
}
extern "C" {
    pub fn g_mkstemp(tmpl: *mut gchar) -> gint;
}
extern "C" {
    pub fn g_mkstemp_full(tmpl: *mut gchar, flags: gint, mode: gint) -> gint;
}
extern "C" {
    pub fn g_file_open_tmp(
        tmpl: *const gchar,
        name_used: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gint;
}
extern "C" {
    pub fn g_dir_make_tmp(tmpl: *const gchar, error: *mut *mut GError) -> *mut gchar;
}
extern "C" {
    pub fn g_build_path(separator: *const gchar, first_element: *const gchar, ...) -> *mut gchar;
}
extern "C" {
    pub fn g_build_pathv(separator: *const gchar, args: *mut *mut gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_build_filename(first_element: *const gchar, ...) -> *mut gchar;
}
extern "C" {
    pub fn g_build_filenamev(args: *mut *mut gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_build_filename_valist(first_element: *const gchar, args: *mut va_list) -> *mut gchar;
}
extern "C" {
    pub fn g_mkdir_with_parents(pathname: *const gchar, mode: gint) -> gint;
}
extern "C" {
    pub fn g_path_is_absolute(file_name: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_path_skip_root(file_name: *const gchar) -> *const gchar;
}
extern "C" {
    pub fn g_basename(file_name: *const gchar) -> *const gchar;
}
extern "C" {
    pub fn g_get_current_dir() -> *mut gchar;
}
extern "C" {
    pub fn g_path_get_basename(file_name: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_path_get_dirname(file_name: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_canonicalize_filename(filename: *const gchar, relative_to: *const gchar)
        -> *mut gchar;
}
extern "C" {
    pub fn g_strip_context(msgid: *const gchar, msgval: *const gchar) -> *const gchar;
}
extern "C" {
    pub fn g_dgettext(domain: *const gchar, msgid: *const gchar) -> *const gchar;
}
extern "C" {
    pub fn g_dcgettext(domain: *const gchar, msgid: *const gchar, category: gint) -> *const gchar;
}
extern "C" {
    pub fn g_dngettext(
        domain: *const gchar,
        msgid: *const gchar,
        msgid_plural: *const gchar,
        n: gulong,
    ) -> *const gchar;
}
extern "C" {
    pub fn g_dpgettext(
        domain: *const gchar,
        msgctxtid: *const gchar,
        msgidoffset: gsize,
    ) -> *const gchar;
}
extern "C" {
    pub fn g_dpgettext2(
        domain: *const gchar,
        context: *const gchar,
        msgid: *const gchar,
    ) -> *const gchar;
}
#[doc = " GMemVTable:"]
#[doc = " @malloc: function to use for allocating memory."]
#[doc = " @realloc: function to use for reallocating memory."]
#[doc = " @free: function to use to free memory."]
#[doc = " @calloc: function to use for allocating zero-filled memory."]
#[doc = " @try_malloc: function to use for allocating memory without a default error handler."]
#[doc = " @try_realloc: function to use for reallocating memory without a default error handler."]
#[doc = ""]
#[doc = " A set of functions used to perform memory allocation. The same #GMemVTable must"]
#[doc = " be used for all allocations in the same program; a call to g_mem_set_vtable(),"]
#[doc = " if it exists, should be prior to any use of GLib."]
#[doc = ""]
#[doc = " This functions related to this has been deprecated in 2.46, and no longer work."]
pub type GMemVTable = _GMemVTable;
extern "C" {
    pub fn g_free(mem: gpointer);
}
extern "C" {
    pub fn g_clear_pointer(pp: *mut gpointer, destroy: GDestroyNotify);
}
extern "C" {
    pub fn g_malloc(n_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_malloc0(n_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_realloc(mem: gpointer, n_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_try_malloc(n_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_try_malloc0(n_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_try_realloc(mem: gpointer, n_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_malloc_n(n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_malloc0_n(n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_realloc_n(mem: gpointer, n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_try_malloc_n(n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_try_malloc0_n(n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_try_realloc_n(mem: gpointer, n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMemVTable {
    pub malloc: ::std::option::Option<unsafe extern "C" fn(n_bytes: gsize) -> gpointer>,
    pub realloc:
        ::std::option::Option<unsafe extern "C" fn(mem: gpointer, n_bytes: gsize) -> gpointer>,
    pub free: ::std::option::Option<unsafe extern "C" fn(mem: gpointer)>,
    pub calloc: ::std::option::Option<
        unsafe extern "C" fn(n_blocks: gsize, n_block_bytes: gsize) -> gpointer,
    >,
    pub try_malloc: ::std::option::Option<unsafe extern "C" fn(n_bytes: gsize) -> gpointer>,
    pub try_realloc:
        ::std::option::Option<unsafe extern "C" fn(mem: gpointer, n_bytes: gsize) -> gpointer>,
}
#[test]
fn bindgen_test_layout__GMemVTable() {
    assert_eq!(
        ::std::mem::size_of::<_GMemVTable>(),
        48usize,
        concat!("Size of: ", stringify!(_GMemVTable))
    );
    assert_eq!(
        ::std::mem::align_of::<_GMemVTable>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMemVTable))
    );
    fn test_field_malloc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GMemVTable>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).malloc) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GMemVTable),
                "::",
                stringify!(malloc)
            )
        );
    }
    test_field_malloc();
    fn test_field_realloc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GMemVTable>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).realloc) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_GMemVTable),
                "::",
                stringify!(realloc)
            )
        );
    }
    test_field_realloc();
    fn test_field_free() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GMemVTable>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).free) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_GMemVTable),
                "::",
                stringify!(free)
            )
        );
    }
    test_field_free();
    fn test_field_calloc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GMemVTable>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).calloc) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_GMemVTable),
                "::",
                stringify!(calloc)
            )
        );
    }
    test_field_calloc();
    fn test_field_try_malloc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GMemVTable>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).try_malloc) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_GMemVTable),
                "::",
                stringify!(try_malloc)
            )
        );
    }
    test_field_try_malloc();
    fn test_field_try_realloc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GMemVTable>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).try_realloc) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_GMemVTable),
                "::",
                stringify!(try_realloc)
            )
        );
    }
    test_field_try_realloc();
}
extern "C" {
    pub fn g_mem_set_vtable(vtable: *mut GMemVTable);
}
extern "C" {
    pub fn g_mem_is_system_malloc() -> gboolean;
}
extern "C" {
    pub static mut g_mem_gc_friendly: gboolean;
}
extern "C" {
    pub static mut glib_mem_profiler_table: *mut GMemVTable;
}
extern "C" {
    pub fn g_mem_profile();
}
pub type GNode = _GNode;
pub const GTraverseFlags_G_TRAVERSE_LEAVES: GTraverseFlags = 1;
pub const GTraverseFlags_G_TRAVERSE_NON_LEAVES: GTraverseFlags = 2;
pub const GTraverseFlags_G_TRAVERSE_ALL: GTraverseFlags = 3;
pub const GTraverseFlags_G_TRAVERSE_MASK: GTraverseFlags = 3;
pub const GTraverseFlags_G_TRAVERSE_LEAFS: GTraverseFlags = 1;
pub const GTraverseFlags_G_TRAVERSE_NON_LEAFS: GTraverseFlags = 2;
pub type GTraverseFlags = ::std::os::raw::c_uint;
pub const GTraverseType_G_IN_ORDER: GTraverseType = 0;
pub const GTraverseType_G_PRE_ORDER: GTraverseType = 1;
pub const GTraverseType_G_POST_ORDER: GTraverseType = 2;
pub const GTraverseType_G_LEVEL_ORDER: GTraverseType = 3;
pub type GTraverseType = ::std::os::raw::c_uint;
pub type GNodeTraverseFunc =
    ::std::option::Option<unsafe extern "C" fn(node: *mut GNode, data: gpointer) -> gboolean>;
pub type GNodeForeachFunc =
    ::std::option::Option<unsafe extern "C" fn(node: *mut GNode, data: gpointer)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GNode {
    pub data: gpointer,
    pub next: *mut GNode,
    pub prev: *mut GNode,
    pub parent: *mut GNode,
    pub children: *mut GNode,
}
#[test]
fn bindgen_test_layout__GNode() {
    assert_eq!(
        ::std::mem::size_of::<_GNode>(),
        40usize,
        concat!("Size of: ", stringify!(_GNode))
    );
    assert_eq!(
        ::std::mem::align_of::<_GNode>(),
        8usize,
        concat!("Alignment of ", stringify!(_GNode))
    );
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GNode>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GNode),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GNode>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_GNode),
                "::",
                stringify!(next)
            )
        );
    }
    test_field_next();
    fn test_field_prev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GNode>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_GNode),
                "::",
                stringify!(prev)
            )
        );
    }
    test_field_prev();
    fn test_field_parent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GNode>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_GNode),
                "::",
                stringify!(parent)
            )
        );
    }
    test_field_parent();
    fn test_field_children() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GNode>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).children) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_GNode),
                "::",
                stringify!(children)
            )
        );
    }
    test_field_children();
}
extern "C" {
    pub fn g_node_new(data: gpointer) -> *mut GNode;
}
extern "C" {
    pub fn g_node_destroy(root: *mut GNode);
}
extern "C" {
    pub fn g_node_unlink(node: *mut GNode);
}
extern "C" {
    pub fn g_node_copy_deep(node: *mut GNode, copy_func: GCopyFunc, data: gpointer) -> *mut GNode;
}
extern "C" {
    pub fn g_node_copy(node: *mut GNode) -> *mut GNode;
}
extern "C" {
    pub fn g_node_insert(parent: *mut GNode, position: gint, node: *mut GNode) -> *mut GNode;
}
extern "C" {
    pub fn g_node_insert_before(
        parent: *mut GNode,
        sibling: *mut GNode,
        node: *mut GNode,
    ) -> *mut GNode;
}
extern "C" {
    pub fn g_node_insert_after(
        parent: *mut GNode,
        sibling: *mut GNode,
        node: *mut GNode,
    ) -> *mut GNode;
}
extern "C" {
    pub fn g_node_prepend(parent: *mut GNode, node: *mut GNode) -> *mut GNode;
}
extern "C" {
    pub fn g_node_n_nodes(root: *mut GNode, flags: GTraverseFlags) -> guint;
}
extern "C" {
    pub fn g_node_get_root(node: *mut GNode) -> *mut GNode;
}
extern "C" {
    pub fn g_node_is_ancestor(node: *mut GNode, descendant: *mut GNode) -> gboolean;
}
extern "C" {
    pub fn g_node_depth(node: *mut GNode) -> guint;
}
extern "C" {
    pub fn g_node_find(
        root: *mut GNode,
        order: GTraverseType,
        flags: GTraverseFlags,
        data: gpointer,
    ) -> *mut GNode;
}
extern "C" {
    pub fn g_node_traverse(
        root: *mut GNode,
        order: GTraverseType,
        flags: GTraverseFlags,
        max_depth: gint,
        func: GNodeTraverseFunc,
        data: gpointer,
    );
}
extern "C" {
    pub fn g_node_max_height(root: *mut GNode) -> guint;
}
extern "C" {
    pub fn g_node_children_foreach(
        node: *mut GNode,
        flags: GTraverseFlags,
        func: GNodeForeachFunc,
        data: gpointer,
    );
}
extern "C" {
    pub fn g_node_reverse_children(node: *mut GNode);
}
extern "C" {
    pub fn g_node_n_children(node: *mut GNode) -> guint;
}
extern "C" {
    pub fn g_node_nth_child(node: *mut GNode, n: guint) -> *mut GNode;
}
extern "C" {
    pub fn g_node_last_child(node: *mut GNode) -> *mut GNode;
}
extern "C" {
    pub fn g_node_find_child(node: *mut GNode, flags: GTraverseFlags, data: gpointer)
        -> *mut GNode;
}
extern "C" {
    pub fn g_node_child_position(node: *mut GNode, child: *mut GNode) -> gint;
}
extern "C" {
    pub fn g_node_child_index(node: *mut GNode, data: gpointer) -> gint;
}
extern "C" {
    pub fn g_node_first_sibling(node: *mut GNode) -> *mut GNode;
}
extern "C" {
    pub fn g_node_last_sibling(node: *mut GNode) -> *mut GNode;
}
pub type GList = _GList;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GList {
    pub data: gpointer,
    pub next: *mut GList,
    pub prev: *mut GList,
}
#[test]
fn bindgen_test_layout__GList() {
    assert_eq!(
        ::std::mem::size_of::<_GList>(),
        24usize,
        concat!("Size of: ", stringify!(_GList))
    );
    assert_eq!(
        ::std::mem::align_of::<_GList>(),
        8usize,
        concat!("Alignment of ", stringify!(_GList))
    );
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GList>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GList),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GList>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_GList),
                "::",
                stringify!(next)
            )
        );
    }
    test_field_next();
    fn test_field_prev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GList>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_GList),
                "::",
                stringify!(prev)
            )
        );
    }
    test_field_prev();
}
extern "C" {
    pub fn g_list_alloc() -> *mut GList;
}
extern "C" {
    pub fn g_list_free(list: *mut GList);
}
extern "C" {
    pub fn g_list_free_1(list: *mut GList);
}
extern "C" {
    pub fn g_list_free_full(list: *mut GList, free_func: GDestroyNotify);
}
extern "C" {
    pub fn g_list_append(list: *mut GList, data: gpointer) -> *mut GList;
}
extern "C" {
    pub fn g_list_prepend(list: *mut GList, data: gpointer) -> *mut GList;
}
extern "C" {
    pub fn g_list_insert(list: *mut GList, data: gpointer, position: gint) -> *mut GList;
}
extern "C" {
    pub fn g_list_insert_sorted(list: *mut GList, data: gpointer, func: GCompareFunc)
        -> *mut GList;
}
extern "C" {
    pub fn g_list_insert_sorted_with_data(
        list: *mut GList,
        data: gpointer,
        func: GCompareDataFunc,
        user_data: gpointer,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_list_insert_before(
        list: *mut GList,
        sibling: *mut GList,
        data: gpointer,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_list_insert_before_link(
        list: *mut GList,
        sibling: *mut GList,
        link_: *mut GList,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_list_concat(list1: *mut GList, list2: *mut GList) -> *mut GList;
}
extern "C" {
    pub fn g_list_remove(list: *mut GList, data: gconstpointer) -> *mut GList;
}
extern "C" {
    pub fn g_list_remove_all(list: *mut GList, data: gconstpointer) -> *mut GList;
}
extern "C" {
    pub fn g_list_remove_link(list: *mut GList, llink: *mut GList) -> *mut GList;
}
extern "C" {
    pub fn g_list_delete_link(list: *mut GList, link_: *mut GList) -> *mut GList;
}
extern "C" {
    pub fn g_list_reverse(list: *mut GList) -> *mut GList;
}
extern "C" {
    pub fn g_list_copy(list: *mut GList) -> *mut GList;
}
extern "C" {
    pub fn g_list_copy_deep(list: *mut GList, func: GCopyFunc, user_data: gpointer) -> *mut GList;
}
extern "C" {
    pub fn g_list_nth(list: *mut GList, n: guint) -> *mut GList;
}
extern "C" {
    pub fn g_list_nth_prev(list: *mut GList, n: guint) -> *mut GList;
}
extern "C" {
    pub fn g_list_find(list: *mut GList, data: gconstpointer) -> *mut GList;
}
extern "C" {
    pub fn g_list_find_custom(
        list: *mut GList,
        data: gconstpointer,
        func: GCompareFunc,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_list_position(list: *mut GList, llink: *mut GList) -> gint;
}
extern "C" {
    pub fn g_list_index(list: *mut GList, data: gconstpointer) -> gint;
}
extern "C" {
    pub fn g_list_last(list: *mut GList) -> *mut GList;
}
extern "C" {
    pub fn g_list_first(list: *mut GList) -> *mut GList;
}
extern "C" {
    pub fn g_list_length(list: *mut GList) -> guint;
}
extern "C" {
    pub fn g_list_foreach(list: *mut GList, func: GFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_list_sort(list: *mut GList, compare_func: GCompareFunc) -> *mut GList;
}
extern "C" {
    pub fn g_list_sort_with_data(
        list: *mut GList,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_list_nth_data(list: *mut GList, n: guint) -> gpointer;
}
extern "C" {
    pub fn g_clear_list(list_ptr: *mut *mut GList, destroy: GDestroyNotify);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GHashTable {
    _unused: [u8; 0],
}
pub type GHashTable = _GHashTable;
pub type GHRFunc = ::std::option::Option<
    unsafe extern "C" fn(key: gpointer, value: gpointer, user_data: gpointer) -> gboolean,
>;
pub type GHashTableIter = _GHashTableIter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GHashTableIter {
    pub dummy1: gpointer,
    pub dummy2: gpointer,
    pub dummy3: gpointer,
    pub dummy4: ::std::os::raw::c_int,
    pub dummy5: gboolean,
    pub dummy6: gpointer,
}
#[test]
fn bindgen_test_layout__GHashTableIter() {
    assert_eq!(
        ::std::mem::size_of::<_GHashTableIter>(),
        40usize,
        concat!("Size of: ", stringify!(_GHashTableIter))
    );
    assert_eq!(
        ::std::mem::align_of::<_GHashTableIter>(),
        8usize,
        concat!("Alignment of ", stringify!(_GHashTableIter))
    );
    fn test_field_dummy1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GHashTableIter>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dummy1) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GHashTableIter),
                "::",
                stringify!(dummy1)
            )
        );
    }
    test_field_dummy1();
    fn test_field_dummy2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GHashTableIter>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dummy2) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_GHashTableIter),
                "::",
                stringify!(dummy2)
            )
        );
    }
    test_field_dummy2();
    fn test_field_dummy3() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GHashTableIter>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dummy3) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_GHashTableIter),
                "::",
                stringify!(dummy3)
            )
        );
    }
    test_field_dummy3();
    fn test_field_dummy4() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GHashTableIter>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dummy4) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_GHashTableIter),
                "::",
                stringify!(dummy4)
            )
        );
    }
    test_field_dummy4();
    fn test_field_dummy5() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GHashTableIter>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dummy5) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(_GHashTableIter),
                "::",
                stringify!(dummy5)
            )
        );
    }
    test_field_dummy5();
    fn test_field_dummy6() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GHashTableIter>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dummy6) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_GHashTableIter),
                "::",
                stringify!(dummy6)
            )
        );
    }
    test_field_dummy6();
}
extern "C" {
    pub fn g_hash_table_new(hash_func: GHashFunc, key_equal_func: GEqualFunc) -> *mut GHashTable;
}
extern "C" {
    pub fn g_hash_table_new_full(
        hash_func: GHashFunc,
        key_equal_func: GEqualFunc,
        key_destroy_func: GDestroyNotify,
        value_destroy_func: GDestroyNotify,
    ) -> *mut GHashTable;
}
extern "C" {
    pub fn g_hash_table_destroy(hash_table: *mut GHashTable);
}
extern "C" {
    pub fn g_hash_table_insert(
        hash_table: *mut GHashTable,
        key: gpointer,
        value: gpointer,
    ) -> gboolean;
}
extern "C" {
    pub fn g_hash_table_replace(
        hash_table: *mut GHashTable,
        key: gpointer,
        value: gpointer,
    ) -> gboolean;
}
extern "C" {
    pub fn g_hash_table_add(hash_table: *mut GHashTable, key: gpointer) -> gboolean;
}
extern "C" {
    pub fn g_hash_table_remove(hash_table: *mut GHashTable, key: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_hash_table_remove_all(hash_table: *mut GHashTable);
}
extern "C" {
    pub fn g_hash_table_steal(hash_table: *mut GHashTable, key: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_hash_table_steal_extended(
        hash_table: *mut GHashTable,
        lookup_key: gconstpointer,
        stolen_key: *mut gpointer,
        stolen_value: *mut gpointer,
    ) -> gboolean;
}
extern "C" {
    pub fn g_hash_table_steal_all(hash_table: *mut GHashTable);
}
extern "C" {
    pub fn g_hash_table_lookup(hash_table: *mut GHashTable, key: gconstpointer) -> gpointer;
}
extern "C" {
    pub fn g_hash_table_contains(hash_table: *mut GHashTable, key: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_hash_table_lookup_extended(
        hash_table: *mut GHashTable,
        lookup_key: gconstpointer,
        orig_key: *mut gpointer,
        value: *mut gpointer,
    ) -> gboolean;
}
extern "C" {
    pub fn g_hash_table_foreach(hash_table: *mut GHashTable, func: GHFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_hash_table_find(
        hash_table: *mut GHashTable,
        predicate: GHRFunc,
        user_data: gpointer,
    ) -> gpointer;
}
extern "C" {
    pub fn g_hash_table_foreach_remove(
        hash_table: *mut GHashTable,
        func: GHRFunc,
        user_data: gpointer,
    ) -> guint;
}
extern "C" {
    pub fn g_hash_table_foreach_steal(
        hash_table: *mut GHashTable,
        func: GHRFunc,
        user_data: gpointer,
    ) -> guint;
}
extern "C" {
    pub fn g_hash_table_size(hash_table: *mut GHashTable) -> guint;
}
extern "C" {
    pub fn g_hash_table_get_keys(hash_table: *mut GHashTable) -> *mut GList;
}
extern "C" {
    pub fn g_hash_table_get_values(hash_table: *mut GHashTable) -> *mut GList;
}
extern "C" {
    pub fn g_hash_table_get_keys_as_array(
        hash_table: *mut GHashTable,
        length: *mut guint,
    ) -> *mut gpointer;
}
extern "C" {
    pub fn g_hash_table_iter_init(iter: *mut GHashTableIter, hash_table: *mut GHashTable);
}
extern "C" {
    pub fn g_hash_table_iter_next(
        iter: *mut GHashTableIter,
        key: *mut gpointer,
        value: *mut gpointer,
    ) -> gboolean;
}
extern "C" {
    pub fn g_hash_table_iter_get_hash_table(iter: *mut GHashTableIter) -> *mut GHashTable;
}
extern "C" {
    pub fn g_hash_table_iter_remove(iter: *mut GHashTableIter);
}
extern "C" {
    pub fn g_hash_table_iter_replace(iter: *mut GHashTableIter, value: gpointer);
}
extern "C" {
    pub fn g_hash_table_iter_steal(iter: *mut GHashTableIter);
}
extern "C" {
    pub fn g_hash_table_ref(hash_table: *mut GHashTable) -> *mut GHashTable;
}
extern "C" {
    pub fn g_hash_table_unref(hash_table: *mut GHashTable);
}
extern "C" {
    pub fn g_str_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_str_hash(v: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_int_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_int_hash(v: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_int64_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_int64_hash(v: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_double_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_double_hash(v: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_direct_hash(v: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_direct_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GHmac {
    _unused: [u8; 0],
}
#[doc = " GHmac:"]
#[doc = ""]
#[doc = " An opaque structure representing a HMAC operation."]
#[doc = " To create a new GHmac, use g_hmac_new(). To free"]
#[doc = " a GHmac, use g_hmac_unref()."]
#[doc = ""]
#[doc = " Since: 2.30"]
pub type GHmac = _GHmac;
extern "C" {
    pub fn g_hmac_new(digest_type: GChecksumType, key: *const guchar, key_len: gsize)
        -> *mut GHmac;
}
extern "C" {
    pub fn g_hmac_copy(hmac: *const GHmac) -> *mut GHmac;
}
extern "C" {
    pub fn g_hmac_ref(hmac: *mut GHmac) -> *mut GHmac;
}
extern "C" {
    pub fn g_hmac_unref(hmac: *mut GHmac);
}
extern "C" {
    pub fn g_hmac_update(hmac: *mut GHmac, data: *const guchar, length: gssize);
}
extern "C" {
    pub fn g_hmac_get_string(hmac: *mut GHmac) -> *const gchar;
}
extern "C" {
    pub fn g_hmac_get_digest(hmac: *mut GHmac, buffer: *mut guint8, digest_len: *mut gsize);
}
extern "C" {
    pub fn g_compute_hmac_for_data(
        digest_type: GChecksumType,
        key: *const guchar,
        key_len: gsize,
        data: *const guchar,
        length: gsize,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_compute_hmac_for_string(
        digest_type: GChecksumType,
        key: *const guchar,
        key_len: gsize,
        str_: *const gchar,
        length: gssize,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_compute_hmac_for_bytes(
        digest_type: GChecksumType,
        key: *mut GBytes,
        data: *mut GBytes,
    ) -> *mut gchar;
}
pub type GHook = _GHook;
pub type GHookList = _GHookList;
pub type GHookCompareFunc =
    ::std::option::Option<unsafe extern "C" fn(new_hook: *mut GHook, sibling: *mut GHook) -> gint>;
pub type GHookFindFunc =
    ::std::option::Option<unsafe extern "C" fn(hook: *mut GHook, data: gpointer) -> gboolean>;
pub type GHookMarshaller =
    ::std::option::Option<unsafe extern "C" fn(hook: *mut GHook, marshal_data: gpointer)>;
pub type GHookCheckMarshaller = ::std::option::Option<
    unsafe extern "C" fn(hook: *mut GHook, marshal_data: gpointer) -> gboolean,
>;
pub type GHookFunc = ::std::option::Option<unsafe extern "C" fn(data: gpointer)>;
pub type GHookCheckFunc = ::std::option::Option<unsafe extern "C" fn(data: gpointer) -> gboolean>;
pub type GHookFinalizeFunc =
    ::std::option::Option<unsafe extern "C" fn(hook_list: *mut GHookList, hook: *mut GHook)>;
pub const GHookFlagMask_G_HOOK_FLAG_ACTIVE: GHookFlagMask = 1;
pub const GHookFlagMask_G_HOOK_FLAG_IN_CALL: GHookFlagMask = 2;
pub const GHookFlagMask_G_HOOK_FLAG_MASK: GHookFlagMask = 15;
pub type GHookFlagMask = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GHookList {
    pub seq_id: gulong,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub hooks: *mut GHook,
    pub dummy3: gpointer,
    pub finalize_hook: GHookFinalizeFunc,
    pub dummy: [gpointer; 2usize],
}
#[test]
fn bindgen_test_layout__GHookList() {
    assert_eq!(
        ::std::mem::size_of::<_GHookList>(),
        56usize,
        concat!("Size of: ", stringify!(_GHookList))
    );
    assert_eq!(
        ::std::mem::align_of::<_GHookList>(),
        8usize,
        concat!("Alignment of ", stringify!(_GHookList))
    );
    fn test_field_seq_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GHookList>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).seq_id) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GHookList),
                "::",
                stringify!(seq_id)
            )
        );
    }
    test_field_seq_id();
    fn test_field_hooks() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GHookList>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hooks) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_GHookList),
                "::",
                stringify!(hooks)
            )
        );
    }
    test_field_hooks();
    fn test_field_dummy3() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GHookList>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dummy3) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_GHookList),
                "::",
                stringify!(dummy3)
            )
        );
    }
    test_field_dummy3();
    fn test_field_finalize_hook() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GHookList>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).finalize_hook) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_GHookList),
                "::",
                stringify!(finalize_hook)
            )
        );
    }
    test_field_finalize_hook();
    fn test_field_dummy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GHookList>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_GHookList),
                "::",
                stringify!(dummy)
            )
        );
    }
    test_field_dummy();
}
impl _GHookList {
    #[inline]
    pub fn hook_size(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_hook_size(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn is_setup(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_setup(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        hook_size: guint,
        is_setup: guint,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let hook_size: u32 = unsafe { ::std::mem::transmute(hook_size) };
            hook_size as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let is_setup: u32 = unsafe { ::std::mem::transmute(is_setup) };
            is_setup as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GHook {
    pub data: gpointer,
    pub next: *mut GHook,
    pub prev: *mut GHook,
    pub ref_count: guint,
    pub hook_id: gulong,
    pub flags: guint,
    pub func: gpointer,
    pub destroy: GDestroyNotify,
}
#[test]
fn bindgen_test_layout__GHook() {
    assert_eq!(
        ::std::mem::size_of::<_GHook>(),
        64usize,
        concat!("Size of: ", stringify!(_GHook))
    );
    assert_eq!(
        ::std::mem::align_of::<_GHook>(),
        8usize,
        concat!("Alignment of ", stringify!(_GHook))
    );
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GHook>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GHook),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GHook>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_GHook),
                "::",
                stringify!(next)
            )
        );
    }
    test_field_next();
    fn test_field_prev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GHook>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_GHook),
                "::",
                stringify!(prev)
            )
        );
    }
    test_field_prev();
    fn test_field_ref_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GHook>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ref_count) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_GHook),
                "::",
                stringify!(ref_count)
            )
        );
    }
    test_field_ref_count();
    fn test_field_hook_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GHook>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hook_id) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_GHook),
                "::",
                stringify!(hook_id)
            )
        );
    }
    test_field_hook_id();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GHook>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_GHook),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_func() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GHook>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_GHook),
                "::",
                stringify!(func)
            )
        );
    }
    test_field_func();
    fn test_field_destroy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GHook>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).destroy) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_GHook),
                "::",
                stringify!(destroy)
            )
        );
    }
    test_field_destroy();
}
extern "C" {
    pub fn g_hook_list_init(hook_list: *mut GHookList, hook_size: guint);
}
extern "C" {
    pub fn g_hook_list_clear(hook_list: *mut GHookList);
}
extern "C" {
    pub fn g_hook_alloc(hook_list: *mut GHookList) -> *mut GHook;
}
extern "C" {
    pub fn g_hook_free(hook_list: *mut GHookList, hook: *mut GHook);
}
extern "C" {
    pub fn g_hook_ref(hook_list: *mut GHookList, hook: *mut GHook) -> *mut GHook;
}
extern "C" {
    pub fn g_hook_unref(hook_list: *mut GHookList, hook: *mut GHook);
}
extern "C" {
    pub fn g_hook_destroy(hook_list: *mut GHookList, hook_id: gulong) -> gboolean;
}
extern "C" {
    pub fn g_hook_destroy_link(hook_list: *mut GHookList, hook: *mut GHook);
}
extern "C" {
    pub fn g_hook_prepend(hook_list: *mut GHookList, hook: *mut GHook);
}
extern "C" {
    pub fn g_hook_insert_before(hook_list: *mut GHookList, sibling: *mut GHook, hook: *mut GHook);
}
extern "C" {
    pub fn g_hook_insert_sorted(
        hook_list: *mut GHookList,
        hook: *mut GHook,
        func: GHookCompareFunc,
    );
}
extern "C" {
    pub fn g_hook_get(hook_list: *mut GHookList, hook_id: gulong) -> *mut GHook;
}
extern "C" {
    pub fn g_hook_find(
        hook_list: *mut GHookList,
        need_valids: gboolean,
        func: GHookFindFunc,
        data: gpointer,
    ) -> *mut GHook;
}
extern "C" {
    pub fn g_hook_find_data(
        hook_list: *mut GHookList,
        need_valids: gboolean,
        data: gpointer,
    ) -> *mut GHook;
}
extern "C" {
    pub fn g_hook_find_func(
        hook_list: *mut GHookList,
        need_valids: gboolean,
        func: gpointer,
    ) -> *mut GHook;
}
extern "C" {
    pub fn g_hook_find_func_data(
        hook_list: *mut GHookList,
        need_valids: gboolean,
        func: gpointer,
        data: gpointer,
    ) -> *mut GHook;
}
extern "C" {
    pub fn g_hook_first_valid(hook_list: *mut GHookList, may_be_in_call: gboolean) -> *mut GHook;
}
extern "C" {
    pub fn g_hook_next_valid(
        hook_list: *mut GHookList,
        hook: *mut GHook,
        may_be_in_call: gboolean,
    ) -> *mut GHook;
}
extern "C" {
    pub fn g_hook_compare_ids(new_hook: *mut GHook, sibling: *mut GHook) -> gint;
}
extern "C" {
    pub fn g_hook_list_invoke(hook_list: *mut GHookList, may_recurse: gboolean);
}
extern "C" {
    pub fn g_hook_list_invoke_check(hook_list: *mut GHookList, may_recurse: gboolean);
}
extern "C" {
    pub fn g_hook_list_marshal(
        hook_list: *mut GHookList,
        may_recurse: gboolean,
        marshaller: GHookMarshaller,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_hook_list_marshal_check(
        hook_list: *mut GHookList,
        may_recurse: gboolean,
        marshaller: GHookCheckMarshaller,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_hostname_is_non_ascii(hostname: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_hostname_is_ascii_encoded(hostname: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_hostname_is_ip_address(hostname: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_hostname_to_ascii(hostname: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_hostname_to_unicode(hostname: *const gchar) -> *mut gchar;
}
#[doc = " GPollFD:"]
#[doc = " @fd: the file descriptor to poll (or a HANDLE on Win32)"]
#[doc = " @events: a bitwise combination from #GIOCondition, specifying which"]
#[doc = "     events should be polled for. Typically for reading from a file"]
#[doc = "     descriptor you would use %G_IO_IN | %G_IO_HUP | %G_IO_ERR, and"]
#[doc = "     for writing you would use %G_IO_OUT | %G_IO_ERR."]
#[doc = " @revents: a bitwise combination of flags from #GIOCondition, returned"]
#[doc = "     from the poll() function to indicate which events occurred."]
#[doc = ""]
#[doc = " Represents a file descriptor, which events to poll for, and which events"]
#[doc = " occurred."]
pub type GPollFD = _GPollFD;
#[doc = " GPollFunc:"]
#[doc = " @ufds: an array of #GPollFD elements"]
#[doc = " @nfsd: the number of elements in @ufds"]
#[doc = " @timeout_: the maximum time to wait for an event of the file descriptors."]
#[doc = "     A negative value indicates an infinite timeout."]
#[doc = ""]
#[doc = " Specifies the type of function passed to g_main_context_set_poll_func()."]
#[doc = " The semantics of the function should match those of the poll() system call."]
#[doc = ""]
#[doc = " Returns: the number of #GPollFD elements which have events or errors"]
#[doc = "     reported, or -1 if an error occurred."]
pub type GPollFunc = ::std::option::Option<
    unsafe extern "C" fn(ufds: *mut GPollFD, nfsd: guint, timeout_: gint) -> gint,
>;
#[doc = " GPollFD:"]
#[doc = " @fd: the file descriptor to poll (or a HANDLE on Win32)"]
#[doc = " @events: a bitwise combination from #GIOCondition, specifying which"]
#[doc = "     events should be polled for. Typically for reading from a file"]
#[doc = "     descriptor you would use %G_IO_IN | %G_IO_HUP | %G_IO_ERR, and"]
#[doc = "     for writing you would use %G_IO_OUT | %G_IO_ERR."]
#[doc = " @revents: a bitwise combination of flags from #GIOCondition, returned"]
#[doc = "     from the poll() function to indicate which events occurred."]
#[doc = ""]
#[doc = " Represents a file descriptor, which events to poll for, and which events"]
#[doc = " occurred."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPollFD {
    pub fd: gint,
    pub events: gushort,
    pub revents: gushort,
}
#[test]
fn bindgen_test_layout__GPollFD() {
    assert_eq!(
        ::std::mem::size_of::<_GPollFD>(),
        8usize,
        concat!("Size of: ", stringify!(_GPollFD))
    );
    assert_eq!(
        ::std::mem::align_of::<_GPollFD>(),
        4usize,
        concat!("Alignment of ", stringify!(_GPollFD))
    );
    fn test_field_fd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GPollFD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fd) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GPollFD),
                "::",
                stringify!(fd)
            )
        );
    }
    test_field_fd();
    fn test_field_events() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GPollFD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).events) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_GPollFD),
                "::",
                stringify!(events)
            )
        );
    }
    test_field_events();
    fn test_field_revents() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GPollFD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).revents) as usize - ptr as usize
            },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(_GPollFD),
                "::",
                stringify!(revents)
            )
        );
    }
    test_field_revents();
}
extern "C" {
    #[doc = " G_POLLFD_FORMAT:"]
    #[doc = ""]
    #[doc = " A format specifier that can be used in printf()-style format strings"]
    #[doc = " when printing the @fd member of a #GPollFD."]
    pub fn g_poll(fds: *mut GPollFD, nfds: guint, timeout: gint) -> gint;
}
pub type GSList = _GSList;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSList {
    pub data: gpointer,
    pub next: *mut GSList,
}
#[test]
fn bindgen_test_layout__GSList() {
    assert_eq!(
        ::std::mem::size_of::<_GSList>(),
        16usize,
        concat!("Size of: ", stringify!(_GSList))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSList>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSList))
    );
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GSList>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GSList),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GSList>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_GSList),
                "::",
                stringify!(next)
            )
        );
    }
    test_field_next();
}
extern "C" {
    pub fn g_slist_alloc() -> *mut GSList;
}
extern "C" {
    pub fn g_slist_free(list: *mut GSList);
}
extern "C" {
    pub fn g_slist_free_1(list: *mut GSList);
}
extern "C" {
    pub fn g_slist_free_full(list: *mut GSList, free_func: GDestroyNotify);
}
extern "C" {
    pub fn g_slist_append(list: *mut GSList, data: gpointer) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_prepend(list: *mut GSList, data: gpointer) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_insert(list: *mut GSList, data: gpointer, position: gint) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_insert_sorted(
        list: *mut GSList,
        data: gpointer,
        func: GCompareFunc,
    ) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_insert_sorted_with_data(
        list: *mut GSList,
        data: gpointer,
        func: GCompareDataFunc,
        user_data: gpointer,
    ) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_insert_before(
        slist: *mut GSList,
        sibling: *mut GSList,
        data: gpointer,
    ) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_concat(list1: *mut GSList, list2: *mut GSList) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_remove(list: *mut GSList, data: gconstpointer) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_remove_all(list: *mut GSList, data: gconstpointer) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_remove_link(list: *mut GSList, link_: *mut GSList) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_delete_link(list: *mut GSList, link_: *mut GSList) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_reverse(list: *mut GSList) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_copy(list: *mut GSList) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_copy_deep(
        list: *mut GSList,
        func: GCopyFunc,
        user_data: gpointer,
    ) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_nth(list: *mut GSList, n: guint) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_find(list: *mut GSList, data: gconstpointer) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_find_custom(
        list: *mut GSList,
        data: gconstpointer,
        func: GCompareFunc,
    ) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_position(list: *mut GSList, llink: *mut GSList) -> gint;
}
extern "C" {
    pub fn g_slist_index(list: *mut GSList, data: gconstpointer) -> gint;
}
extern "C" {
    pub fn g_slist_last(list: *mut GSList) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_length(list: *mut GSList) -> guint;
}
extern "C" {
    pub fn g_slist_foreach(list: *mut GSList, func: GFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_slist_sort(list: *mut GSList, compare_func: GCompareFunc) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_sort_with_data(
        list: *mut GSList,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    ) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_nth_data(list: *mut GSList, n: guint) -> gpointer;
}
extern "C" {
    pub fn g_clear_slist(slist_ptr: *mut *mut GSList, destroy: GDestroyNotify);
}
pub const GIOCondition_G_IO_IN: GIOCondition = 1;
pub const GIOCondition_G_IO_OUT: GIOCondition = 4;
pub const GIOCondition_G_IO_PRI: GIOCondition = 2;
pub const GIOCondition_G_IO_ERR: GIOCondition = 8;
pub const GIOCondition_G_IO_HUP: GIOCondition = 16;
pub const GIOCondition_G_IO_NVAL: GIOCondition = 32;
pub type GIOCondition = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMainContext {
    _unused: [u8; 0],
}
#[doc = " GMainContext:"]
#[doc = ""]
#[doc = " The `GMainContext` struct is an opaque data"]
#[doc = " type representing a set of sources to be handled in a main loop."]
pub type GMainContext = _GMainContext;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMainLoop {
    _unused: [u8; 0],
}
#[doc = " GMainLoop:"]
#[doc = ""]
#[doc = " The `GMainLoop` struct is an opaque data type"]
#[doc = " representing the main event loop of a GLib or GTK+ application."]
pub type GMainLoop = _GMainLoop;
#[doc = " GSource:"]
#[doc = ""]
#[doc = " The `GSource` struct is an opaque data type"]
#[doc = " representing an event source."]
pub type GSource = _GSource;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSourcePrivate {
    _unused: [u8; 0],
}
pub type GSourcePrivate = _GSourcePrivate;
#[doc = " GSourceCallbackFuncs:"]
#[doc = " @ref: Called when a reference is added to the callback object"]
#[doc = " @unref: Called when a reference to the callback object is dropped"]
#[doc = " @get: Called to extract the callback function and data from the"]
#[doc = "     callback object."]
#[doc = ""]
#[doc = " The `GSourceCallbackFuncs` struct contains"]
#[doc = " functions for managing callback objects."]
pub type GSourceCallbackFuncs = _GSourceCallbackFuncs;
#[doc = " GSourceFuncs:"]
#[doc = " @prepare: Called before all the file descriptors are polled. If the"]
#[doc = "     source can determine that it is ready here (without waiting for the"]
#[doc = "     results of the poll() call) it should return %TRUE. It can also return"]
#[doc = "     a @timeout_ value which should be the maximum timeout (in milliseconds)"]
#[doc = "     which should be passed to the poll() call. The actual timeout used will"]
#[doc = "     be -1 if all sources returned -1, or it will be the minimum of all"]
#[doc = "     the @timeout_ values returned which were >= 0.  Since 2.36 this may"]
#[doc = "     be %NULL, in which case the effect is as if the function always returns"]
#[doc = "     %FALSE with a timeout of -1.  If @prepare returns a"]
#[doc = "     timeout and the source also has a ready time set, then the"]
#[doc = "     lower of the two will be used."]
#[doc = " @check: Called after all the file descriptors are polled. The source"]
#[doc = "     should return %TRUE if it is ready to be dispatched. Note that some"]
#[doc = "     time may have passed since the previous prepare function was called,"]
#[doc = "     so the source should be checked again here.  Since 2.36 this may"]
#[doc = "     be %NULL, in which case the effect is as if the function always returns"]
#[doc = "     %FALSE."]
#[doc = " @dispatch: Called to dispatch the event source, after it has returned"]
#[doc = "     %TRUE in either its @prepare or its @check function, or if a ready time"]
#[doc = "     has been reached. The @dispatch function receives a callback function and"]
#[doc = "     user data. The callback function may be %NULL if the source was never"]
#[doc = "     connected to a callback using g_source_set_callback(). The @dispatch"]
#[doc = "     function should call the callback function with @user_data and whatever"]
#[doc = "     additional parameters are needed for this type of event source. The"]
#[doc = "     return value of the @dispatch function should be #G_SOURCE_REMOVE if the"]
#[doc = "     source should be removed or #G_SOURCE_CONTINUE to keep it."]
#[doc = " @finalize: Called when the source is finalized. At this point, the source"]
#[doc = "     will have been destroyed, had its callback cleared, and have been removed"]
#[doc = "     from its #GMainContext, but it will still have its final reference count,"]
#[doc = "     so methods can be called on it from within this function."]
#[doc = ""]
#[doc = " The `GSourceFuncs` struct contains a table of"]
#[doc = " functions used to handle event sources in a generic manner."]
#[doc = ""]
#[doc = " For idle sources, the prepare and check functions always return %TRUE"]
#[doc = " to indicate that the source is always ready to be processed. The prepare"]
#[doc = " function also returns a timeout value of 0 to ensure that the poll() call"]
#[doc = " doesn't block (since that would be time wasted which could have been spent"]
#[doc = " running the idle function)."]
#[doc = ""]
#[doc = " For timeout sources, the prepare and check functions both return %TRUE"]
#[doc = " if the timeout interval has expired. The prepare function also returns"]
#[doc = " a timeout value to ensure that the poll() call doesn't block too long"]
#[doc = " and miss the next timeout."]
#[doc = ""]
#[doc = " For file descriptor sources, the prepare function typically returns %FALSE,"]
#[doc = " since it must wait until poll() has been called before it knows whether"]
#[doc = " any events need to be processed. It sets the returned timeout to -1 to"]
#[doc = " indicate that it doesn't mind how long the poll() call blocks. In the"]
#[doc = " check function, it tests the results of the poll() call to see if the"]
#[doc = " required condition has been met, and returns %TRUE if so."]
pub type GSourceFuncs = _GSourceFuncs;
#[doc = " GSourceFunc:"]
#[doc = " @user_data: data passed to the function, set when the source was"]
#[doc = "     created with one of the above functions"]
#[doc = ""]
#[doc = " Specifies the type of function passed to g_timeout_add(),"]
#[doc = " g_timeout_add_full(), g_idle_add(), and g_idle_add_full()."]
#[doc = ""]
#[doc = " When calling g_source_set_callback(), you may need to cast a function of a"]
#[doc = " different type to this type. Use G_SOURCE_FUNC() to avoid warnings about"]
#[doc = " incompatible function types."]
#[doc = ""]
#[doc = " Returns: %FALSE if the source should be removed. #G_SOURCE_CONTINUE and"]
#[doc = " #G_SOURCE_REMOVE are more memorable names for the return value."]
pub type GSourceFunc = ::std::option::Option<unsafe extern "C" fn(user_data: gpointer) -> gboolean>;
#[doc = " GChildWatchFunc:"]
#[doc = " @pid: the process id of the child process"]
#[doc = " @status: Status information about the child process, encoded"]
#[doc = "     in a platform-specific manner"]
#[doc = " @user_data: user data passed to g_child_watch_add()"]
#[doc = ""]
#[doc = " Prototype of a #GChildWatchSource callback, called when a child"]
#[doc = " process has exited.  To interpret @status, see the documentation"]
#[doc = " for g_spawn_check_exit_status()."]
pub type GChildWatchFunc =
    ::std::option::Option<unsafe extern "C" fn(pid: GPid, status: gint, user_data: gpointer)>;
#[doc = " GSourceDisposeFunc:"]
#[doc = " @source: #GSource that is currently being disposed"]
#[doc = ""]
#[doc = " Dispose function for @source. See g_source_set_dispose_function() for"]
#[doc = " details."]
#[doc = ""]
#[doc = " Since: 2.64"]
pub type GSourceDisposeFunc = ::std::option::Option<unsafe extern "C" fn(source: *mut GSource)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSource {
    pub callback_data: gpointer,
    pub callback_funcs: *mut GSourceCallbackFuncs,
    pub source_funcs: *const GSourceFuncs,
    pub ref_count: guint,
    pub context: *mut GMainContext,
    pub priority: gint,
    pub flags: guint,
    pub source_id: guint,
    pub poll_fds: *mut GSList,
    pub prev: *mut GSource,
    pub next: *mut GSource,
    pub name: *mut ::std::os::raw::c_char,
    pub priv_: *mut GSourcePrivate,
}
#[test]
fn bindgen_test_layout__GSource() {
    assert_eq!(
        ::std::mem::size_of::<_GSource>(),
        96usize,
        concat!("Size of: ", stringify!(_GSource))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSource>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSource))
    );
    fn test_field_callback_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GSource>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).callback_data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GSource),
                "::",
                stringify!(callback_data)
            )
        );
    }
    test_field_callback_data();
    fn test_field_callback_funcs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GSource>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).callback_funcs) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_GSource),
                "::",
                stringify!(callback_funcs)
            )
        );
    }
    test_field_callback_funcs();
    fn test_field_source_funcs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GSource>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).source_funcs) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_GSource),
                "::",
                stringify!(source_funcs)
            )
        );
    }
    test_field_source_funcs();
    fn test_field_ref_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GSource>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ref_count) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_GSource),
                "::",
                stringify!(ref_count)
            )
        );
    }
    test_field_ref_count();
    fn test_field_context() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GSource>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).context) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_GSource),
                "::",
                stringify!(context)
            )
        );
    }
    test_field_context();
    fn test_field_priority() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GSource>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).priority) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_GSource),
                "::",
                stringify!(priority)
            )
        );
    }
    test_field_priority();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GSource>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(_GSource),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_source_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GSource>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).source_id) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_GSource),
                "::",
                stringify!(source_id)
            )
        );
    }
    test_field_source_id();
    fn test_field_poll_fds() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GSource>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).poll_fds) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_GSource),
                "::",
                stringify!(poll_fds)
            )
        );
    }
    test_field_poll_fds();
    fn test_field_prev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GSource>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_GSource),
                "::",
                stringify!(prev)
            )
        );
    }
    test_field_prev();
    fn test_field_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GSource>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_GSource),
                "::",
                stringify!(next)
            )
        );
    }
    test_field_next();
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GSource>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_GSource),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_priv() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GSource>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_GSource),
                "::",
                stringify!(priv_)
            )
        );
    }
    test_field_priv();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSourceCallbackFuncs {
    pub ref_: ::std::option::Option<unsafe extern "C" fn(cb_data: gpointer)>,
    pub unref: ::std::option::Option<unsafe extern "C" fn(cb_data: gpointer)>,
    pub get: ::std::option::Option<
        unsafe extern "C" fn(
            cb_data: gpointer,
            source: *mut GSource,
            func: *mut GSourceFunc,
            data: *mut gpointer,
        ),
    >,
}
#[test]
fn bindgen_test_layout__GSourceCallbackFuncs() {
    assert_eq!(
        ::std::mem::size_of::<_GSourceCallbackFuncs>(),
        24usize,
        concat!("Size of: ", stringify!(_GSourceCallbackFuncs))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSourceCallbackFuncs>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSourceCallbackFuncs))
    );
    fn test_field_ref() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GSourceCallbackFuncs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ref_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GSourceCallbackFuncs),
                "::",
                stringify!(ref_)
            )
        );
    }
    test_field_ref();
    fn test_field_unref() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GSourceCallbackFuncs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unref) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_GSourceCallbackFuncs),
                "::",
                stringify!(unref)
            )
        );
    }
    test_field_unref();
    fn test_field_get() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GSourceCallbackFuncs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_GSourceCallbackFuncs),
                "::",
                stringify!(get)
            )
        );
    }
    test_field_get();
}
#[doc = " GSourceDummyMarshal:"]
#[doc = ""]
#[doc = " This is just a placeholder for #GClosureMarshal,"]
#[doc = " which cannot be used here for dependency reasons."]
pub type GSourceDummyMarshal = ::std::option::Option<unsafe extern "C" fn()>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSourceFuncs {
    pub prepare: ::std::option::Option<
        unsafe extern "C" fn(source: *mut GSource, timeout_: *mut gint) -> gboolean,
    >,
    pub check: ::std::option::Option<unsafe extern "C" fn(source: *mut GSource) -> gboolean>,
    pub dispatch: ::std::option::Option<
        unsafe extern "C" fn(
            source: *mut GSource,
            callback: GSourceFunc,
            user_data: gpointer,
        ) -> gboolean,
    >,
    pub finalize: ::std::option::Option<unsafe extern "C" fn(source: *mut GSource)>,
    pub closure_callback: GSourceFunc,
    pub closure_marshal: GSourceDummyMarshal,
}
#[test]
fn bindgen_test_layout__GSourceFuncs() {
    assert_eq!(
        ::std::mem::size_of::<_GSourceFuncs>(),
        48usize,
        concat!("Size of: ", stringify!(_GSourceFuncs))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSourceFuncs>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSourceFuncs))
    );
    fn test_field_prepare() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GSourceFuncs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).prepare) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GSourceFuncs),
                "::",
                stringify!(prepare)
            )
        );
    }
    test_field_prepare();
    fn test_field_check() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GSourceFuncs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).check) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_GSourceFuncs),
                "::",
                stringify!(check)
            )
        );
    }
    test_field_check();
    fn test_field_dispatch() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GSourceFuncs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dispatch) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_GSourceFuncs),
                "::",
                stringify!(dispatch)
            )
        );
    }
    test_field_dispatch();
    fn test_field_finalize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GSourceFuncs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).finalize) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_GSourceFuncs),
                "::",
                stringify!(finalize)
            )
        );
    }
    test_field_finalize();
    fn test_field_closure_callback() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GSourceFuncs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).closure_callback) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_GSourceFuncs),
                "::",
                stringify!(closure_callback)
            )
        );
    }
    test_field_closure_callback();
    fn test_field_closure_marshal() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GSourceFuncs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).closure_marshal) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_GSourceFuncs),
                "::",
                stringify!(closure_marshal)
            )
        );
    }
    test_field_closure_marshal();
}
extern "C" {
    pub fn g_main_context_new() -> *mut GMainContext;
}
extern "C" {
    pub fn g_main_context_ref(context: *mut GMainContext) -> *mut GMainContext;
}
extern "C" {
    pub fn g_main_context_unref(context: *mut GMainContext);
}
extern "C" {
    pub fn g_main_context_default() -> *mut GMainContext;
}
extern "C" {
    pub fn g_main_context_iteration(context: *mut GMainContext, may_block: gboolean) -> gboolean;
}
extern "C" {
    pub fn g_main_context_pending(context: *mut GMainContext) -> gboolean;
}
extern "C" {
    pub fn g_main_context_find_source_by_id(
        context: *mut GMainContext,
        source_id: guint,
    ) -> *mut GSource;
}
extern "C" {
    pub fn g_main_context_find_source_by_user_data(
        context: *mut GMainContext,
        user_data: gpointer,
    ) -> *mut GSource;
}
extern "C" {
    pub fn g_main_context_find_source_by_funcs_user_data(
        context: *mut GMainContext,
        funcs: *mut GSourceFuncs,
        user_data: gpointer,
    ) -> *mut GSource;
}
extern "C" {
    pub fn g_main_context_wakeup(context: *mut GMainContext);
}
extern "C" {
    pub fn g_main_context_acquire(context: *mut GMainContext) -> gboolean;
}
extern "C" {
    pub fn g_main_context_release(context: *mut GMainContext);
}
extern "C" {
    pub fn g_main_context_is_owner(context: *mut GMainContext) -> gboolean;
}
extern "C" {
    pub fn g_main_context_wait(
        context: *mut GMainContext,
        cond: *mut GCond,
        mutex: *mut GMutex,
    ) -> gboolean;
}
extern "C" {
    pub fn g_main_context_prepare(context: *mut GMainContext, priority: *mut gint) -> gboolean;
}
extern "C" {
    pub fn g_main_context_query(
        context: *mut GMainContext,
        max_priority: gint,
        timeout_: *mut gint,
        fds: *mut GPollFD,
        n_fds: gint,
    ) -> gint;
}
extern "C" {
    pub fn g_main_context_check(
        context: *mut GMainContext,
        max_priority: gint,
        fds: *mut GPollFD,
        n_fds: gint,
    ) -> gboolean;
}
extern "C" {
    pub fn g_main_context_dispatch(context: *mut GMainContext);
}
extern "C" {
    pub fn g_main_context_set_poll_func(context: *mut GMainContext, func: GPollFunc);
}
extern "C" {
    pub fn g_main_context_get_poll_func(context: *mut GMainContext) -> GPollFunc;
}
extern "C" {
    pub fn g_main_context_add_poll(context: *mut GMainContext, fd: *mut GPollFD, priority: gint);
}
extern "C" {
    pub fn g_main_context_remove_poll(context: *mut GMainContext, fd: *mut GPollFD);
}
extern "C" {
    pub fn g_main_depth() -> gint;
}
extern "C" {
    pub fn g_main_current_source() -> *mut GSource;
}
extern "C" {
    pub fn g_main_context_push_thread_default(context: *mut GMainContext);
}
extern "C" {
    pub fn g_main_context_pop_thread_default(context: *mut GMainContext);
}
extern "C" {
    pub fn g_main_context_get_thread_default() -> *mut GMainContext;
}
extern "C" {
    pub fn g_main_context_ref_thread_default() -> *mut GMainContext;
}
#[doc = " GMainContextPusher:"]
#[doc = ""]
#[doc = " Opaque type. See g_main_context_pusher_new() for details."]
#[doc = ""]
#[doc = " Since: 2.64"]
pub type GMainContextPusher = ::std::os::raw::c_void;
extern "C" {
    pub fn g_main_loop_new(context: *mut GMainContext, is_running: gboolean) -> *mut GMainLoop;
}
extern "C" {
    pub fn g_main_loop_run(loop_: *mut GMainLoop);
}
extern "C" {
    pub fn g_main_loop_quit(loop_: *mut GMainLoop);
}
extern "C" {
    pub fn g_main_loop_ref(loop_: *mut GMainLoop) -> *mut GMainLoop;
}
extern "C" {
    pub fn g_main_loop_unref(loop_: *mut GMainLoop);
}
extern "C" {
    pub fn g_main_loop_is_running(loop_: *mut GMainLoop) -> gboolean;
}
extern "C" {
    pub fn g_main_loop_get_context(loop_: *mut GMainLoop) -> *mut GMainContext;
}
extern "C" {
    pub fn g_source_new(source_funcs: *mut GSourceFuncs, struct_size: guint) -> *mut GSource;
}
extern "C" {
    pub fn g_source_set_dispose_function(source: *mut GSource, dispose: GSourceDisposeFunc);
}
extern "C" {
    pub fn g_source_ref(source: *mut GSource) -> *mut GSource;
}
extern "C" {
    pub fn g_source_unref(source: *mut GSource);
}
extern "C" {
    pub fn g_source_attach(source: *mut GSource, context: *mut GMainContext) -> guint;
}
extern "C" {
    pub fn g_source_destroy(source: *mut GSource);
}
extern "C" {
    pub fn g_source_set_priority(source: *mut GSource, priority: gint);
}
extern "C" {
    pub fn g_source_get_priority(source: *mut GSource) -> gint;
}
extern "C" {
    pub fn g_source_set_can_recurse(source: *mut GSource, can_recurse: gboolean);
}
extern "C" {
    pub fn g_source_get_can_recurse(source: *mut GSource) -> gboolean;
}
extern "C" {
    pub fn g_source_get_id(source: *mut GSource) -> guint;
}
extern "C" {
    pub fn g_source_get_context(source: *mut GSource) -> *mut GMainContext;
}
extern "C" {
    pub fn g_source_set_callback(
        source: *mut GSource,
        func: GSourceFunc,
        data: gpointer,
        notify: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_source_set_funcs(source: *mut GSource, funcs: *mut GSourceFuncs);
}
extern "C" {
    pub fn g_source_is_destroyed(source: *mut GSource) -> gboolean;
}
extern "C" {
    pub fn g_source_set_name(source: *mut GSource, name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn g_source_get_name(source: *mut GSource) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_source_set_name_by_id(tag: guint, name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn g_source_set_ready_time(source: *mut GSource, ready_time: gint64);
}
extern "C" {
    pub fn g_source_get_ready_time(source: *mut GSource) -> gint64;
}
extern "C" {
    pub fn g_source_add_unix_fd(source: *mut GSource, fd: gint, events: GIOCondition) -> gpointer;
}
extern "C" {
    pub fn g_source_modify_unix_fd(source: *mut GSource, tag: gpointer, new_events: GIOCondition);
}
extern "C" {
    pub fn g_source_remove_unix_fd(source: *mut GSource, tag: gpointer);
}
extern "C" {
    pub fn g_source_query_unix_fd(source: *mut GSource, tag: gpointer) -> GIOCondition;
}
extern "C" {
    pub fn g_source_set_callback_indirect(
        source: *mut GSource,
        callback_data: gpointer,
        callback_funcs: *mut GSourceCallbackFuncs,
    );
}
extern "C" {
    pub fn g_source_add_poll(source: *mut GSource, fd: *mut GPollFD);
}
extern "C" {
    pub fn g_source_remove_poll(source: *mut GSource, fd: *mut GPollFD);
}
extern "C" {
    pub fn g_source_add_child_source(source: *mut GSource, child_source: *mut GSource);
}
extern "C" {
    pub fn g_source_remove_child_source(source: *mut GSource, child_source: *mut GSource);
}
extern "C" {
    pub fn g_source_get_current_time(source: *mut GSource, timeval: *mut GTimeVal);
}
extern "C" {
    pub fn g_source_get_time(source: *mut GSource) -> gint64;
}
extern "C" {
    pub fn g_idle_source_new() -> *mut GSource;
}
extern "C" {
    pub fn g_child_watch_source_new(pid: GPid) -> *mut GSource;
}
extern "C" {
    pub fn g_timeout_source_new(interval: guint) -> *mut GSource;
}
extern "C" {
    pub fn g_timeout_source_new_seconds(interval: guint) -> *mut GSource;
}
extern "C" {
    pub fn g_get_current_time(result: *mut GTimeVal);
}
extern "C" {
    pub fn g_get_monotonic_time() -> gint64;
}
extern "C" {
    pub fn g_get_real_time() -> gint64;
}
extern "C" {
    pub fn g_source_remove(tag: guint) -> gboolean;
}
extern "C" {
    pub fn g_source_remove_by_user_data(user_data: gpointer) -> gboolean;
}
extern "C" {
    pub fn g_source_remove_by_funcs_user_data(
        funcs: *mut GSourceFuncs,
        user_data: gpointer,
    ) -> gboolean;
}
#[doc = " GClearHandleFunc:"]
#[doc = " @handle_id: the handle ID to clear"]
#[doc = ""]
#[doc = " Specifies the type of function passed to g_clear_handle_id()."]
#[doc = " The implementation is expected to free the resource identified"]
#[doc = " by @handle_id; for instance, if @handle_id is a #GSource ID,"]
#[doc = " g_source_remove() can be used."]
#[doc = ""]
#[doc = " Since: 2.56"]
pub type GClearHandleFunc = ::std::option::Option<unsafe extern "C" fn(handle_id: guint)>;
extern "C" {
    pub fn g_clear_handle_id(tag_ptr: *mut guint, clear_func: GClearHandleFunc);
}
extern "C" {
    pub fn g_timeout_add_full(
        priority: gint,
        interval: guint,
        function: GSourceFunc,
        data: gpointer,
        notify: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    pub fn g_timeout_add(interval: guint, function: GSourceFunc, data: gpointer) -> guint;
}
extern "C" {
    pub fn g_timeout_add_seconds_full(
        priority: gint,
        interval: guint,
        function: GSourceFunc,
        data: gpointer,
        notify: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    pub fn g_timeout_add_seconds(interval: guint, function: GSourceFunc, data: gpointer) -> guint;
}
extern "C" {
    pub fn g_child_watch_add_full(
        priority: gint,
        pid: GPid,
        function: GChildWatchFunc,
        data: gpointer,
        notify: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    pub fn g_child_watch_add(pid: GPid, function: GChildWatchFunc, data: gpointer) -> guint;
}
extern "C" {
    pub fn g_idle_add(function: GSourceFunc, data: gpointer) -> guint;
}
extern "C" {
    pub fn g_idle_add_full(
        priority: gint,
        function: GSourceFunc,
        data: gpointer,
        notify: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    pub fn g_idle_remove_by_data(data: gpointer) -> gboolean;
}
extern "C" {
    pub fn g_main_context_invoke_full(
        context: *mut GMainContext,
        priority: gint,
        function: GSourceFunc,
        data: gpointer,
        notify: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_main_context_invoke(context: *mut GMainContext, function: GSourceFunc, data: gpointer);
}
extern "C" {
    pub static mut g_timeout_funcs: GSourceFuncs;
}
extern "C" {
    pub static mut g_child_watch_funcs: GSourceFuncs;
}
extern "C" {
    pub static mut g_idle_funcs: GSourceFuncs;
}
extern "C" {
    pub static mut g_unix_signal_funcs: GSourceFuncs;
}
extern "C" {
    pub static mut g_unix_fd_source_funcs: GSourceFuncs;
}
#[doc = " gunichar:"]
#[doc = ""]
#[doc = " A type which can hold any UTF-32 or UCS-4 character code,"]
#[doc = " also known as a Unicode code point."]
#[doc = ""]
#[doc = " If you want to produce the UTF-8 representation of a #gunichar,"]
#[doc = " use g_ucs4_to_utf8(). See also g_utf8_to_ucs4() for the reverse"]
#[doc = " process."]
#[doc = ""]
#[doc = " To print/scan values of this type as integer, use"]
#[doc = " %G_GINT32_MODIFIER and/or %G_GUINT32_FORMAT."]
#[doc = ""]
#[doc = " The notation to express a Unicode code point in running text is"]
#[doc = " as a hexadecimal number with four to six digits and uppercase"]
#[doc = " letters, prefixed by the string \"U+\". Leading zeros are omitted,"]
#[doc = " unless the code point would have fewer than four hexadecimal digits."]
#[doc = " For example, \"U+0041 LATIN CAPITAL LETTER A\". To print a code point"]
#[doc = " in the U+-notation, use the format string \"U+\\%04\"G_GINT32_FORMAT\"X\"."]
#[doc = " To scan, use the format string \"U+\\%06\"G_GINT32_FORMAT\"X\"."]
#[doc = ""]
#[doc = " |["]
#[doc = " gunichar c;"]
#[doc = " sscanf (\"U+0041\", \"U+%06\"G_GINT32_FORMAT\"X\", &amp;c)"]
#[doc = " g_print (\"Read U+%04\"G_GINT32_FORMAT\"X\", c);"]
#[doc = " ]|"]
pub type gunichar = guint32;
#[doc = " gunichar2:"]
#[doc = ""]
#[doc = " A type which can hold any UTF-16 code"]
#[doc = " point<footnote id=\"utf16_surrogate_pairs\">UTF-16 also has so called"]
#[doc = " <firstterm>surrogate pairs</firstterm> to encode characters beyond"]
#[doc = " the BMP as pairs of 16bit numbers. Surrogate pairs cannot be stored"]
#[doc = " in a single gunichar2 field, but all GLib functions accepting gunichar2"]
#[doc = " arrays will correctly interpret surrogate pairs.</footnote>."]
#[doc = ""]
#[doc = " To print/scan values of this type to/from text you need to convert"]
#[doc = " to/from UTF-8, using g_utf16_to_utf8()/g_utf8_to_utf16()."]
#[doc = ""]
#[doc = " To print/scan values of this type as integer, use"]
#[doc = " %G_GINT16_MODIFIER and/or %G_GUINT16_FORMAT."]
pub type gunichar2 = guint16;
pub const GUnicodeType_G_UNICODE_CONTROL: GUnicodeType = 0;
pub const GUnicodeType_G_UNICODE_FORMAT: GUnicodeType = 1;
pub const GUnicodeType_G_UNICODE_UNASSIGNED: GUnicodeType = 2;
pub const GUnicodeType_G_UNICODE_PRIVATE_USE: GUnicodeType = 3;
pub const GUnicodeType_G_UNICODE_SURROGATE: GUnicodeType = 4;
pub const GUnicodeType_G_UNICODE_LOWERCASE_LETTER: GUnicodeType = 5;
pub const GUnicodeType_G_UNICODE_MODIFIER_LETTER: GUnicodeType = 6;
pub const GUnicodeType_G_UNICODE_OTHER_LETTER: GUnicodeType = 7;
pub const GUnicodeType_G_UNICODE_TITLECASE_LETTER: GUnicodeType = 8;
pub const GUnicodeType_G_UNICODE_UPPERCASE_LETTER: GUnicodeType = 9;
pub const GUnicodeType_G_UNICODE_SPACING_MARK: GUnicodeType = 10;
pub const GUnicodeType_G_UNICODE_ENCLOSING_MARK: GUnicodeType = 11;
pub const GUnicodeType_G_UNICODE_NON_SPACING_MARK: GUnicodeType = 12;
pub const GUnicodeType_G_UNICODE_DECIMAL_NUMBER: GUnicodeType = 13;
pub const GUnicodeType_G_UNICODE_LETTER_NUMBER: GUnicodeType = 14;
pub const GUnicodeType_G_UNICODE_OTHER_NUMBER: GUnicodeType = 15;
pub const GUnicodeType_G_UNICODE_CONNECT_PUNCTUATION: GUnicodeType = 16;
pub const GUnicodeType_G_UNICODE_DASH_PUNCTUATION: GUnicodeType = 17;
pub const GUnicodeType_G_UNICODE_CLOSE_PUNCTUATION: GUnicodeType = 18;
pub const GUnicodeType_G_UNICODE_FINAL_PUNCTUATION: GUnicodeType = 19;
pub const GUnicodeType_G_UNICODE_INITIAL_PUNCTUATION: GUnicodeType = 20;
pub const GUnicodeType_G_UNICODE_OTHER_PUNCTUATION: GUnicodeType = 21;
pub const GUnicodeType_G_UNICODE_OPEN_PUNCTUATION: GUnicodeType = 22;
pub const GUnicodeType_G_UNICODE_CURRENCY_SYMBOL: GUnicodeType = 23;
pub const GUnicodeType_G_UNICODE_MODIFIER_SYMBOL: GUnicodeType = 24;
pub const GUnicodeType_G_UNICODE_MATH_SYMBOL: GUnicodeType = 25;
pub const GUnicodeType_G_UNICODE_OTHER_SYMBOL: GUnicodeType = 26;
pub const GUnicodeType_G_UNICODE_LINE_SEPARATOR: GUnicodeType = 27;
pub const GUnicodeType_G_UNICODE_PARAGRAPH_SEPARATOR: GUnicodeType = 28;
pub const GUnicodeType_G_UNICODE_SPACE_SEPARATOR: GUnicodeType = 29;
#[doc = " GUnicodeType:"]
#[doc = " @G_UNICODE_CONTROL: General category \"Other, Control\" (Cc)"]
#[doc = " @G_UNICODE_FORMAT: General category \"Other, Format\" (Cf)"]
#[doc = " @G_UNICODE_UNASSIGNED: General category \"Other, Not Assigned\" (Cn)"]
#[doc = " @G_UNICODE_PRIVATE_USE: General category \"Other, Private Use\" (Co)"]
#[doc = " @G_UNICODE_SURROGATE: General category \"Other, Surrogate\" (Cs)"]
#[doc = " @G_UNICODE_LOWERCASE_LETTER: General category \"Letter, Lowercase\" (Ll)"]
#[doc = " @G_UNICODE_MODIFIER_LETTER: General category \"Letter, Modifier\" (Lm)"]
#[doc = " @G_UNICODE_OTHER_LETTER: General category \"Letter, Other\" (Lo)"]
#[doc = " @G_UNICODE_TITLECASE_LETTER: General category \"Letter, Titlecase\" (Lt)"]
#[doc = " @G_UNICODE_UPPERCASE_LETTER: General category \"Letter, Uppercase\" (Lu)"]
#[doc = " @G_UNICODE_SPACING_MARK: General category \"Mark, Spacing\" (Mc)"]
#[doc = " @G_UNICODE_ENCLOSING_MARK: General category \"Mark, Enclosing\" (Me)"]
#[doc = " @G_UNICODE_NON_SPACING_MARK: General category \"Mark, Nonspacing\" (Mn)"]
#[doc = " @G_UNICODE_DECIMAL_NUMBER: General category \"Number, Decimal Digit\" (Nd)"]
#[doc = " @G_UNICODE_LETTER_NUMBER: General category \"Number, Letter\" (Nl)"]
#[doc = " @G_UNICODE_OTHER_NUMBER: General category \"Number, Other\" (No)"]
#[doc = " @G_UNICODE_CONNECT_PUNCTUATION: General category \"Punctuation, Connector\" (Pc)"]
#[doc = " @G_UNICODE_DASH_PUNCTUATION: General category \"Punctuation, Dash\" (Pd)"]
#[doc = " @G_UNICODE_CLOSE_PUNCTUATION: General category \"Punctuation, Close\" (Pe)"]
#[doc = " @G_UNICODE_FINAL_PUNCTUATION: General category \"Punctuation, Final quote\" (Pf)"]
#[doc = " @G_UNICODE_INITIAL_PUNCTUATION: General category \"Punctuation, Initial quote\" (Pi)"]
#[doc = " @G_UNICODE_OTHER_PUNCTUATION: General category \"Punctuation, Other\" (Po)"]
#[doc = " @G_UNICODE_OPEN_PUNCTUATION: General category \"Punctuation, Open\" (Ps)"]
#[doc = " @G_UNICODE_CURRENCY_SYMBOL: General category \"Symbol, Currency\" (Sc)"]
#[doc = " @G_UNICODE_MODIFIER_SYMBOL: General category \"Symbol, Modifier\" (Sk)"]
#[doc = " @G_UNICODE_MATH_SYMBOL: General category \"Symbol, Math\" (Sm)"]
#[doc = " @G_UNICODE_OTHER_SYMBOL: General category \"Symbol, Other\" (So)"]
#[doc = " @G_UNICODE_LINE_SEPARATOR: General category \"Separator, Line\" (Zl)"]
#[doc = " @G_UNICODE_PARAGRAPH_SEPARATOR: General category \"Separator, Paragraph\" (Zp)"]
#[doc = " @G_UNICODE_SPACE_SEPARATOR: General category \"Separator, Space\" (Zs)"]
#[doc = ""]
#[doc = " These are the possible character classifications from the"]
#[doc = " Unicode specification."]
#[doc = " See [Unicode Character Database](http://www.unicode.org/reports/tr44/#General_Category_Values)."]
pub type GUnicodeType = ::std::os::raw::c_uint;
pub const GUnicodeBreakType_G_UNICODE_BREAK_MANDATORY: GUnicodeBreakType = 0;
pub const GUnicodeBreakType_G_UNICODE_BREAK_CARRIAGE_RETURN: GUnicodeBreakType = 1;
pub const GUnicodeBreakType_G_UNICODE_BREAK_LINE_FEED: GUnicodeBreakType = 2;
pub const GUnicodeBreakType_G_UNICODE_BREAK_COMBINING_MARK: GUnicodeBreakType = 3;
pub const GUnicodeBreakType_G_UNICODE_BREAK_SURROGATE: GUnicodeBreakType = 4;
pub const GUnicodeBreakType_G_UNICODE_BREAK_ZERO_WIDTH_SPACE: GUnicodeBreakType = 5;
pub const GUnicodeBreakType_G_UNICODE_BREAK_INSEPARABLE: GUnicodeBreakType = 6;
pub const GUnicodeBreakType_G_UNICODE_BREAK_NON_BREAKING_GLUE: GUnicodeBreakType = 7;
pub const GUnicodeBreakType_G_UNICODE_BREAK_CONTINGENT: GUnicodeBreakType = 8;
pub const GUnicodeBreakType_G_UNICODE_BREAK_SPACE: GUnicodeBreakType = 9;
pub const GUnicodeBreakType_G_UNICODE_BREAK_AFTER: GUnicodeBreakType = 10;
pub const GUnicodeBreakType_G_UNICODE_BREAK_BEFORE: GUnicodeBreakType = 11;
pub const GUnicodeBreakType_G_UNICODE_BREAK_BEFORE_AND_AFTER: GUnicodeBreakType = 12;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HYPHEN: GUnicodeBreakType = 13;
pub const GUnicodeBreakType_G_UNICODE_BREAK_NON_STARTER: GUnicodeBreakType = 14;
pub const GUnicodeBreakType_G_UNICODE_BREAK_OPEN_PUNCTUATION: GUnicodeBreakType = 15;
pub const GUnicodeBreakType_G_UNICODE_BREAK_CLOSE_PUNCTUATION: GUnicodeBreakType = 16;
pub const GUnicodeBreakType_G_UNICODE_BREAK_QUOTATION: GUnicodeBreakType = 17;
pub const GUnicodeBreakType_G_UNICODE_BREAK_EXCLAMATION: GUnicodeBreakType = 18;
pub const GUnicodeBreakType_G_UNICODE_BREAK_IDEOGRAPHIC: GUnicodeBreakType = 19;
pub const GUnicodeBreakType_G_UNICODE_BREAK_NUMERIC: GUnicodeBreakType = 20;
pub const GUnicodeBreakType_G_UNICODE_BREAK_INFIX_SEPARATOR: GUnicodeBreakType = 21;
pub const GUnicodeBreakType_G_UNICODE_BREAK_SYMBOL: GUnicodeBreakType = 22;
pub const GUnicodeBreakType_G_UNICODE_BREAK_ALPHABETIC: GUnicodeBreakType = 23;
pub const GUnicodeBreakType_G_UNICODE_BREAK_PREFIX: GUnicodeBreakType = 24;
pub const GUnicodeBreakType_G_UNICODE_BREAK_POSTFIX: GUnicodeBreakType = 25;
pub const GUnicodeBreakType_G_UNICODE_BREAK_COMPLEX_CONTEXT: GUnicodeBreakType = 26;
pub const GUnicodeBreakType_G_UNICODE_BREAK_AMBIGUOUS: GUnicodeBreakType = 27;
pub const GUnicodeBreakType_G_UNICODE_BREAK_UNKNOWN: GUnicodeBreakType = 28;
pub const GUnicodeBreakType_G_UNICODE_BREAK_NEXT_LINE: GUnicodeBreakType = 29;
pub const GUnicodeBreakType_G_UNICODE_BREAK_WORD_JOINER: GUnicodeBreakType = 30;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HANGUL_L_JAMO: GUnicodeBreakType = 31;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HANGUL_V_JAMO: GUnicodeBreakType = 32;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HANGUL_T_JAMO: GUnicodeBreakType = 33;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HANGUL_LV_SYLLABLE: GUnicodeBreakType = 34;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE: GUnicodeBreakType = 35;
pub const GUnicodeBreakType_G_UNICODE_BREAK_CLOSE_PARANTHESIS: GUnicodeBreakType = 36;
pub const GUnicodeBreakType_G_UNICODE_BREAK_CONDITIONAL_JAPANESE_STARTER: GUnicodeBreakType = 37;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HEBREW_LETTER: GUnicodeBreakType = 38;
pub const GUnicodeBreakType_G_UNICODE_BREAK_REGIONAL_INDICATOR: GUnicodeBreakType = 39;
pub const GUnicodeBreakType_G_UNICODE_BREAK_EMOJI_BASE: GUnicodeBreakType = 40;
pub const GUnicodeBreakType_G_UNICODE_BREAK_EMOJI_MODIFIER: GUnicodeBreakType = 41;
pub const GUnicodeBreakType_G_UNICODE_BREAK_ZERO_WIDTH_JOINER: GUnicodeBreakType = 42;
#[doc = " GUnicodeBreakType:"]
#[doc = " @G_UNICODE_BREAK_MANDATORY: Mandatory Break (BK)"]
#[doc = " @G_UNICODE_BREAK_CARRIAGE_RETURN: Carriage Return (CR)"]
#[doc = " @G_UNICODE_BREAK_LINE_FEED: Line Feed (LF)"]
#[doc = " @G_UNICODE_BREAK_COMBINING_MARK: Attached Characters and Combining Marks (CM)"]
#[doc = " @G_UNICODE_BREAK_SURROGATE: Surrogates (SG)"]
#[doc = " @G_UNICODE_BREAK_ZERO_WIDTH_SPACE: Zero Width Space (ZW)"]
#[doc = " @G_UNICODE_BREAK_INSEPARABLE: Inseparable (IN)"]
#[doc = " @G_UNICODE_BREAK_NON_BREAKING_GLUE: Non-breaking (\"Glue\") (GL)"]
#[doc = " @G_UNICODE_BREAK_CONTINGENT: Contingent Break Opportunity (CB)"]
#[doc = " @G_UNICODE_BREAK_SPACE: Space (SP)"]
#[doc = " @G_UNICODE_BREAK_AFTER: Break Opportunity After (BA)"]
#[doc = " @G_UNICODE_BREAK_BEFORE: Break Opportunity Before (BB)"]
#[doc = " @G_UNICODE_BREAK_BEFORE_AND_AFTER: Break Opportunity Before and After (B2)"]
#[doc = " @G_UNICODE_BREAK_HYPHEN: Hyphen (HY)"]
#[doc = " @G_UNICODE_BREAK_NON_STARTER: Nonstarter (NS)"]
#[doc = " @G_UNICODE_BREAK_OPEN_PUNCTUATION: Opening Punctuation (OP)"]
#[doc = " @G_UNICODE_BREAK_CLOSE_PUNCTUATION: Closing Punctuation (CL)"]
#[doc = " @G_UNICODE_BREAK_QUOTATION: Ambiguous Quotation (QU)"]
#[doc = " @G_UNICODE_BREAK_EXCLAMATION: Exclamation/Interrogation (EX)"]
#[doc = " @G_UNICODE_BREAK_IDEOGRAPHIC: Ideographic (ID)"]
#[doc = " @G_UNICODE_BREAK_NUMERIC: Numeric (NU)"]
#[doc = " @G_UNICODE_BREAK_INFIX_SEPARATOR: Infix Separator (Numeric) (IS)"]
#[doc = " @G_UNICODE_BREAK_SYMBOL: Symbols Allowing Break After (SY)"]
#[doc = " @G_UNICODE_BREAK_ALPHABETIC: Ordinary Alphabetic and Symbol Characters (AL)"]
#[doc = " @G_UNICODE_BREAK_PREFIX: Prefix (Numeric) (PR)"]
#[doc = " @G_UNICODE_BREAK_POSTFIX: Postfix (Numeric) (PO)"]
#[doc = " @G_UNICODE_BREAK_COMPLEX_CONTEXT: Complex Content Dependent (South East Asian) (SA)"]
#[doc = " @G_UNICODE_BREAK_AMBIGUOUS: Ambiguous (Alphabetic or Ideographic) (AI)"]
#[doc = " @G_UNICODE_BREAK_UNKNOWN: Unknown (XX)"]
#[doc = " @G_UNICODE_BREAK_NEXT_LINE: Next Line (NL)"]
#[doc = " @G_UNICODE_BREAK_WORD_JOINER: Word Joiner (WJ)"]
#[doc = " @G_UNICODE_BREAK_HANGUL_L_JAMO: Hangul L Jamo (JL)"]
#[doc = " @G_UNICODE_BREAK_HANGUL_V_JAMO: Hangul V Jamo (JV)"]
#[doc = " @G_UNICODE_BREAK_HANGUL_T_JAMO: Hangul T Jamo (JT)"]
#[doc = " @G_UNICODE_BREAK_HANGUL_LV_SYLLABLE: Hangul LV Syllable (H2)"]
#[doc = " @G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE: Hangul LVT Syllable (H3)"]
#[doc = " @G_UNICODE_BREAK_CLOSE_PARANTHESIS: Closing Parenthesis (CP). Since 2.28"]
#[doc = " @G_UNICODE_BREAK_CONDITIONAL_JAPANESE_STARTER: Conditional Japanese Starter (CJ). Since: 2.32"]
#[doc = " @G_UNICODE_BREAK_HEBREW_LETTER: Hebrew Letter (HL). Since: 2.32"]
#[doc = " @G_UNICODE_BREAK_REGIONAL_INDICATOR: Regional Indicator (RI). Since: 2.36"]
#[doc = " @G_UNICODE_BREAK_EMOJI_BASE: Emoji Base (EB). Since: 2.50"]
#[doc = " @G_UNICODE_BREAK_EMOJI_MODIFIER: Emoji Modifier (EM). Since: 2.50"]
#[doc = " @G_UNICODE_BREAK_ZERO_WIDTH_JOINER: Zero Width Joiner (ZWJ). Since: 2.50"]
#[doc = ""]
#[doc = " These are the possible line break classifications."]
#[doc = ""]
#[doc = " Since new unicode versions may add new types here, applications should be ready"]
#[doc = " to handle unknown values. They may be regarded as %G_UNICODE_BREAK_UNKNOWN."]
#[doc = ""]
#[doc = " See [Unicode Line Breaking Algorithm](http://www.unicode.org/unicode/reports/tr14/)."]
pub type GUnicodeBreakType = ::std::os::raw::c_uint;
pub const GUnicodeScript_G_UNICODE_SCRIPT_INVALID_CODE: GUnicodeScript = -1;
pub const GUnicodeScript_G_UNICODE_SCRIPT_COMMON: GUnicodeScript = 0;
pub const GUnicodeScript_G_UNICODE_SCRIPT_INHERITED: GUnicodeScript = 1;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ARABIC: GUnicodeScript = 2;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ARMENIAN: GUnicodeScript = 3;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BENGALI: GUnicodeScript = 4;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BOPOMOFO: GUnicodeScript = 5;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CHEROKEE: GUnicodeScript = 6;
pub const GUnicodeScript_G_UNICODE_SCRIPT_COPTIC: GUnicodeScript = 7;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CYRILLIC: GUnicodeScript = 8;
pub const GUnicodeScript_G_UNICODE_SCRIPT_DESERET: GUnicodeScript = 9;
pub const GUnicodeScript_G_UNICODE_SCRIPT_DEVANAGARI: GUnicodeScript = 10;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ETHIOPIC: GUnicodeScript = 11;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GEORGIAN: GUnicodeScript = 12;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GOTHIC: GUnicodeScript = 13;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GREEK: GUnicodeScript = 14;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GUJARATI: GUnicodeScript = 15;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GURMUKHI: GUnicodeScript = 16;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HAN: GUnicodeScript = 17;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HANGUL: GUnicodeScript = 18;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HEBREW: GUnicodeScript = 19;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HIRAGANA: GUnicodeScript = 20;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KANNADA: GUnicodeScript = 21;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KATAKANA: GUnicodeScript = 22;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KHMER: GUnicodeScript = 23;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LAO: GUnicodeScript = 24;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LATIN: GUnicodeScript = 25;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MALAYALAM: GUnicodeScript = 26;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MONGOLIAN: GUnicodeScript = 27;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MYANMAR: GUnicodeScript = 28;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OGHAM: GUnicodeScript = 29;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_ITALIC: GUnicodeScript = 30;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ORIYA: GUnicodeScript = 31;
pub const GUnicodeScript_G_UNICODE_SCRIPT_RUNIC: GUnicodeScript = 32;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SINHALA: GUnicodeScript = 33;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SYRIAC: GUnicodeScript = 34;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAMIL: GUnicodeScript = 35;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TELUGU: GUnicodeScript = 36;
pub const GUnicodeScript_G_UNICODE_SCRIPT_THAANA: GUnicodeScript = 37;
pub const GUnicodeScript_G_UNICODE_SCRIPT_THAI: GUnicodeScript = 38;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TIBETAN: GUnicodeScript = 39;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CANADIAN_ABORIGINAL: GUnicodeScript = 40;
pub const GUnicodeScript_G_UNICODE_SCRIPT_YI: GUnicodeScript = 41;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAGALOG: GUnicodeScript = 42;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HANUNOO: GUnicodeScript = 43;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BUHID: GUnicodeScript = 44;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAGBANWA: GUnicodeScript = 45;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BRAILLE: GUnicodeScript = 46;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CYPRIOT: GUnicodeScript = 47;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LIMBU: GUnicodeScript = 48;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OSMANYA: GUnicodeScript = 49;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SHAVIAN: GUnicodeScript = 50;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LINEAR_B: GUnicodeScript = 51;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAI_LE: GUnicodeScript = 52;
pub const GUnicodeScript_G_UNICODE_SCRIPT_UGARITIC: GUnicodeScript = 53;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NEW_TAI_LUE: GUnicodeScript = 54;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BUGINESE: GUnicodeScript = 55;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GLAGOLITIC: GUnicodeScript = 56;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TIFINAGH: GUnicodeScript = 57;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SYLOTI_NAGRI: GUnicodeScript = 58;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_PERSIAN: GUnicodeScript = 59;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KHAROSHTHI: GUnicodeScript = 60;
pub const GUnicodeScript_G_UNICODE_SCRIPT_UNKNOWN: GUnicodeScript = 61;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BALINESE: GUnicodeScript = 62;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CUNEIFORM: GUnicodeScript = 63;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PHOENICIAN: GUnicodeScript = 64;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PHAGS_PA: GUnicodeScript = 65;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NKO: GUnicodeScript = 66;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KAYAH_LI: GUnicodeScript = 67;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LEPCHA: GUnicodeScript = 68;
pub const GUnicodeScript_G_UNICODE_SCRIPT_REJANG: GUnicodeScript = 69;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SUNDANESE: GUnicodeScript = 70;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SAURASHTRA: GUnicodeScript = 71;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CHAM: GUnicodeScript = 72;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OL_CHIKI: GUnicodeScript = 73;
pub const GUnicodeScript_G_UNICODE_SCRIPT_VAI: GUnicodeScript = 74;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CARIAN: GUnicodeScript = 75;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LYCIAN: GUnicodeScript = 76;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LYDIAN: GUnicodeScript = 77;
pub const GUnicodeScript_G_UNICODE_SCRIPT_AVESTAN: GUnicodeScript = 78;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BAMUM: GUnicodeScript = 79;
pub const GUnicodeScript_G_UNICODE_SCRIPT_EGYPTIAN_HIEROGLYPHS: GUnicodeScript = 80;
pub const GUnicodeScript_G_UNICODE_SCRIPT_IMPERIAL_ARAMAIC: GUnicodeScript = 81;
pub const GUnicodeScript_G_UNICODE_SCRIPT_INSCRIPTIONAL_PAHLAVI: GUnicodeScript = 82;
pub const GUnicodeScript_G_UNICODE_SCRIPT_INSCRIPTIONAL_PARTHIAN: GUnicodeScript = 83;
pub const GUnicodeScript_G_UNICODE_SCRIPT_JAVANESE: GUnicodeScript = 84;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KAITHI: GUnicodeScript = 85;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LISU: GUnicodeScript = 86;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MEETEI_MAYEK: GUnicodeScript = 87;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_SOUTH_ARABIAN: GUnicodeScript = 88;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_TURKIC: GUnicodeScript = 89;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SAMARITAN: GUnicodeScript = 90;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAI_THAM: GUnicodeScript = 91;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAI_VIET: GUnicodeScript = 92;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BATAK: GUnicodeScript = 93;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BRAHMI: GUnicodeScript = 94;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MANDAIC: GUnicodeScript = 95;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CHAKMA: GUnicodeScript = 96;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MEROITIC_CURSIVE: GUnicodeScript = 97;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MEROITIC_HIEROGLYPHS: GUnicodeScript = 98;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MIAO: GUnicodeScript = 99;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SHARADA: GUnicodeScript = 100;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SORA_SOMPENG: GUnicodeScript = 101;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAKRI: GUnicodeScript = 102;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BASSA_VAH: GUnicodeScript = 103;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CAUCASIAN_ALBANIAN: GUnicodeScript = 104;
pub const GUnicodeScript_G_UNICODE_SCRIPT_DUPLOYAN: GUnicodeScript = 105;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ELBASAN: GUnicodeScript = 106;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GRANTHA: GUnicodeScript = 107;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KHOJKI: GUnicodeScript = 108;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KHUDAWADI: GUnicodeScript = 109;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LINEAR_A: GUnicodeScript = 110;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MAHAJANI: GUnicodeScript = 111;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MANICHAEAN: GUnicodeScript = 112;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MENDE_KIKAKUI: GUnicodeScript = 113;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MODI: GUnicodeScript = 114;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MRO: GUnicodeScript = 115;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NABATAEAN: GUnicodeScript = 116;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_NORTH_ARABIAN: GUnicodeScript = 117;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_PERMIC: GUnicodeScript = 118;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PAHAWH_HMONG: GUnicodeScript = 119;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PALMYRENE: GUnicodeScript = 120;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PAU_CIN_HAU: GUnicodeScript = 121;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PSALTER_PAHLAVI: GUnicodeScript = 122;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SIDDHAM: GUnicodeScript = 123;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TIRHUTA: GUnicodeScript = 124;
pub const GUnicodeScript_G_UNICODE_SCRIPT_WARANG_CITI: GUnicodeScript = 125;
pub const GUnicodeScript_G_UNICODE_SCRIPT_AHOM: GUnicodeScript = 126;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ANATOLIAN_HIEROGLYPHS: GUnicodeScript = 127;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HATRAN: GUnicodeScript = 128;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MULTANI: GUnicodeScript = 129;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_HUNGARIAN: GUnicodeScript = 130;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SIGNWRITING: GUnicodeScript = 131;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ADLAM: GUnicodeScript = 132;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BHAIKSUKI: GUnicodeScript = 133;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MARCHEN: GUnicodeScript = 134;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NEWA: GUnicodeScript = 135;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OSAGE: GUnicodeScript = 136;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TANGUT: GUnicodeScript = 137;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MASARAM_GONDI: GUnicodeScript = 138;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NUSHU: GUnicodeScript = 139;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SOYOMBO: GUnicodeScript = 140;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ZANABAZAR_SQUARE: GUnicodeScript = 141;
pub const GUnicodeScript_G_UNICODE_SCRIPT_DOGRA: GUnicodeScript = 142;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GUNJALA_GONDI: GUnicodeScript = 143;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HANIFI_ROHINGYA: GUnicodeScript = 144;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MAKASAR: GUnicodeScript = 145;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MEDEFAIDRIN: GUnicodeScript = 146;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_SOGDIAN: GUnicodeScript = 147;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SOGDIAN: GUnicodeScript = 148;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ELYMAIC: GUnicodeScript = 149;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NANDINAGARI: GUnicodeScript = 150;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NYIAKENG_PUACHUE_HMONG: GUnicodeScript = 151;
pub const GUnicodeScript_G_UNICODE_SCRIPT_WANCHO: GUnicodeScript = 152;
#[doc = " GUnicodeScript:"]
#[doc = " @G_UNICODE_SCRIPT_INVALID_CODE:"]
#[doc = "                               a value never returned from g_unichar_get_script()"]
#[doc = " @G_UNICODE_SCRIPT_COMMON:     a character used by multiple different scripts"]
#[doc = " @G_UNICODE_SCRIPT_INHERITED:  a mark glyph that takes its script from the"]
#[doc = "                               base glyph to which it is attached"]
#[doc = " @G_UNICODE_SCRIPT_ARABIC:     Arabic"]
#[doc = " @G_UNICODE_SCRIPT_ARMENIAN:   Armenian"]
#[doc = " @G_UNICODE_SCRIPT_BENGALI:    Bengali"]
#[doc = " @G_UNICODE_SCRIPT_BOPOMOFO:   Bopomofo"]
#[doc = " @G_UNICODE_SCRIPT_CHEROKEE:   Cherokee"]
#[doc = " @G_UNICODE_SCRIPT_COPTIC:     Coptic"]
#[doc = " @G_UNICODE_SCRIPT_CYRILLIC:   Cyrillic"]
#[doc = " @G_UNICODE_SCRIPT_DESERET:    Deseret"]
#[doc = " @G_UNICODE_SCRIPT_DEVANAGARI: Devanagari"]
#[doc = " @G_UNICODE_SCRIPT_ETHIOPIC:   Ethiopic"]
#[doc = " @G_UNICODE_SCRIPT_GEORGIAN:   Georgian"]
#[doc = " @G_UNICODE_SCRIPT_GOTHIC:     Gothic"]
#[doc = " @G_UNICODE_SCRIPT_GREEK:      Greek"]
#[doc = " @G_UNICODE_SCRIPT_GUJARATI:   Gujarati"]
#[doc = " @G_UNICODE_SCRIPT_GURMUKHI:   Gurmukhi"]
#[doc = " @G_UNICODE_SCRIPT_HAN:        Han"]
#[doc = " @G_UNICODE_SCRIPT_HANGUL:     Hangul"]
#[doc = " @G_UNICODE_SCRIPT_HEBREW:     Hebrew"]
#[doc = " @G_UNICODE_SCRIPT_HIRAGANA:   Hiragana"]
#[doc = " @G_UNICODE_SCRIPT_KANNADA:    Kannada"]
#[doc = " @G_UNICODE_SCRIPT_KATAKANA:   Katakana"]
#[doc = " @G_UNICODE_SCRIPT_KHMER:      Khmer"]
#[doc = " @G_UNICODE_SCRIPT_LAO:        Lao"]
#[doc = " @G_UNICODE_SCRIPT_LATIN:      Latin"]
#[doc = " @G_UNICODE_SCRIPT_MALAYALAM:  Malayalam"]
#[doc = " @G_UNICODE_SCRIPT_MONGOLIAN:  Mongolian"]
#[doc = " @G_UNICODE_SCRIPT_MYANMAR:    Myanmar"]
#[doc = " @G_UNICODE_SCRIPT_OGHAM:      Ogham"]
#[doc = " @G_UNICODE_SCRIPT_OLD_ITALIC: Old Italic"]
#[doc = " @G_UNICODE_SCRIPT_ORIYA:      Oriya"]
#[doc = " @G_UNICODE_SCRIPT_RUNIC:      Runic"]
#[doc = " @G_UNICODE_SCRIPT_SINHALA:    Sinhala"]
#[doc = " @G_UNICODE_SCRIPT_SYRIAC:     Syriac"]
#[doc = " @G_UNICODE_SCRIPT_TAMIL:      Tamil"]
#[doc = " @G_UNICODE_SCRIPT_TELUGU:     Telugu"]
#[doc = " @G_UNICODE_SCRIPT_THAANA:     Thaana"]
#[doc = " @G_UNICODE_SCRIPT_THAI:       Thai"]
#[doc = " @G_UNICODE_SCRIPT_TIBETAN:    Tibetan"]
#[doc = " @G_UNICODE_SCRIPT_CANADIAN_ABORIGINAL:"]
#[doc = "                               Canadian Aboriginal"]
#[doc = " @G_UNICODE_SCRIPT_YI:         Yi"]
#[doc = " @G_UNICODE_SCRIPT_TAGALOG:    Tagalog"]
#[doc = " @G_UNICODE_SCRIPT_HANUNOO:    Hanunoo"]
#[doc = " @G_UNICODE_SCRIPT_BUHID:      Buhid"]
#[doc = " @G_UNICODE_SCRIPT_TAGBANWA:   Tagbanwa"]
#[doc = " @G_UNICODE_SCRIPT_BRAILLE:    Braille"]
#[doc = " @G_UNICODE_SCRIPT_CYPRIOT:    Cypriot"]
#[doc = " @G_UNICODE_SCRIPT_LIMBU:      Limbu"]
#[doc = " @G_UNICODE_SCRIPT_OSMANYA:    Osmanya"]
#[doc = " @G_UNICODE_SCRIPT_SHAVIAN:    Shavian"]
#[doc = " @G_UNICODE_SCRIPT_LINEAR_B:   Linear B"]
#[doc = " @G_UNICODE_SCRIPT_TAI_LE:     Tai Le"]
#[doc = " @G_UNICODE_SCRIPT_UGARITIC:   Ugaritic"]
#[doc = " @G_UNICODE_SCRIPT_NEW_TAI_LUE:"]
#[doc = "                               New Tai Lue"]
#[doc = " @G_UNICODE_SCRIPT_BUGINESE:   Buginese"]
#[doc = " @G_UNICODE_SCRIPT_GLAGOLITIC: Glagolitic"]
#[doc = " @G_UNICODE_SCRIPT_TIFINAGH:   Tifinagh"]
#[doc = " @G_UNICODE_SCRIPT_SYLOTI_NAGRI:"]
#[doc = "                               Syloti Nagri"]
#[doc = " @G_UNICODE_SCRIPT_OLD_PERSIAN:"]
#[doc = "                               Old Persian"]
#[doc = " @G_UNICODE_SCRIPT_KHAROSHTHI: Kharoshthi"]
#[doc = " @G_UNICODE_SCRIPT_UNKNOWN:    an unassigned code point"]
#[doc = " @G_UNICODE_SCRIPT_BALINESE:   Balinese"]
#[doc = " @G_UNICODE_SCRIPT_CUNEIFORM:  Cuneiform"]
#[doc = " @G_UNICODE_SCRIPT_PHOENICIAN: Phoenician"]
#[doc = " @G_UNICODE_SCRIPT_PHAGS_PA:   Phags-pa"]
#[doc = " @G_UNICODE_SCRIPT_NKO:        N'Ko"]
#[doc = " @G_UNICODE_SCRIPT_KAYAH_LI:   Kayah Li. Since 2.16.3"]
#[doc = " @G_UNICODE_SCRIPT_LEPCHA:     Lepcha. Since 2.16.3"]
#[doc = " @G_UNICODE_SCRIPT_REJANG:     Rejang. Since 2.16.3"]
#[doc = " @G_UNICODE_SCRIPT_SUNDANESE:  Sundanese. Since 2.16.3"]
#[doc = " @G_UNICODE_SCRIPT_SAURASHTRA: Saurashtra. Since 2.16.3"]
#[doc = " @G_UNICODE_SCRIPT_CHAM:       Cham. Since 2.16.3"]
#[doc = " @G_UNICODE_SCRIPT_OL_CHIKI:   Ol Chiki. Since 2.16.3"]
#[doc = " @G_UNICODE_SCRIPT_VAI:        Vai. Since 2.16.3"]
#[doc = " @G_UNICODE_SCRIPT_CARIAN:     Carian. Since 2.16.3"]
#[doc = " @G_UNICODE_SCRIPT_LYCIAN:     Lycian. Since 2.16.3"]
#[doc = " @G_UNICODE_SCRIPT_LYDIAN:     Lydian. Since 2.16.3"]
#[doc = " @G_UNICODE_SCRIPT_AVESTAN:    Avestan. Since 2.26"]
#[doc = " @G_UNICODE_SCRIPT_BAMUM:      Bamum. Since 2.26"]
#[doc = " @G_UNICODE_SCRIPT_EGYPTIAN_HIEROGLYPHS:"]
#[doc = "                               Egyptian Hieroglpyhs. Since 2.26"]
#[doc = " @G_UNICODE_SCRIPT_IMPERIAL_ARAMAIC:"]
#[doc = "                               Imperial Aramaic. Since 2.26"]
#[doc = " @G_UNICODE_SCRIPT_INSCRIPTIONAL_PAHLAVI:"]
#[doc = "                               Inscriptional Pahlavi. Since 2.26"]
#[doc = " @G_UNICODE_SCRIPT_INSCRIPTIONAL_PARTHIAN:"]
#[doc = "                               Inscriptional Parthian. Since 2.26"]
#[doc = " @G_UNICODE_SCRIPT_JAVANESE:   Javanese. Since 2.26"]
#[doc = " @G_UNICODE_SCRIPT_KAITHI:     Kaithi. Since 2.26"]
#[doc = " @G_UNICODE_SCRIPT_LISU:       Lisu. Since 2.26"]
#[doc = " @G_UNICODE_SCRIPT_MEETEI_MAYEK:"]
#[doc = "                               Meetei Mayek. Since 2.26"]
#[doc = " @G_UNICODE_SCRIPT_OLD_SOUTH_ARABIAN:"]
#[doc = "                               Old South Arabian. Since 2.26"]
#[doc = " @G_UNICODE_SCRIPT_OLD_TURKIC: Old Turkic. Since 2.28"]
#[doc = " @G_UNICODE_SCRIPT_SAMARITAN:  Samaritan. Since 2.26"]
#[doc = " @G_UNICODE_SCRIPT_TAI_THAM:   Tai Tham. Since 2.26"]
#[doc = " @G_UNICODE_SCRIPT_TAI_VIET:   Tai Viet. Since 2.26"]
#[doc = " @G_UNICODE_SCRIPT_BATAK:      Batak. Since 2.28"]
#[doc = " @G_UNICODE_SCRIPT_BRAHMI:     Brahmi. Since 2.28"]
#[doc = " @G_UNICODE_SCRIPT_MANDAIC:    Mandaic. Since 2.28"]
#[doc = " @G_UNICODE_SCRIPT_CHAKMA:               Chakma. Since: 2.32"]
#[doc = " @G_UNICODE_SCRIPT_MEROITIC_CURSIVE:     Meroitic Cursive. Since: 2.32"]
#[doc = " @G_UNICODE_SCRIPT_MEROITIC_HIEROGLYPHS: Meroitic Hieroglyphs. Since: 2.32"]
#[doc = " @G_UNICODE_SCRIPT_MIAO:                 Miao. Since: 2.32"]
#[doc = " @G_UNICODE_SCRIPT_SHARADA:              Sharada. Since: 2.32"]
#[doc = " @G_UNICODE_SCRIPT_SORA_SOMPENG:         Sora Sompeng. Since: 2.32"]
#[doc = " @G_UNICODE_SCRIPT_TAKRI:                Takri. Since: 2.32"]
#[doc = " @G_UNICODE_SCRIPT_BASSA_VAH:            Bassa. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_CAUCASIAN_ALBANIAN:   Caucasian Albanian. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_DUPLOYAN:             Duployan. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_ELBASAN:              Elbasan. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_GRANTHA:              Grantha. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_KHOJKI:               Kjohki. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_KHUDAWADI:            Khudawadi, Sindhi. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_LINEAR_A:             Linear A. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_MAHAJANI:             Mahajani. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_MANICHAEAN:           Manichaean. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_MENDE_KIKAKUI:        Mende Kikakui. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_MODI:                 Modi. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_MRO:                  Mro. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_NABATAEAN:            Nabataean. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_OLD_NORTH_ARABIAN:    Old North Arabian. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_OLD_PERMIC:           Old Permic. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_PAHAWH_HMONG:         Pahawh Hmong. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_PALMYRENE:            Palmyrene. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_PAU_CIN_HAU:          Pau Cin Hau. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_PSALTER_PAHLAVI:      Psalter Pahlavi. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_SIDDHAM:              Siddham. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_TIRHUTA:              Tirhuta. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_WARANG_CITI:          Warang Citi. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_AHOM:                 Ahom. Since: 2.48"]
#[doc = " @G_UNICODE_SCRIPT_ANATOLIAN_HIEROGLYPHS: Anatolian Hieroglyphs. Since: 2.48"]
#[doc = " @G_UNICODE_SCRIPT_HATRAN:               Hatran. Since: 2.48"]
#[doc = " @G_UNICODE_SCRIPT_MULTANI:              Multani. Since: 2.48"]
#[doc = " @G_UNICODE_SCRIPT_OLD_HUNGARIAN:        Old Hungarian. Since: 2.48"]
#[doc = " @G_UNICODE_SCRIPT_SIGNWRITING:          Signwriting. Since: 2.48"]
#[doc = " @G_UNICODE_SCRIPT_ADLAM:                Adlam. Since: 2.50"]
#[doc = " @G_UNICODE_SCRIPT_BHAIKSUKI:            Bhaiksuki. Since: 2.50"]
#[doc = " @G_UNICODE_SCRIPT_MARCHEN:              Marchen. Since: 2.50"]
#[doc = " @G_UNICODE_SCRIPT_NEWA:                 Newa. Since: 2.50"]
#[doc = " @G_UNICODE_SCRIPT_OSAGE:                Osage. Since: 2.50"]
#[doc = " @G_UNICODE_SCRIPT_TANGUT:               Tangut. Since: 2.50"]
#[doc = " @G_UNICODE_SCRIPT_MASARAM_GONDI:        Masaram Gondi. Since: 2.54"]
#[doc = " @G_UNICODE_SCRIPT_NUSHU:                Nushu. Since: 2.54"]
#[doc = " @G_UNICODE_SCRIPT_SOYOMBO:              Soyombo. Since: 2.54"]
#[doc = " @G_UNICODE_SCRIPT_ZANABAZAR_SQUARE:     Zanabazar Square. Since: 2.54"]
#[doc = " @G_UNICODE_SCRIPT_DOGRA:                Dogra. Since: 2.58"]
#[doc = " @G_UNICODE_SCRIPT_GUNJALA_GONDI:        Gunjala Gondi. Since: 2.58"]
#[doc = " @G_UNICODE_SCRIPT_HANIFI_ROHINGYA:      Hanifi Rohingya. Since: 2.58"]
#[doc = " @G_UNICODE_SCRIPT_MAKASAR:              Makasar. Since: 2.58"]
#[doc = " @G_UNICODE_SCRIPT_MEDEFAIDRIN:          Medefaidrin. Since: 2.58"]
#[doc = " @G_UNICODE_SCRIPT_OLD_SOGDIAN:          Old Sogdian. Since: 2.58"]
#[doc = " @G_UNICODE_SCRIPT_SOGDIAN:              Sogdian. Since: 2.58"]
#[doc = " @G_UNICODE_SCRIPT_ELYMAIC:              Elym. Since: 2.62"]
#[doc = " @G_UNICODE_SCRIPT_NANDINAGARI:          Nand. Since: 2.62"]
#[doc = " @G_UNICODE_SCRIPT_NYIAKENG_PUACHUE_HMONG: Rohg. Since: 2.62"]
#[doc = " @G_UNICODE_SCRIPT_WANCHO:               Wcho. Since: 2.62"]
#[doc = ""]
#[doc = " The #GUnicodeScript enumeration identifies different writing"]
#[doc = " systems. The values correspond to the names as defined in the"]
#[doc = " Unicode standard. The enumeration has been added in GLib 2.14,"]
#[doc = " and is interchangeable with #PangoScript."]
#[doc = ""]
#[doc = " Note that new types may be added in the future. Applications"]
#[doc = " should be ready to handle unknown values."]
#[doc = " See [Unicode Standard Annex #24: Script names](http://www.unicode.org/reports/tr24/)."]
pub type GUnicodeScript = ::std::os::raw::c_int;
extern "C" {
    pub fn g_unicode_script_to_iso15924(script: GUnicodeScript) -> guint32;
}
extern "C" {
    pub fn g_unicode_script_from_iso15924(iso15924: guint32) -> GUnicodeScript;
}
extern "C" {
    pub fn g_unichar_isalnum(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_isalpha(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_iscntrl(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_isdigit(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_isgraph(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_islower(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_isprint(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_ispunct(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_isspace(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_isupper(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_isxdigit(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_istitle(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_isdefined(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_iswide(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_iswide_cjk(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_iszerowidth(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_ismark(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_toupper(c: gunichar) -> gunichar;
}
extern "C" {
    pub fn g_unichar_tolower(c: gunichar) -> gunichar;
}
extern "C" {
    pub fn g_unichar_totitle(c: gunichar) -> gunichar;
}
extern "C" {
    pub fn g_unichar_digit_value(c: gunichar) -> gint;
}
extern "C" {
    pub fn g_unichar_xdigit_value(c: gunichar) -> gint;
}
extern "C" {
    pub fn g_unichar_type(c: gunichar) -> GUnicodeType;
}
extern "C" {
    pub fn g_unichar_break_type(c: gunichar) -> GUnicodeBreakType;
}
extern "C" {
    pub fn g_unichar_combining_class(uc: gunichar) -> gint;
}
extern "C" {
    pub fn g_unichar_get_mirror_char(ch: gunichar, mirrored_ch: *mut gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_get_script(ch: gunichar) -> GUnicodeScript;
}
extern "C" {
    pub fn g_unichar_validate(ch: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_compose(a: gunichar, b: gunichar, ch: *mut gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_decompose(ch: gunichar, a: *mut gunichar, b: *mut gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_fully_decompose(
        ch: gunichar,
        compat: gboolean,
        result: *mut gunichar,
        result_len: gsize,
    ) -> gsize;
}
extern "C" {
    pub fn g_unicode_canonical_ordering(string: *mut gunichar, len: gsize);
}
extern "C" {
    pub fn g_unicode_canonical_decomposition(ch: gunichar, result_len: *mut gsize)
        -> *mut gunichar;
}
extern "C" {
    pub static g_utf8_skip: *const gchar;
}
extern "C" {
    pub fn g_utf8_get_char(p: *const gchar) -> gunichar;
}
extern "C" {
    pub fn g_utf8_get_char_validated(p: *const gchar, max_len: gssize) -> gunichar;
}
extern "C" {
    pub fn g_utf8_offset_to_pointer(str_: *const gchar, offset: glong) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_pointer_to_offset(str_: *const gchar, pos: *const gchar) -> glong;
}
extern "C" {
    pub fn g_utf8_prev_char(p: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_find_next_char(p: *const gchar, end: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_find_prev_char(str_: *const gchar, p: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_strlen(p: *const gchar, max: gssize) -> glong;
}
extern "C" {
    pub fn g_utf8_substring(str_: *const gchar, start_pos: glong, end_pos: glong) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_strncpy(dest: *mut gchar, src: *const gchar, n: gsize) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_strchr(p: *const gchar, len: gssize, c: gunichar) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_strrchr(p: *const gchar, len: gssize, c: gunichar) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_strreverse(str_: *const gchar, len: gssize) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_to_utf16(
        str_: *const gchar,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gunichar2;
}
extern "C" {
    pub fn g_utf8_to_ucs4(
        str_: *const gchar,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gunichar;
}
extern "C" {
    pub fn g_utf8_to_ucs4_fast(
        str_: *const gchar,
        len: glong,
        items_written: *mut glong,
    ) -> *mut gunichar;
}
extern "C" {
    pub fn g_utf16_to_ucs4(
        str_: *const gunichar2,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gunichar;
}
extern "C" {
    pub fn g_utf16_to_utf8(
        str_: *const gunichar2,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_ucs4_to_utf16(
        str_: *const gunichar,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gunichar2;
}
extern "C" {
    pub fn g_ucs4_to_utf8(
        str_: *const gunichar,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_unichar_to_utf8(c: gunichar, outbuf: *mut gchar) -> gint;
}
extern "C" {
    pub fn g_utf8_validate(str_: *const gchar, max_len: gssize, end: *mut *const gchar)
        -> gboolean;
}
extern "C" {
    pub fn g_utf8_validate_len(
        str_: *const gchar,
        max_len: gsize,
        end: *mut *const gchar,
    ) -> gboolean;
}
extern "C" {
    pub fn g_utf8_strup(str_: *const gchar, len: gssize) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_strdown(str_: *const gchar, len: gssize) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_casefold(str_: *const gchar, len: gssize) -> *mut gchar;
}
pub const GNormalizeMode_G_NORMALIZE_DEFAULT: GNormalizeMode = 0;
pub const GNormalizeMode_G_NORMALIZE_NFD: GNormalizeMode = 0;
pub const GNormalizeMode_G_NORMALIZE_DEFAULT_COMPOSE: GNormalizeMode = 1;
pub const GNormalizeMode_G_NORMALIZE_NFC: GNormalizeMode = 1;
pub const GNormalizeMode_G_NORMALIZE_ALL: GNormalizeMode = 2;
pub const GNormalizeMode_G_NORMALIZE_NFKD: GNormalizeMode = 2;
pub const GNormalizeMode_G_NORMALIZE_ALL_COMPOSE: GNormalizeMode = 3;
pub const GNormalizeMode_G_NORMALIZE_NFKC: GNormalizeMode = 3;
#[doc = " GNormalizeMode:"]
#[doc = " @G_NORMALIZE_DEFAULT: standardize differences that do not affect the"]
#[doc = "     text content, such as the above-mentioned accent representation"]
#[doc = " @G_NORMALIZE_NFD: another name for %G_NORMALIZE_DEFAULT"]
#[doc = " @G_NORMALIZE_DEFAULT_COMPOSE: like %G_NORMALIZE_DEFAULT, but with"]
#[doc = "     composed forms rather than a maximally decomposed form"]
#[doc = " @G_NORMALIZE_NFC: another name for %G_NORMALIZE_DEFAULT_COMPOSE"]
#[doc = " @G_NORMALIZE_ALL: beyond %G_NORMALIZE_DEFAULT also standardize the"]
#[doc = "     \"compatibility\" characters in Unicode, such as SUPERSCRIPT THREE"]
#[doc = "     to the standard forms (in this case DIGIT THREE). Formatting"]
#[doc = "     information may be lost but for most text operations such"]
#[doc = "     characters should be considered the same"]
#[doc = " @G_NORMALIZE_NFKD: another name for %G_NORMALIZE_ALL"]
#[doc = " @G_NORMALIZE_ALL_COMPOSE: like %G_NORMALIZE_ALL, but with composed"]
#[doc = "     forms rather than a maximally decomposed form"]
#[doc = " @G_NORMALIZE_NFKC: another name for %G_NORMALIZE_ALL_COMPOSE"]
#[doc = ""]
#[doc = " Defines how a Unicode string is transformed in a canonical"]
#[doc = " form, standardizing such issues as whether a character with"]
#[doc = " an accent is represented as a base character and combining"]
#[doc = " accent or as a single precomposed character. Unicode strings"]
#[doc = " should generally be normalized before comparing them."]
pub type GNormalizeMode = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_utf8_normalize(str_: *const gchar, len: gssize, mode: GNormalizeMode) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_collate(str1: *const gchar, str2: *const gchar) -> gint;
}
extern "C" {
    pub fn g_utf8_collate_key(str_: *const gchar, len: gssize) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_collate_key_for_filename(str_: *const gchar, len: gssize) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_make_valid(str_: *const gchar, len: gssize) -> *mut gchar;
}
pub type GString = _GString;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GString {
    pub str_: *mut gchar,
    pub len: gsize,
    pub allocated_len: gsize,
}
#[test]
fn bindgen_test_layout__GString() {
    assert_eq!(
        ::std::mem::size_of::<_GString>(),
        24usize,
        concat!("Size of: ", stringify!(_GString))
    );
    assert_eq!(
        ::std::mem::align_of::<_GString>(),
        8usize,
        concat!("Alignment of ", stringify!(_GString))
    );
    fn test_field_str() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GString>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).str_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GString),
                "::",
                stringify!(str_)
            )
        );
    }
    test_field_str();
    fn test_field_len() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GString>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_GString),
                "::",
                stringify!(len)
            )
        );
    }
    test_field_len();
    fn test_field_allocated_len() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GString>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).allocated_len) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_GString),
                "::",
                stringify!(allocated_len)
            )
        );
    }
    test_field_allocated_len();
}
extern "C" {
    pub fn g_string_new(init: *const gchar) -> *mut GString;
}
extern "C" {
    pub fn g_string_new_len(init: *const gchar, len: gssize) -> *mut GString;
}
extern "C" {
    pub fn g_string_sized_new(dfl_size: gsize) -> *mut GString;
}
extern "C" {
    pub fn g_string_free(string: *mut GString, free_segment: gboolean) -> *mut gchar;
}
extern "C" {
    pub fn g_string_free_to_bytes(string: *mut GString) -> *mut GBytes;
}
extern "C" {
    pub fn g_string_equal(v: *const GString, v2: *const GString) -> gboolean;
}
extern "C" {
    pub fn g_string_hash(str_: *const GString) -> guint;
}
extern "C" {
    pub fn g_string_assign(string: *mut GString, rval: *const gchar) -> *mut GString;
}
extern "C" {
    pub fn g_string_truncate(string: *mut GString, len: gsize) -> *mut GString;
}
extern "C" {
    pub fn g_string_set_size(string: *mut GString, len: gsize) -> *mut GString;
}
extern "C" {
    pub fn g_string_insert_len(
        string: *mut GString,
        pos: gssize,
        val: *const gchar,
        len: gssize,
    ) -> *mut GString;
}
extern "C" {
    pub fn g_string_append(string: *mut GString, val: *const gchar) -> *mut GString;
}
extern "C" {
    pub fn g_string_append_len(
        string: *mut GString,
        val: *const gchar,
        len: gssize,
    ) -> *mut GString;
}
extern "C" {
    pub fn g_string_append_c(string: *mut GString, c: gchar) -> *mut GString;
}
extern "C" {
    pub fn g_string_append_unichar(string: *mut GString, wc: gunichar) -> *mut GString;
}
extern "C" {
    pub fn g_string_prepend(string: *mut GString, val: *const gchar) -> *mut GString;
}
extern "C" {
    pub fn g_string_prepend_c(string: *mut GString, c: gchar) -> *mut GString;
}
extern "C" {
    pub fn g_string_prepend_unichar(string: *mut GString, wc: gunichar) -> *mut GString;
}
extern "C" {
    pub fn g_string_prepend_len(
        string: *mut GString,
        val: *const gchar,
        len: gssize,
    ) -> *mut GString;
}
extern "C" {
    pub fn g_string_insert(string: *mut GString, pos: gssize, val: *const gchar) -> *mut GString;
}
extern "C" {
    pub fn g_string_insert_c(string: *mut GString, pos: gssize, c: gchar) -> *mut GString;
}
extern "C" {
    pub fn g_string_insert_unichar(string: *mut GString, pos: gssize, wc: gunichar)
        -> *mut GString;
}
extern "C" {
    pub fn g_string_overwrite(string: *mut GString, pos: gsize, val: *const gchar) -> *mut GString;
}
extern "C" {
    pub fn g_string_overwrite_len(
        string: *mut GString,
        pos: gsize,
        val: *const gchar,
        len: gssize,
    ) -> *mut GString;
}
extern "C" {
    pub fn g_string_erase(string: *mut GString, pos: gssize, len: gssize) -> *mut GString;
}
extern "C" {
    pub fn g_string_ascii_down(string: *mut GString) -> *mut GString;
}
extern "C" {
    pub fn g_string_ascii_up(string: *mut GString) -> *mut GString;
}
extern "C" {
    pub fn g_string_vprintf(string: *mut GString, format: *const gchar, args: va_list);
}
extern "C" {
    pub fn g_string_printf(string: *mut GString, format: *const gchar, ...);
}
extern "C" {
    pub fn g_string_append_vprintf(string: *mut GString, format: *const gchar, args: va_list);
}
extern "C" {
    pub fn g_string_append_printf(string: *mut GString, format: *const gchar, ...);
}
extern "C" {
    pub fn g_string_append_uri_escaped(
        string: *mut GString,
        unescaped: *const gchar,
        reserved_chars_allowed: *const gchar,
        allow_utf8: gboolean,
    ) -> *mut GString;
}
extern "C" {
    pub fn g_string_down(string: *mut GString) -> *mut GString;
}
extern "C" {
    pub fn g_string_up(string: *mut GString) -> *mut GString;
}
pub type GIOChannel = _GIOChannel;
pub type GIOFuncs = _GIOFuncs;
pub const GIOError_G_IO_ERROR_NONE: GIOError = 0;
pub const GIOError_G_IO_ERROR_AGAIN: GIOError = 1;
pub const GIOError_G_IO_ERROR_INVAL: GIOError = 2;
pub const GIOError_G_IO_ERROR_UNKNOWN: GIOError = 3;
pub type GIOError = ::std::os::raw::c_uint;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_FBIG: GIOChannelError = 0;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_INVAL: GIOChannelError = 1;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_IO: GIOChannelError = 2;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_ISDIR: GIOChannelError = 3;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_NOSPC: GIOChannelError = 4;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_NXIO: GIOChannelError = 5;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_OVERFLOW: GIOChannelError = 6;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_PIPE: GIOChannelError = 7;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_FAILED: GIOChannelError = 8;
pub type GIOChannelError = ::std::os::raw::c_uint;
pub const GIOStatus_G_IO_STATUS_ERROR: GIOStatus = 0;
pub const GIOStatus_G_IO_STATUS_NORMAL: GIOStatus = 1;
pub const GIOStatus_G_IO_STATUS_EOF: GIOStatus = 2;
pub const GIOStatus_G_IO_STATUS_AGAIN: GIOStatus = 3;
pub type GIOStatus = ::std::os::raw::c_uint;
pub const GSeekType_G_SEEK_CUR: GSeekType = 0;
pub const GSeekType_G_SEEK_SET: GSeekType = 1;
pub const GSeekType_G_SEEK_END: GSeekType = 2;
pub type GSeekType = ::std::os::raw::c_uint;
pub const GIOFlags_G_IO_FLAG_APPEND: GIOFlags = 1;
pub const GIOFlags_G_IO_FLAG_NONBLOCK: GIOFlags = 2;
pub const GIOFlags_G_IO_FLAG_IS_READABLE: GIOFlags = 4;
pub const GIOFlags_G_IO_FLAG_IS_WRITABLE: GIOFlags = 8;
pub const GIOFlags_G_IO_FLAG_IS_WRITEABLE: GIOFlags = 8;
pub const GIOFlags_G_IO_FLAG_IS_SEEKABLE: GIOFlags = 16;
pub const GIOFlags_G_IO_FLAG_MASK: GIOFlags = 31;
pub const GIOFlags_G_IO_FLAG_GET_MASK: GIOFlags = 31;
pub const GIOFlags_G_IO_FLAG_SET_MASK: GIOFlags = 3;
pub type GIOFlags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIOChannel {
    pub ref_count: gint,
    pub funcs: *mut GIOFuncs,
    pub encoding: *mut gchar,
    pub read_cd: GIConv,
    pub write_cd: GIConv,
    pub line_term: *mut gchar,
    pub line_term_len: guint,
    pub buf_size: gsize,
    pub read_buf: *mut GString,
    pub encoded_read_buf: *mut GString,
    pub write_buf: *mut GString,
    pub partial_write_buf: [gchar; 6usize],
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub reserved1: gpointer,
    pub reserved2: gpointer,
}
#[test]
fn bindgen_test_layout__GIOChannel() {
    assert_eq!(
        ::std::mem::size_of::<_GIOChannel>(),
        112usize,
        concat!("Size of: ", stringify!(_GIOChannel))
    );
    assert_eq!(
        ::std::mem::align_of::<_GIOChannel>(),
        8usize,
        concat!("Alignment of ", stringify!(_GIOChannel))
    );
    fn test_field_ref_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GIOChannel>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ref_count) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GIOChannel),
                "::",
                stringify!(ref_count)
            )
        );
    }
    test_field_ref_count();
    fn test_field_funcs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GIOChannel>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).funcs) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_GIOChannel),
                "::",
                stringify!(funcs)
            )
        );
    }
    test_field_funcs();
    fn test_field_encoding() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GIOChannel>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).encoding) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_GIOChannel),
                "::",
                stringify!(encoding)
            )
        );
    }
    test_field_encoding();
    fn test_field_read_cd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GIOChannel>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).read_cd) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_GIOChannel),
                "::",
                stringify!(read_cd)
            )
        );
    }
    test_field_read_cd();
    fn test_field_write_cd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GIOChannel>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).write_cd) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_GIOChannel),
                "::",
                stringify!(write_cd)
            )
        );
    }
    test_field_write_cd();
    fn test_field_line_term() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GIOChannel>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).line_term) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_GIOChannel),
                "::",
                stringify!(line_term)
            )
        );
    }
    test_field_line_term();
    fn test_field_line_term_len() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GIOChannel>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).line_term_len) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_GIOChannel),
                "::",
                stringify!(line_term_len)
            )
        );
    }
    test_field_line_term_len();
    fn test_field_buf_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GIOChannel>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).buf_size) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_GIOChannel),
                "::",
                stringify!(buf_size)
            )
        );
    }
    test_field_buf_size();
    fn test_field_read_buf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GIOChannel>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).read_buf) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_GIOChannel),
                "::",
                stringify!(read_buf)
            )
        );
    }
    test_field_read_buf();
    fn test_field_encoded_read_buf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GIOChannel>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).encoded_read_buf) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_GIOChannel),
                "::",
                stringify!(encoded_read_buf)
            )
        );
    }
    test_field_encoded_read_buf();
    fn test_field_write_buf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GIOChannel>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).write_buf) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_GIOChannel),
                "::",
                stringify!(write_buf)
            )
        );
    }
    test_field_write_buf();
    fn test_field_partial_write_buf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GIOChannel>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).partial_write_buf) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_GIOChannel),
                "::",
                stringify!(partial_write_buf)
            )
        );
    }
    test_field_partial_write_buf();
    fn test_field_reserved1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GIOChannel>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_GIOChannel),
                "::",
                stringify!(reserved1)
            )
        );
    }
    test_field_reserved1();
    fn test_field_reserved2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GIOChannel>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_GIOChannel),
                "::",
                stringify!(reserved2)
            )
        );
    }
    test_field_reserved2();
}
impl _GIOChannel {
    #[inline]
    pub fn use_buffer(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_use_buffer(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn do_encode(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_do_encode(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn close_on_unref(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_close_on_unref(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_readable(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_readable(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_writeable(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_writeable(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_seekable(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_seekable(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        use_buffer: guint,
        do_encode: guint,
        close_on_unref: guint,
        is_readable: guint,
        is_writeable: guint,
        is_seekable: guint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let use_buffer: u32 = unsafe { ::std::mem::transmute(use_buffer) };
            use_buffer as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let do_encode: u32 = unsafe { ::std::mem::transmute(do_encode) };
            do_encode as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let close_on_unref: u32 = unsafe { ::std::mem::transmute(close_on_unref) };
            close_on_unref as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let is_readable: u32 = unsafe { ::std::mem::transmute(is_readable) };
            is_readable as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let is_writeable: u32 = unsafe { ::std::mem::transmute(is_writeable) };
            is_writeable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let is_seekable: u32 = unsafe { ::std::mem::transmute(is_seekable) };
            is_seekable as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type GIOFunc = ::std::option::Option<
    unsafe extern "C" fn(
        source: *mut GIOChannel,
        condition: GIOCondition,
        data: gpointer,
    ) -> gboolean,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIOFuncs {
    pub io_read: ::std::option::Option<
        unsafe extern "C" fn(
            channel: *mut GIOChannel,
            buf: *mut gchar,
            count: gsize,
            bytes_read: *mut gsize,
            err: *mut *mut GError,
        ) -> GIOStatus,
    >,
    pub io_write: ::std::option::Option<
        unsafe extern "C" fn(
            channel: *mut GIOChannel,
            buf: *const gchar,
            count: gsize,
            bytes_written: *mut gsize,
            err: *mut *mut GError,
        ) -> GIOStatus,
    >,
    pub io_seek: ::std::option::Option<
        unsafe extern "C" fn(
            channel: *mut GIOChannel,
            offset: gint64,
            type_: GSeekType,
            err: *mut *mut GError,
        ) -> GIOStatus,
    >,
    pub io_close: ::std::option::Option<
        unsafe extern "C" fn(channel: *mut GIOChannel, err: *mut *mut GError) -> GIOStatus,
    >,
    pub io_create_watch: ::std::option::Option<
        unsafe extern "C" fn(channel: *mut GIOChannel, condition: GIOCondition) -> *mut GSource,
    >,
    pub io_free: ::std::option::Option<unsafe extern "C" fn(channel: *mut GIOChannel)>,
    pub io_set_flags: ::std::option::Option<
        unsafe extern "C" fn(
            channel: *mut GIOChannel,
            flags: GIOFlags,
            err: *mut *mut GError,
        ) -> GIOStatus,
    >,
    pub io_get_flags:
        ::std::option::Option<unsafe extern "C" fn(channel: *mut GIOChannel) -> GIOFlags>,
}
#[test]
fn bindgen_test_layout__GIOFuncs() {
    assert_eq!(
        ::std::mem::size_of::<_GIOFuncs>(),
        64usize,
        concat!("Size of: ", stringify!(_GIOFuncs))
    );
    assert_eq!(
        ::std::mem::align_of::<_GIOFuncs>(),
        8usize,
        concat!("Alignment of ", stringify!(_GIOFuncs))
    );
    fn test_field_io_read() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GIOFuncs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).io_read) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GIOFuncs),
                "::",
                stringify!(io_read)
            )
        );
    }
    test_field_io_read();
    fn test_field_io_write() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GIOFuncs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).io_write) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_GIOFuncs),
                "::",
                stringify!(io_write)
            )
        );
    }
    test_field_io_write();
    fn test_field_io_seek() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GIOFuncs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).io_seek) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_GIOFuncs),
                "::",
                stringify!(io_seek)
            )
        );
    }
    test_field_io_seek();
    fn test_field_io_close() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GIOFuncs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).io_close) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_GIOFuncs),
                "::",
                stringify!(io_close)
            )
        );
    }
    test_field_io_close();
    fn test_field_io_create_watch() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GIOFuncs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).io_create_watch) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_GIOFuncs),
                "::",
                stringify!(io_create_watch)
            )
        );
    }
    test_field_io_create_watch();
    fn test_field_io_free() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GIOFuncs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).io_free) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_GIOFuncs),
                "::",
                stringify!(io_free)
            )
        );
    }
    test_field_io_free();
    fn test_field_io_set_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GIOFuncs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).io_set_flags) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_GIOFuncs),
                "::",
                stringify!(io_set_flags)
            )
        );
    }
    test_field_io_set_flags();
    fn test_field_io_get_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GIOFuncs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).io_get_flags) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_GIOFuncs),
                "::",
                stringify!(io_get_flags)
            )
        );
    }
    test_field_io_get_flags();
}
extern "C" {
    pub fn g_io_channel_init(channel: *mut GIOChannel);
}
extern "C" {
    pub fn g_io_channel_ref(channel: *mut GIOChannel) -> *mut GIOChannel;
}
extern "C" {
    pub fn g_io_channel_unref(channel: *mut GIOChannel);
}
extern "C" {
    pub fn g_io_channel_read(
        channel: *mut GIOChannel,
        buf: *mut gchar,
        count: gsize,
        bytes_read: *mut gsize,
    ) -> GIOError;
}
extern "C" {
    pub fn g_io_channel_write(
        channel: *mut GIOChannel,
        buf: *const gchar,
        count: gsize,
        bytes_written: *mut gsize,
    ) -> GIOError;
}
extern "C" {
    pub fn g_io_channel_seek(
        channel: *mut GIOChannel,
        offset: gint64,
        type_: GSeekType,
    ) -> GIOError;
}
extern "C" {
    pub fn g_io_channel_close(channel: *mut GIOChannel);
}
extern "C" {
    pub fn g_io_channel_shutdown(
        channel: *mut GIOChannel,
        flush: gboolean,
        err: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_add_watch_full(
        channel: *mut GIOChannel,
        priority: gint,
        condition: GIOCondition,
        func: GIOFunc,
        user_data: gpointer,
        notify: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    pub fn g_io_create_watch(channel: *mut GIOChannel, condition: GIOCondition) -> *mut GSource;
}
extern "C" {
    pub fn g_io_add_watch(
        channel: *mut GIOChannel,
        condition: GIOCondition,
        func: GIOFunc,
        user_data: gpointer,
    ) -> guint;
}
extern "C" {
    pub fn g_io_channel_set_buffer_size(channel: *mut GIOChannel, size: gsize);
}
extern "C" {
    pub fn g_io_channel_get_buffer_size(channel: *mut GIOChannel) -> gsize;
}
extern "C" {
    pub fn g_io_channel_get_buffer_condition(channel: *mut GIOChannel) -> GIOCondition;
}
extern "C" {
    pub fn g_io_channel_set_flags(
        channel: *mut GIOChannel,
        flags: GIOFlags,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_get_flags(channel: *mut GIOChannel) -> GIOFlags;
}
extern "C" {
    pub fn g_io_channel_set_line_term(
        channel: *mut GIOChannel,
        line_term: *const gchar,
        length: gint,
    );
}
extern "C" {
    pub fn g_io_channel_get_line_term(channel: *mut GIOChannel, length: *mut gint) -> *const gchar;
}
extern "C" {
    pub fn g_io_channel_set_buffered(channel: *mut GIOChannel, buffered: gboolean);
}
extern "C" {
    pub fn g_io_channel_get_buffered(channel: *mut GIOChannel) -> gboolean;
}
extern "C" {
    pub fn g_io_channel_set_encoding(
        channel: *mut GIOChannel,
        encoding: *const gchar,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_get_encoding(channel: *mut GIOChannel) -> *const gchar;
}
extern "C" {
    pub fn g_io_channel_set_close_on_unref(channel: *mut GIOChannel, do_close: gboolean);
}
extern "C" {
    pub fn g_io_channel_get_close_on_unref(channel: *mut GIOChannel) -> gboolean;
}
extern "C" {
    pub fn g_io_channel_flush(channel: *mut GIOChannel, error: *mut *mut GError) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_read_line(
        channel: *mut GIOChannel,
        str_return: *mut *mut gchar,
        length: *mut gsize,
        terminator_pos: *mut gsize,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_read_line_string(
        channel: *mut GIOChannel,
        buffer: *mut GString,
        terminator_pos: *mut gsize,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_read_to_end(
        channel: *mut GIOChannel,
        str_return: *mut *mut gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_read_chars(
        channel: *mut GIOChannel,
        buf: *mut gchar,
        count: gsize,
        bytes_read: *mut gsize,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_read_unichar(
        channel: *mut GIOChannel,
        thechar: *mut gunichar,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_write_chars(
        channel: *mut GIOChannel,
        buf: *const gchar,
        count: gssize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_write_unichar(
        channel: *mut GIOChannel,
        thechar: gunichar,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_seek_position(
        channel: *mut GIOChannel,
        offset: gint64,
        type_: GSeekType,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_new_file(
        filename: *const gchar,
        mode: *const gchar,
        error: *mut *mut GError,
    ) -> *mut GIOChannel;
}
extern "C" {
    pub fn g_io_channel_error_quark() -> GQuark;
}
extern "C" {
    pub fn g_io_channel_error_from_errno(en: gint) -> GIOChannelError;
}
extern "C" {
    pub fn g_io_channel_unix_new(fd: ::std::os::raw::c_int) -> *mut GIOChannel;
}
extern "C" {
    pub fn g_io_channel_unix_get_fd(channel: *mut GIOChannel) -> gint;
}
extern "C" {
    pub static mut g_io_watch_funcs: GSourceFuncs;
}
pub const GKeyFileError_G_KEY_FILE_ERROR_UNKNOWN_ENCODING: GKeyFileError = 0;
pub const GKeyFileError_G_KEY_FILE_ERROR_PARSE: GKeyFileError = 1;
pub const GKeyFileError_G_KEY_FILE_ERROR_NOT_FOUND: GKeyFileError = 2;
pub const GKeyFileError_G_KEY_FILE_ERROR_KEY_NOT_FOUND: GKeyFileError = 3;
pub const GKeyFileError_G_KEY_FILE_ERROR_GROUP_NOT_FOUND: GKeyFileError = 4;
pub const GKeyFileError_G_KEY_FILE_ERROR_INVALID_VALUE: GKeyFileError = 5;
pub type GKeyFileError = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_key_file_error_quark() -> GQuark;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GKeyFile {
    _unused: [u8; 0],
}
pub type GKeyFile = _GKeyFile;
pub const GKeyFileFlags_G_KEY_FILE_NONE: GKeyFileFlags = 0;
pub const GKeyFileFlags_G_KEY_FILE_KEEP_COMMENTS: GKeyFileFlags = 1;
pub const GKeyFileFlags_G_KEY_FILE_KEEP_TRANSLATIONS: GKeyFileFlags = 2;
pub type GKeyFileFlags = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_key_file_new() -> *mut GKeyFile;
}
extern "C" {
    pub fn g_key_file_ref(key_file: *mut GKeyFile) -> *mut GKeyFile;
}
extern "C" {
    pub fn g_key_file_unref(key_file: *mut GKeyFile);
}
extern "C" {
    pub fn g_key_file_free(key_file: *mut GKeyFile);
}
extern "C" {
    pub fn g_key_file_set_list_separator(key_file: *mut GKeyFile, separator: gchar);
}
extern "C" {
    pub fn g_key_file_load_from_file(
        key_file: *mut GKeyFile,
        file: *const gchar,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_load_from_data(
        key_file: *mut GKeyFile,
        data: *const gchar,
        length: gsize,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_load_from_bytes(
        key_file: *mut GKeyFile,
        bytes: *mut GBytes,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_load_from_dirs(
        key_file: *mut GKeyFile,
        file: *const gchar,
        search_dirs: *mut *const gchar,
        full_path: *mut *mut gchar,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_load_from_data_dirs(
        key_file: *mut GKeyFile,
        file: *const gchar,
        full_path: *mut *mut gchar,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_to_data(
        key_file: *mut GKeyFile,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_key_file_save_to_file(
        key_file: *mut GKeyFile,
        filename: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_get_start_group(key_file: *mut GKeyFile) -> *mut gchar;
}
extern "C" {
    pub fn g_key_file_get_groups(key_file: *mut GKeyFile, length: *mut gsize) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_key_file_get_keys(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_key_file_has_group(key_file: *mut GKeyFile, group_name: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_key_file_has_key(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_get_value(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_key_file_set_value(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: *const gchar,
    );
}
extern "C" {
    pub fn g_key_file_get_string(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_key_file_set_string(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        string: *const gchar,
    );
}
extern "C" {
    pub fn g_key_file_get_locale_string(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        locale: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_key_file_get_locale_for_key(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        locale: *const gchar,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_key_file_set_locale_string(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        locale: *const gchar,
        string: *const gchar,
    );
}
extern "C" {
    pub fn g_key_file_get_boolean(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_set_boolean(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: gboolean,
    );
}
extern "C" {
    pub fn g_key_file_get_integer(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gint;
}
extern "C" {
    pub fn g_key_file_set_integer(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: gint,
    );
}
extern "C" {
    pub fn g_key_file_get_int64(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gint64;
}
extern "C" {
    pub fn g_key_file_set_int64(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: gint64,
    );
}
extern "C" {
    pub fn g_key_file_get_uint64(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> guint64;
}
extern "C" {
    pub fn g_key_file_set_uint64(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: guint64,
    );
}
extern "C" {
    pub fn g_key_file_get_double(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gdouble;
}
extern "C" {
    pub fn g_key_file_set_double(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: gdouble,
    );
}
extern "C" {
    pub fn g_key_file_get_string_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_key_file_set_string_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        list: *const *const gchar,
        length: gsize,
    );
}
extern "C" {
    pub fn g_key_file_get_locale_string_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        locale: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_key_file_set_locale_string_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        locale: *const gchar,
        list: *const *const gchar,
        length: gsize,
    );
}
extern "C" {
    pub fn g_key_file_get_boolean_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gboolean;
}
extern "C" {
    pub fn g_key_file_set_boolean_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        list: *mut gboolean,
        length: gsize,
    );
}
extern "C" {
    pub fn g_key_file_get_integer_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gint;
}
extern "C" {
    pub fn g_key_file_set_double_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        list: *mut gdouble,
        length: gsize,
    );
}
extern "C" {
    pub fn g_key_file_get_double_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gdouble;
}
extern "C" {
    pub fn g_key_file_set_integer_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        list: *mut gint,
        length: gsize,
    );
}
extern "C" {
    pub fn g_key_file_set_comment(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        comment: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_get_comment(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_key_file_remove_comment(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_remove_key(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_remove_group(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMappedFile {
    _unused: [u8; 0],
}
pub type GMappedFile = _GMappedFile;
extern "C" {
    pub fn g_mapped_file_new(
        filename: *const gchar,
        writable: gboolean,
        error: *mut *mut GError,
    ) -> *mut GMappedFile;
}
extern "C" {
    pub fn g_mapped_file_new_from_fd(
        fd: gint,
        writable: gboolean,
        error: *mut *mut GError,
    ) -> *mut GMappedFile;
}
extern "C" {
    pub fn g_mapped_file_get_length(file: *mut GMappedFile) -> gsize;
}
extern "C" {
    pub fn g_mapped_file_get_contents(file: *mut GMappedFile) -> *mut gchar;
}
extern "C" {
    pub fn g_mapped_file_get_bytes(file: *mut GMappedFile) -> *mut GBytes;
}
extern "C" {
    pub fn g_mapped_file_ref(file: *mut GMappedFile) -> *mut GMappedFile;
}
extern "C" {
    pub fn g_mapped_file_unref(file: *mut GMappedFile);
}
extern "C" {
    pub fn g_mapped_file_free(file: *mut GMappedFile);
}
pub const GMarkupError_G_MARKUP_ERROR_BAD_UTF8: GMarkupError = 0;
pub const GMarkupError_G_MARKUP_ERROR_EMPTY: GMarkupError = 1;
pub const GMarkupError_G_MARKUP_ERROR_PARSE: GMarkupError = 2;
pub const GMarkupError_G_MARKUP_ERROR_UNKNOWN_ELEMENT: GMarkupError = 3;
pub const GMarkupError_G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE: GMarkupError = 4;
pub const GMarkupError_G_MARKUP_ERROR_INVALID_CONTENT: GMarkupError = 5;
pub const GMarkupError_G_MARKUP_ERROR_MISSING_ATTRIBUTE: GMarkupError = 6;
#[doc = " GMarkupError:"]
#[doc = " @G_MARKUP_ERROR_BAD_UTF8: text being parsed was not valid UTF-8"]
#[doc = " @G_MARKUP_ERROR_EMPTY: document contained nothing, or only whitespace"]
#[doc = " @G_MARKUP_ERROR_PARSE: document was ill-formed"]
#[doc = " @G_MARKUP_ERROR_UNKNOWN_ELEMENT: error should be set by #GMarkupParser"]
#[doc = "     functions; element wasn't known"]
#[doc = " @G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE: error should be set by #GMarkupParser"]
#[doc = "     functions; attribute wasn't known"]
#[doc = " @G_MARKUP_ERROR_INVALID_CONTENT: error should be set by #GMarkupParser"]
#[doc = "     functions; content was invalid"]
#[doc = " @G_MARKUP_ERROR_MISSING_ATTRIBUTE: error should be set by #GMarkupParser"]
#[doc = "     functions; a required attribute was missing"]
#[doc = ""]
#[doc = " Error codes returned by markup parsing."]
pub type GMarkupError = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_markup_error_quark() -> GQuark;
}
pub const GMarkupParseFlags_G_MARKUP_DO_NOT_USE_THIS_UNSUPPORTED_FLAG: GMarkupParseFlags = 1;
pub const GMarkupParseFlags_G_MARKUP_TREAT_CDATA_AS_TEXT: GMarkupParseFlags = 2;
pub const GMarkupParseFlags_G_MARKUP_PREFIX_ERROR_POSITION: GMarkupParseFlags = 4;
pub const GMarkupParseFlags_G_MARKUP_IGNORE_QUALIFIED: GMarkupParseFlags = 8;
#[doc = " GMarkupParseFlags:"]
#[doc = " @G_MARKUP_DO_NOT_USE_THIS_UNSUPPORTED_FLAG: flag you should not use"]
#[doc = " @G_MARKUP_TREAT_CDATA_AS_TEXT: When this flag is set, CDATA marked"]
#[doc = "     sections are not passed literally to the @passthrough function of"]
#[doc = "     the parser. Instead, the content of the section (without the"]
#[doc = "     `<![CDATA[` and `]]>`) is"]
#[doc = "     passed to the @text function. This flag was added in GLib 2.12"]
#[doc = " @G_MARKUP_PREFIX_ERROR_POSITION: Normally errors caught by GMarkup"]
#[doc = "     itself have line/column information prefixed to them to let the"]
#[doc = "     caller know the location of the error. When this flag is set the"]
#[doc = "     location information is also prefixed to errors generated by the"]
#[doc = "     #GMarkupParser implementation functions"]
#[doc = " @G_MARKUP_IGNORE_QUALIFIED: Ignore (don't report) qualified"]
#[doc = "     attributes and tags, along with their contents.  A qualified"]
#[doc = "     attribute or tag is one that contains ':' in its name (ie: is in"]
#[doc = "     another namespace).  Since: 2.40."]
#[doc = ""]
#[doc = " Flags that affect the behaviour of the parser."]
pub type GMarkupParseFlags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMarkupParseContext {
    _unused: [u8; 0],
}
#[doc = " GMarkupParseContext:"]
#[doc = ""]
#[doc = " A parse context is used to parse a stream of bytes that"]
#[doc = " you expect to contain marked-up text."]
#[doc = ""]
#[doc = " See g_markup_parse_context_new(), #GMarkupParser, and so"]
#[doc = " on for more details."]
pub type GMarkupParseContext = _GMarkupParseContext;
#[doc = " GMarkupParser:"]
#[doc = " @start_element: Callback to invoke when the opening tag of an element"]
#[doc = "     is seen. The callback's @attribute_names and @attribute_values parameters"]
#[doc = "     are %NULL-terminated."]
#[doc = " @end_element: Callback to invoke when the closing tag of an element"]
#[doc = "     is seen. Note that this is also called for empty tags like"]
#[doc = "     `<empty/>`."]
#[doc = " @text: Callback to invoke when some text is seen (text is always"]
#[doc = "     inside an element). Note that the text of an element may be spread"]
#[doc = "     over multiple calls of this function. If the"]
#[doc = "     %G_MARKUP_TREAT_CDATA_AS_TEXT flag is set, this function is also"]
#[doc = "     called for the content of CDATA marked sections."]
#[doc = " @passthrough: Callback to invoke for comments, processing instructions"]
#[doc = "     and doctype declarations; if you're re-writing the parsed document,"]
#[doc = "     write the passthrough text back out in the same position. If the"]
#[doc = "     %G_MARKUP_TREAT_CDATA_AS_TEXT flag is not set, this function is also"]
#[doc = "     called for CDATA marked sections."]
#[doc = " @error: Callback to invoke when an error occurs."]
#[doc = ""]
#[doc = " Any of the fields in #GMarkupParser can be %NULL, in which case they"]
#[doc = " will be ignored. Except for the @error function, any of these callbacks"]
#[doc = " can set an error; in particular the %G_MARKUP_ERROR_UNKNOWN_ELEMENT,"]
#[doc = " %G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE, and %G_MARKUP_ERROR_INVALID_CONTENT"]
#[doc = " errors are intended to be set from these callbacks. If you set an error"]
#[doc = " from a callback, g_markup_parse_context_parse() will report that error"]
#[doc = " back to its caller."]
pub type GMarkupParser = _GMarkupParser;
#[doc = " GMarkupParser:"]
#[doc = " @start_element: Callback to invoke when the opening tag of an element"]
#[doc = "     is seen. The callback's @attribute_names and @attribute_values parameters"]
#[doc = "     are %NULL-terminated."]
#[doc = " @end_element: Callback to invoke when the closing tag of an element"]
#[doc = "     is seen. Note that this is also called for empty tags like"]
#[doc = "     `<empty/>`."]
#[doc = " @text: Callback to invoke when some text is seen (text is always"]
#[doc = "     inside an element). Note that the text of an element may be spread"]
#[doc = "     over multiple calls of this function. If the"]
#[doc = "     %G_MARKUP_TREAT_CDATA_AS_TEXT flag is set, this function is also"]
#[doc = "     called for the content of CDATA marked sections."]
#[doc = " @passthrough: Callback to invoke for comments, processing instructions"]
#[doc = "     and doctype declarations; if you're re-writing the parsed document,"]
#[doc = "     write the passthrough text back out in the same position. If the"]
#[doc = "     %G_MARKUP_TREAT_CDATA_AS_TEXT flag is not set, this function is also"]
#[doc = "     called for CDATA marked sections."]
#[doc = " @error: Callback to invoke when an error occurs."]
#[doc = ""]
#[doc = " Any of the fields in #GMarkupParser can be %NULL, in which case they"]
#[doc = " will be ignored. Except for the @error function, any of these callbacks"]
#[doc = " can set an error; in particular the %G_MARKUP_ERROR_UNKNOWN_ELEMENT,"]
#[doc = " %G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE, and %G_MARKUP_ERROR_INVALID_CONTENT"]
#[doc = " errors are intended to be set from these callbacks. If you set an error"]
#[doc = " from a callback, g_markup_parse_context_parse() will report that error"]
#[doc = " back to its caller."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMarkupParser {
    pub start_element: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GMarkupParseContext,
            element_name: *const gchar,
            attribute_names: *mut *const gchar,
            attribute_values: *mut *const gchar,
            user_data: gpointer,
            error: *mut *mut GError,
        ),
    >,
    pub end_element: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GMarkupParseContext,
            element_name: *const gchar,
            user_data: gpointer,
            error: *mut *mut GError,
        ),
    >,
    pub text: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GMarkupParseContext,
            text: *const gchar,
            text_len: gsize,
            user_data: gpointer,
            error: *mut *mut GError,
        ),
    >,
    pub passthrough: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GMarkupParseContext,
            passthrough_text: *const gchar,
            text_len: gsize,
            user_data: gpointer,
            error: *mut *mut GError,
        ),
    >,
    pub error: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GMarkupParseContext,
            error: *mut GError,
            user_data: gpointer,
        ),
    >,
}
#[test]
fn bindgen_test_layout__GMarkupParser() {
    assert_eq!(
        ::std::mem::size_of::<_GMarkupParser>(),
        40usize,
        concat!("Size of: ", stringify!(_GMarkupParser))
    );
    assert_eq!(
        ::std::mem::align_of::<_GMarkupParser>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMarkupParser))
    );
    fn test_field_start_element() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GMarkupParser>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).start_element) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GMarkupParser),
                "::",
                stringify!(start_element)
            )
        );
    }
    test_field_start_element();
    fn test_field_end_element() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GMarkupParser>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).end_element) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_GMarkupParser),
                "::",
                stringify!(end_element)
            )
        );
    }
    test_field_end_element();
    fn test_field_text() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GMarkupParser>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).text) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_GMarkupParser),
                "::",
                stringify!(text)
            )
        );
    }
    test_field_text();
    fn test_field_passthrough() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GMarkupParser>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).passthrough) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_GMarkupParser),
                "::",
                stringify!(passthrough)
            )
        );
    }
    test_field_passthrough();
    fn test_field_error() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GMarkupParser>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).error) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_GMarkupParser),
                "::",
                stringify!(error)
            )
        );
    }
    test_field_error();
}
extern "C" {
    pub fn g_markup_parse_context_new(
        parser: *const GMarkupParser,
        flags: GMarkupParseFlags,
        user_data: gpointer,
        user_data_dnotify: GDestroyNotify,
    ) -> *mut GMarkupParseContext;
}
extern "C" {
    pub fn g_markup_parse_context_ref(
        context: *mut GMarkupParseContext,
    ) -> *mut GMarkupParseContext;
}
extern "C" {
    pub fn g_markup_parse_context_unref(context: *mut GMarkupParseContext);
}
extern "C" {
    pub fn g_markup_parse_context_free(context: *mut GMarkupParseContext);
}
extern "C" {
    pub fn g_markup_parse_context_parse(
        context: *mut GMarkupParseContext,
        text: *const gchar,
        text_len: gssize,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_markup_parse_context_push(
        context: *mut GMarkupParseContext,
        parser: *const GMarkupParser,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_markup_parse_context_pop(context: *mut GMarkupParseContext) -> gpointer;
}
extern "C" {
    pub fn g_markup_parse_context_end_parse(
        context: *mut GMarkupParseContext,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_markup_parse_context_get_element(context: *mut GMarkupParseContext) -> *const gchar;
}
extern "C" {
    pub fn g_markup_parse_context_get_element_stack(
        context: *mut GMarkupParseContext,
    ) -> *const GSList;
}
extern "C" {
    pub fn g_markup_parse_context_get_position(
        context: *mut GMarkupParseContext,
        line_number: *mut gint,
        char_number: *mut gint,
    );
}
extern "C" {
    pub fn g_markup_parse_context_get_user_data(context: *mut GMarkupParseContext) -> gpointer;
}
extern "C" {
    pub fn g_markup_escape_text(text: *const gchar, length: gssize) -> *mut gchar;
}
extern "C" {
    pub fn g_markup_printf_escaped(format: *const ::std::os::raw::c_char, ...) -> *mut gchar;
}
extern "C" {
    pub fn g_markup_vprintf_escaped(
        format: *const ::std::os::raw::c_char,
        args: va_list,
    ) -> *mut gchar;
}
pub const GMarkupCollectType_G_MARKUP_COLLECT_INVALID: GMarkupCollectType = 0;
pub const GMarkupCollectType_G_MARKUP_COLLECT_STRING: GMarkupCollectType = 1;
pub const GMarkupCollectType_G_MARKUP_COLLECT_STRDUP: GMarkupCollectType = 2;
pub const GMarkupCollectType_G_MARKUP_COLLECT_BOOLEAN: GMarkupCollectType = 3;
pub const GMarkupCollectType_G_MARKUP_COLLECT_TRISTATE: GMarkupCollectType = 4;
pub const GMarkupCollectType_G_MARKUP_COLLECT_OPTIONAL: GMarkupCollectType = 65536;
pub type GMarkupCollectType = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_markup_collect_attributes(
        element_name: *const gchar,
        attribute_names: *mut *const gchar,
        attribute_values: *mut *const gchar,
        error: *mut *mut GError,
        first_type: GMarkupCollectType,
        first_attr: *const gchar,
        ...
    ) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVariantType {
    _unused: [u8; 0],
}
#[doc = " GVariantType:"]
#[doc = ""]
#[doc = " A type in the GVariant type system."]
#[doc = ""]
#[doc = " Two types may not be compared by value; use g_variant_type_equal() or"]
#[doc = " g_variant_type_is_subtype_of().  May be copied using"]
#[doc = " g_variant_type_copy() and freed using g_variant_type_free()."]
pub type GVariantType = _GVariantType;
extern "C" {
    pub fn g_variant_type_string_is_valid(type_string: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_string_scan(
        string: *const gchar,
        limit: *const gchar,
        endptr: *mut *const gchar,
    ) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_free(type_: *mut GVariantType);
}
extern "C" {
    pub fn g_variant_type_copy(type_: *const GVariantType) -> *mut GVariantType;
}
extern "C" {
    pub fn g_variant_type_new(type_string: *const gchar) -> *mut GVariantType;
}
extern "C" {
    pub fn g_variant_type_get_string_length(type_: *const GVariantType) -> gsize;
}
extern "C" {
    pub fn g_variant_type_peek_string(type_: *const GVariantType) -> *const gchar;
}
extern "C" {
    pub fn g_variant_type_dup_string(type_: *const GVariantType) -> *mut gchar;
}
extern "C" {
    pub fn g_variant_type_is_definite(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_is_container(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_is_basic(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_is_maybe(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_is_array(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_is_tuple(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_is_dict_entry(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_is_variant(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_hash(type_: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_variant_type_equal(type1: gconstpointer, type2: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_is_subtype_of(
        type_: *const GVariantType,
        supertype: *const GVariantType,
    ) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_element(type_: *const GVariantType) -> *const GVariantType;
}
extern "C" {
    pub fn g_variant_type_first(type_: *const GVariantType) -> *const GVariantType;
}
extern "C" {
    pub fn g_variant_type_next(type_: *const GVariantType) -> *const GVariantType;
}
extern "C" {
    pub fn g_variant_type_n_items(type_: *const GVariantType) -> gsize;
}
extern "C" {
    pub fn g_variant_type_key(type_: *const GVariantType) -> *const GVariantType;
}
extern "C" {
    pub fn g_variant_type_value(type_: *const GVariantType) -> *const GVariantType;
}
extern "C" {
    pub fn g_variant_type_new_array(element: *const GVariantType) -> *mut GVariantType;
}
extern "C" {
    pub fn g_variant_type_new_maybe(element: *const GVariantType) -> *mut GVariantType;
}
extern "C" {
    pub fn g_variant_type_new_tuple(
        items: *const *const GVariantType,
        length: gint,
    ) -> *mut GVariantType;
}
extern "C" {
    pub fn g_variant_type_new_dict_entry(
        key: *const GVariantType,
        value: *const GVariantType,
    ) -> *mut GVariantType;
}
extern "C" {
    pub fn g_variant_type_checked_(arg1: *const gchar) -> *const GVariantType;
}
extern "C" {
    pub fn g_variant_type_string_get_depth_(type_string: *const gchar) -> gsize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVariant {
    _unused: [u8; 0],
}
pub type GVariant = _GVariant;
pub const GVariantClass_G_VARIANT_CLASS_BOOLEAN: GVariantClass = 98;
pub const GVariantClass_G_VARIANT_CLASS_BYTE: GVariantClass = 121;
pub const GVariantClass_G_VARIANT_CLASS_INT16: GVariantClass = 110;
pub const GVariantClass_G_VARIANT_CLASS_UINT16: GVariantClass = 113;
pub const GVariantClass_G_VARIANT_CLASS_INT32: GVariantClass = 105;
pub const GVariantClass_G_VARIANT_CLASS_UINT32: GVariantClass = 117;
pub const GVariantClass_G_VARIANT_CLASS_INT64: GVariantClass = 120;
pub const GVariantClass_G_VARIANT_CLASS_UINT64: GVariantClass = 116;
pub const GVariantClass_G_VARIANT_CLASS_HANDLE: GVariantClass = 104;
pub const GVariantClass_G_VARIANT_CLASS_DOUBLE: GVariantClass = 100;
pub const GVariantClass_G_VARIANT_CLASS_STRING: GVariantClass = 115;
pub const GVariantClass_G_VARIANT_CLASS_OBJECT_PATH: GVariantClass = 111;
pub const GVariantClass_G_VARIANT_CLASS_SIGNATURE: GVariantClass = 103;
pub const GVariantClass_G_VARIANT_CLASS_VARIANT: GVariantClass = 118;
pub const GVariantClass_G_VARIANT_CLASS_MAYBE: GVariantClass = 109;
pub const GVariantClass_G_VARIANT_CLASS_ARRAY: GVariantClass = 97;
pub const GVariantClass_G_VARIANT_CLASS_TUPLE: GVariantClass = 40;
pub const GVariantClass_G_VARIANT_CLASS_DICT_ENTRY: GVariantClass = 123;
pub type GVariantClass = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_variant_unref(value: *mut GVariant);
}
extern "C" {
    pub fn g_variant_ref(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_ref_sink(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_is_floating(value: *mut GVariant) -> gboolean;
}
extern "C" {
    pub fn g_variant_take_ref(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_get_type(value: *mut GVariant) -> *const GVariantType;
}
extern "C" {
    pub fn g_variant_get_type_string(value: *mut GVariant) -> *const gchar;
}
extern "C" {
    pub fn g_variant_is_of_type(value: *mut GVariant, type_: *const GVariantType) -> gboolean;
}
extern "C" {
    pub fn g_variant_is_container(value: *mut GVariant) -> gboolean;
}
extern "C" {
    pub fn g_variant_classify(value: *mut GVariant) -> GVariantClass;
}
extern "C" {
    pub fn g_variant_new_boolean(value: gboolean) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_byte(value: guint8) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_int16(value: gint16) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_uint16(value: guint16) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_int32(value: gint32) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_uint32(value: guint32) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_int64(value: gint64) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_uint64(value: guint64) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_handle(value: gint32) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_double(value: gdouble) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_string(string: *const gchar) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_take_string(string: *mut gchar) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_printf(format_string: *const gchar, ...) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_object_path(object_path: *const gchar) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_is_object_path(string: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_variant_new_signature(signature: *const gchar) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_is_signature(string: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_variant_new_variant(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_strv(strv: *const *const gchar, length: gssize) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_objv(strv: *const *const gchar, length: gssize) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_bytestring(string: *const gchar) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_bytestring_array(
        strv: *const *const gchar,
        length: gssize,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_fixed_array(
        element_type: *const GVariantType,
        elements: gconstpointer,
        n_elements: gsize,
        element_size: gsize,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_get_boolean(value: *mut GVariant) -> gboolean;
}
extern "C" {
    pub fn g_variant_get_byte(value: *mut GVariant) -> guint8;
}
extern "C" {
    pub fn g_variant_get_int16(value: *mut GVariant) -> gint16;
}
extern "C" {
    pub fn g_variant_get_uint16(value: *mut GVariant) -> guint16;
}
extern "C" {
    pub fn g_variant_get_int32(value: *mut GVariant) -> gint32;
}
extern "C" {
    pub fn g_variant_get_uint32(value: *mut GVariant) -> guint32;
}
extern "C" {
    pub fn g_variant_get_int64(value: *mut GVariant) -> gint64;
}
extern "C" {
    pub fn g_variant_get_uint64(value: *mut GVariant) -> guint64;
}
extern "C" {
    pub fn g_variant_get_handle(value: *mut GVariant) -> gint32;
}
extern "C" {
    pub fn g_variant_get_double(value: *mut GVariant) -> gdouble;
}
extern "C" {
    pub fn g_variant_get_variant(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_get_string(value: *mut GVariant, length: *mut gsize) -> *const gchar;
}
extern "C" {
    pub fn g_variant_dup_string(value: *mut GVariant, length: *mut gsize) -> *mut gchar;
}
extern "C" {
    pub fn g_variant_get_strv(value: *mut GVariant, length: *mut gsize) -> *mut *const gchar;
}
extern "C" {
    pub fn g_variant_dup_strv(value: *mut GVariant, length: *mut gsize) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_variant_get_objv(value: *mut GVariant, length: *mut gsize) -> *mut *const gchar;
}
extern "C" {
    pub fn g_variant_dup_objv(value: *mut GVariant, length: *mut gsize) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_variant_get_bytestring(value: *mut GVariant) -> *const gchar;
}
extern "C" {
    pub fn g_variant_dup_bytestring(value: *mut GVariant, length: *mut gsize) -> *mut gchar;
}
extern "C" {
    pub fn g_variant_get_bytestring_array(
        value: *mut GVariant,
        length: *mut gsize,
    ) -> *mut *const gchar;
}
extern "C" {
    pub fn g_variant_dup_bytestring_array(
        value: *mut GVariant,
        length: *mut gsize,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_variant_new_maybe(
        child_type: *const GVariantType,
        child: *mut GVariant,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_array(
        child_type: *const GVariantType,
        children: *const *mut GVariant,
        n_children: gsize,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_tuple(children: *const *mut GVariant, n_children: gsize) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_dict_entry(key: *mut GVariant, value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_get_maybe(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_n_children(value: *mut GVariant) -> gsize;
}
extern "C" {
    pub fn g_variant_get_child(
        value: *mut GVariant,
        index_: gsize,
        format_string: *const gchar,
        ...
    );
}
extern "C" {
    pub fn g_variant_get_child_value(value: *mut GVariant, index_: gsize) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_lookup(
        dictionary: *mut GVariant,
        key: *const gchar,
        format_string: *const gchar,
        ...
    ) -> gboolean;
}
extern "C" {
    pub fn g_variant_lookup_value(
        dictionary: *mut GVariant,
        key: *const gchar,
        expected_type: *const GVariantType,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_get_fixed_array(
        value: *mut GVariant,
        n_elements: *mut gsize,
        element_size: gsize,
    ) -> gconstpointer;
}
extern "C" {
    pub fn g_variant_get_size(value: *mut GVariant) -> gsize;
}
extern "C" {
    pub fn g_variant_get_data(value: *mut GVariant) -> gconstpointer;
}
extern "C" {
    pub fn g_variant_get_data_as_bytes(value: *mut GVariant) -> *mut GBytes;
}
extern "C" {
    pub fn g_variant_store(value: *mut GVariant, data: gpointer);
}
extern "C" {
    pub fn g_variant_print(value: *mut GVariant, type_annotate: gboolean) -> *mut gchar;
}
extern "C" {
    pub fn g_variant_print_string(
        value: *mut GVariant,
        string: *mut GString,
        type_annotate: gboolean,
    ) -> *mut GString;
}
extern "C" {
    pub fn g_variant_hash(value: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_variant_equal(one: gconstpointer, two: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_variant_get_normal_form(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_is_normal_form(value: *mut GVariant) -> gboolean;
}
extern "C" {
    pub fn g_variant_byteswap(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_from_bytes(
        type_: *const GVariantType,
        bytes: *mut GBytes,
        trusted: gboolean,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_from_data(
        type_: *const GVariantType,
        data: gconstpointer,
        size: gsize,
        trusted: gboolean,
        notify: GDestroyNotify,
        user_data: gpointer,
    ) -> *mut GVariant;
}
pub type GVariantIter = _GVariantIter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVariantIter {
    pub x: [gsize; 16usize],
}
#[test]
fn bindgen_test_layout__GVariantIter() {
    assert_eq!(
        ::std::mem::size_of::<_GVariantIter>(),
        128usize,
        concat!("Size of: ", stringify!(_GVariantIter))
    );
    assert_eq!(
        ::std::mem::align_of::<_GVariantIter>(),
        8usize,
        concat!("Alignment of ", stringify!(_GVariantIter))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GVariantIter>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GVariantIter),
                "::",
                stringify!(x)
            )
        );
    }
    test_field_x();
}
extern "C" {
    pub fn g_variant_iter_new(value: *mut GVariant) -> *mut GVariantIter;
}
extern "C" {
    pub fn g_variant_iter_init(iter: *mut GVariantIter, value: *mut GVariant) -> gsize;
}
extern "C" {
    pub fn g_variant_iter_copy(iter: *mut GVariantIter) -> *mut GVariantIter;
}
extern "C" {
    pub fn g_variant_iter_n_children(iter: *mut GVariantIter) -> gsize;
}
extern "C" {
    pub fn g_variant_iter_free(iter: *mut GVariantIter);
}
extern "C" {
    pub fn g_variant_iter_next_value(iter: *mut GVariantIter) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_iter_next(
        iter: *mut GVariantIter,
        format_string: *const gchar,
        ...
    ) -> gboolean;
}
extern "C" {
    pub fn g_variant_iter_loop(
        iter: *mut GVariantIter,
        format_string: *const gchar,
        ...
    ) -> gboolean;
}
pub type GVariantBuilder = _GVariantBuilder;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GVariantBuilder {
    pub u: _GVariantBuilder__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GVariantBuilder__bindgen_ty_1 {
    pub s: _GVariantBuilder__bindgen_ty_1__bindgen_ty_1,
    pub x: [gsize; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVariantBuilder__bindgen_ty_1__bindgen_ty_1 {
    pub partial_magic: gsize,
    pub type_: *const GVariantType,
    pub y: [gsize; 14usize],
}
#[test]
fn bindgen_test_layout__GVariantBuilder__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_GVariantBuilder__bindgen_ty_1__bindgen_ty_1>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(_GVariantBuilder__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_GVariantBuilder__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_GVariantBuilder__bindgen_ty_1__bindgen_ty_1)
        )
    );
    fn test_field_partial_magic() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_GVariantBuilder__bindgen_ty_1__bindgen_ty_1>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).partial_magic) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GVariantBuilder__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(partial_magic)
            )
        );
    }
    test_field_partial_magic();
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_GVariantBuilder__bindgen_ty_1__bindgen_ty_1>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_GVariantBuilder__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_GVariantBuilder__bindgen_ty_1__bindgen_ty_1>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_GVariantBuilder__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(y)
            )
        );
    }
    test_field_y();
}
#[test]
fn bindgen_test_layout__GVariantBuilder__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_GVariantBuilder__bindgen_ty_1>(),
        128usize,
        concat!("Size of: ", stringify!(_GVariantBuilder__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_GVariantBuilder__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_GVariantBuilder__bindgen_ty_1))
    );
    fn test_field_s() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GVariantBuilder__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).s) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GVariantBuilder__bindgen_ty_1),
                "::",
                stringify!(s)
            )
        );
    }
    test_field_s();
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GVariantBuilder__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GVariantBuilder__bindgen_ty_1),
                "::",
                stringify!(x)
            )
        );
    }
    test_field_x();
}
#[test]
fn bindgen_test_layout__GVariantBuilder() {
    assert_eq!(
        ::std::mem::size_of::<_GVariantBuilder>(),
        128usize,
        concat!("Size of: ", stringify!(_GVariantBuilder))
    );
    assert_eq!(
        ::std::mem::align_of::<_GVariantBuilder>(),
        8usize,
        concat!("Alignment of ", stringify!(_GVariantBuilder))
    );
    fn test_field_u() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GVariantBuilder>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).u) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GVariantBuilder),
                "::",
                stringify!(u)
            )
        );
    }
    test_field_u();
}
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_FAILED: GVariantParseError = 0;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_BASIC_TYPE_EXPECTED: GVariantParseError = 1;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_CANNOT_INFER_TYPE: GVariantParseError = 2;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_DEFINITE_TYPE_EXPECTED: GVariantParseError = 3;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INPUT_NOT_AT_END: GVariantParseError = 4;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INVALID_CHARACTER: GVariantParseError = 5;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INVALID_FORMAT_STRING: GVariantParseError = 6;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INVALID_OBJECT_PATH: GVariantParseError = 7;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INVALID_SIGNATURE: GVariantParseError = 8;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INVALID_TYPE_STRING: GVariantParseError = 9;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_NO_COMMON_TYPE: GVariantParseError = 10;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_NUMBER_OUT_OF_RANGE: GVariantParseError = 11;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_NUMBER_TOO_BIG: GVariantParseError = 12;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_TYPE_ERROR: GVariantParseError = 13;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_UNEXPECTED_TOKEN: GVariantParseError = 14;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_UNKNOWN_KEYWORD: GVariantParseError = 15;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_UNTERMINATED_STRING_CONSTANT:
    GVariantParseError = 16;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_VALUE_EXPECTED: GVariantParseError = 17;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_RECURSION: GVariantParseError = 18;
pub type GVariantParseError = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_variant_parser_get_error_quark() -> GQuark;
}
extern "C" {
    pub fn g_variant_parse_error_quark() -> GQuark;
}
extern "C" {
    pub fn g_variant_builder_new(type_: *const GVariantType) -> *mut GVariantBuilder;
}
extern "C" {
    pub fn g_variant_builder_unref(builder: *mut GVariantBuilder);
}
extern "C" {
    pub fn g_variant_builder_ref(builder: *mut GVariantBuilder) -> *mut GVariantBuilder;
}
extern "C" {
    pub fn g_variant_builder_init(builder: *mut GVariantBuilder, type_: *const GVariantType);
}
extern "C" {
    pub fn g_variant_builder_end(builder: *mut GVariantBuilder) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_builder_clear(builder: *mut GVariantBuilder);
}
extern "C" {
    pub fn g_variant_builder_open(builder: *mut GVariantBuilder, type_: *const GVariantType);
}
extern "C" {
    pub fn g_variant_builder_close(builder: *mut GVariantBuilder);
}
extern "C" {
    pub fn g_variant_builder_add_value(builder: *mut GVariantBuilder, value: *mut GVariant);
}
extern "C" {
    pub fn g_variant_builder_add(builder: *mut GVariantBuilder, format_string: *const gchar, ...);
}
extern "C" {
    pub fn g_variant_builder_add_parsed(builder: *mut GVariantBuilder, format: *const gchar, ...);
}
extern "C" {
    pub fn g_variant_new(format_string: *const gchar, ...) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_get(value: *mut GVariant, format_string: *const gchar, ...);
}
extern "C" {
    pub fn g_variant_new_va(
        format_string: *const gchar,
        endptr: *mut *const gchar,
        app: *mut va_list,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_get_va(
        value: *mut GVariant,
        format_string: *const gchar,
        endptr: *mut *const gchar,
        app: *mut va_list,
    );
}
extern "C" {
    pub fn g_variant_check_format_string(
        value: *mut GVariant,
        format_string: *const gchar,
        copy_only: gboolean,
    ) -> gboolean;
}
extern "C" {
    pub fn g_variant_parse(
        type_: *const GVariantType,
        text: *const gchar,
        limit: *const gchar,
        endptr: *mut *const gchar,
        error: *mut *mut GError,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_parsed(format: *const gchar, ...) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_parsed_va(format: *const gchar, app: *mut va_list) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_parse_error_print_context(
        error: *mut GError,
        source_str: *const gchar,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_variant_compare(one: gconstpointer, two: gconstpointer) -> gint;
}
pub type GVariantDict = _GVariantDict;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GVariantDict {
    pub u: _GVariantDict__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GVariantDict__bindgen_ty_1 {
    pub s: _GVariantDict__bindgen_ty_1__bindgen_ty_1,
    pub x: [gsize; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVariantDict__bindgen_ty_1__bindgen_ty_1 {
    pub asv: *mut GVariant,
    pub partial_magic: gsize,
    pub y: [gsize; 14usize],
}
#[test]
fn bindgen_test_layout__GVariantDict__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_GVariantDict__bindgen_ty_1__bindgen_ty_1>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(_GVariantDict__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_GVariantDict__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_GVariantDict__bindgen_ty_1__bindgen_ty_1)
        )
    );
    fn test_field_asv() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_GVariantDict__bindgen_ty_1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).asv) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GVariantDict__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(asv)
            )
        );
    }
    test_field_asv();
    fn test_field_partial_magic() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_GVariantDict__bindgen_ty_1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).partial_magic) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_GVariantDict__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(partial_magic)
            )
        );
    }
    test_field_partial_magic();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_GVariantDict__bindgen_ty_1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_GVariantDict__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(y)
            )
        );
    }
    test_field_y();
}
#[test]
fn bindgen_test_layout__GVariantDict__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_GVariantDict__bindgen_ty_1>(),
        128usize,
        concat!("Size of: ", stringify!(_GVariantDict__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_GVariantDict__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_GVariantDict__bindgen_ty_1))
    );
    fn test_field_s() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GVariantDict__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).s) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GVariantDict__bindgen_ty_1),
                "::",
                stringify!(s)
            )
        );
    }
    test_field_s();
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GVariantDict__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GVariantDict__bindgen_ty_1),
                "::",
                stringify!(x)
            )
        );
    }
    test_field_x();
}
#[test]
fn bindgen_test_layout__GVariantDict() {
    assert_eq!(
        ::std::mem::size_of::<_GVariantDict>(),
        128usize,
        concat!("Size of: ", stringify!(_GVariantDict))
    );
    assert_eq!(
        ::std::mem::align_of::<_GVariantDict>(),
        8usize,
        concat!("Alignment of ", stringify!(_GVariantDict))
    );
    fn test_field_u() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GVariantDict>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).u) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GVariantDict),
                "::",
                stringify!(u)
            )
        );
    }
    test_field_u();
}
extern "C" {
    pub fn g_variant_dict_new(from_asv: *mut GVariant) -> *mut GVariantDict;
}
extern "C" {
    pub fn g_variant_dict_init(dict: *mut GVariantDict, from_asv: *mut GVariant);
}
extern "C" {
    pub fn g_variant_dict_lookup(
        dict: *mut GVariantDict,
        key: *const gchar,
        format_string: *const gchar,
        ...
    ) -> gboolean;
}
extern "C" {
    pub fn g_variant_dict_lookup_value(
        dict: *mut GVariantDict,
        key: *const gchar,
        expected_type: *const GVariantType,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_dict_contains(dict: *mut GVariantDict, key: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_variant_dict_insert(
        dict: *mut GVariantDict,
        key: *const gchar,
        format_string: *const gchar,
        ...
    );
}
extern "C" {
    pub fn g_variant_dict_insert_value(
        dict: *mut GVariantDict,
        key: *const gchar,
        value: *mut GVariant,
    );
}
extern "C" {
    pub fn g_variant_dict_remove(dict: *mut GVariantDict, key: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_variant_dict_clear(dict: *mut GVariantDict);
}
extern "C" {
    pub fn g_variant_dict_end(dict: *mut GVariantDict) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_dict_ref(dict: *mut GVariantDict) -> *mut GVariantDict;
}
extern "C" {
    pub fn g_variant_dict_unref(dict: *mut GVariantDict);
}
extern "C" {
    pub fn g_printf_string_upper_bound(format: *const gchar, args: va_list) -> gsize;
}
pub const GLogLevelFlags_G_LOG_FLAG_RECURSION: GLogLevelFlags = 1;
pub const GLogLevelFlags_G_LOG_FLAG_FATAL: GLogLevelFlags = 2;
pub const GLogLevelFlags_G_LOG_LEVEL_ERROR: GLogLevelFlags = 4;
pub const GLogLevelFlags_G_LOG_LEVEL_CRITICAL: GLogLevelFlags = 8;
pub const GLogLevelFlags_G_LOG_LEVEL_WARNING: GLogLevelFlags = 16;
pub const GLogLevelFlags_G_LOG_LEVEL_MESSAGE: GLogLevelFlags = 32;
pub const GLogLevelFlags_G_LOG_LEVEL_INFO: GLogLevelFlags = 64;
pub const GLogLevelFlags_G_LOG_LEVEL_DEBUG: GLogLevelFlags = 128;
pub const GLogLevelFlags_G_LOG_LEVEL_MASK: GLogLevelFlags = -4;
pub type GLogLevelFlags = ::std::os::raw::c_int;
pub type GLogFunc = ::std::option::Option<
    unsafe extern "C" fn(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        message: *const gchar,
        user_data: gpointer,
    ),
>;
extern "C" {
    pub fn g_log_set_handler(
        log_domain: *const gchar,
        log_levels: GLogLevelFlags,
        log_func: GLogFunc,
        user_data: gpointer,
    ) -> guint;
}
extern "C" {
    pub fn g_log_set_handler_full(
        log_domain: *const gchar,
        log_levels: GLogLevelFlags,
        log_func: GLogFunc,
        user_data: gpointer,
        destroy: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    pub fn g_log_remove_handler(log_domain: *const gchar, handler_id: guint);
}
extern "C" {
    pub fn g_log_default_handler(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        message: *const gchar,
        unused_data: gpointer,
    );
}
extern "C" {
    pub fn g_log_set_default_handler(log_func: GLogFunc, user_data: gpointer) -> GLogFunc;
}
extern "C" {
    pub fn g_log(log_domain: *const gchar, log_level: GLogLevelFlags, format: *const gchar, ...);
}
extern "C" {
    pub fn g_logv(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        format: *const gchar,
        args: va_list,
    );
}
extern "C" {
    pub fn g_log_set_fatal_mask(
        log_domain: *const gchar,
        fatal_mask: GLogLevelFlags,
    ) -> GLogLevelFlags;
}
extern "C" {
    pub fn g_log_set_always_fatal(fatal_mask: GLogLevelFlags) -> GLogLevelFlags;
}
pub const GLogWriterOutput_G_LOG_WRITER_HANDLED: GLogWriterOutput = 1;
pub const GLogWriterOutput_G_LOG_WRITER_UNHANDLED: GLogWriterOutput = 0;
#[doc = " GLogWriterOutput:"]
#[doc = " @G_LOG_WRITER_HANDLED: Log writer has handled the log entry."]
#[doc = " @G_LOG_WRITER_UNHANDLED: Log writer could not handle the log entry."]
#[doc = ""]
#[doc = " Return values from #GLogWriterFuncs to indicate whether the given log entry"]
#[doc = " was successfully handled by the writer, or whether there was an error in"]
#[doc = " handling it (and hence a fallback writer should be used)."]
#[doc = ""]
#[doc = " If a #GLogWriterFunc ignores a log entry, it should return"]
#[doc = " %G_LOG_WRITER_HANDLED."]
#[doc = ""]
#[doc = " Since: 2.50"]
pub type GLogWriterOutput = ::std::os::raw::c_uint;
#[doc = " GLogField:"]
#[doc = " @key: field name (UTF-8 string)"]
#[doc = " @value: field value (arbitrary bytes)"]
#[doc = " @length: length of @value, in bytes, or -1 if it is nul-terminated"]
#[doc = ""]
#[doc = " Structure representing a single field in a structured log entry. See"]
#[doc = " g_log_structured() for details."]
#[doc = ""]
#[doc = " Log fields may contain arbitrary values, including binary with embedded nul"]
#[doc = " bytes. If the field contains a string, the string must be UTF-8 encoded and"]
#[doc = " have a trailing nul byte. Otherwise, @length must be set to a non-negative"]
#[doc = " value."]
#[doc = ""]
#[doc = " Since: 2.50"]
pub type GLogField = _GLogField;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GLogField {
    pub key: *const gchar,
    pub value: gconstpointer,
    pub length: gssize,
}
#[test]
fn bindgen_test_layout__GLogField() {
    assert_eq!(
        ::std::mem::size_of::<_GLogField>(),
        24usize,
        concat!("Size of: ", stringify!(_GLogField))
    );
    assert_eq!(
        ::std::mem::align_of::<_GLogField>(),
        8usize,
        concat!("Alignment of ", stringify!(_GLogField))
    );
    fn test_field_key() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GLogField>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GLogField),
                "::",
                stringify!(key)
            )
        );
    }
    test_field_key();
    fn test_field_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GLogField>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_GLogField),
                "::",
                stringify!(value)
            )
        );
    }
    test_field_value();
    fn test_field_length() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GLogField>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_GLogField),
                "::",
                stringify!(length)
            )
        );
    }
    test_field_length();
}
#[doc = " GLogWriterFunc:"]
#[doc = " @log_level: log level of the message"]
#[doc = " @fields: (array length=n_fields): fields forming the message"]
#[doc = " @n_fields: number of @fields"]
#[doc = " @user_data: user data passed to g_log_set_writer_func()"]
#[doc = ""]
#[doc = " Writer function for log entries. A log entry is a collection of one or more"]
#[doc = " #GLogFields, using the standard [field names from journal"]
#[doc = " specification](https://www.freedesktop.org/software/systemd/man/systemd.journal-fields.html)."]
#[doc = " See g_log_structured() for more information."]
#[doc = ""]
#[doc = " Writer functions must ignore fields which they do not recognise, unless they"]
#[doc = " can write arbitrary binary output, as field values may be arbitrary binary."]
#[doc = ""]
#[doc = " @log_level is guaranteed to be included in @fields as the `PRIORITY` field,"]
#[doc = " but is provided separately for convenience of deciding whether or where to"]
#[doc = " output the log entry."]
#[doc = ""]
#[doc = " Writer functions should return %G_LOG_WRITER_HANDLED if they handled the log"]
#[doc = " message successfully or if they deliberately ignored it. If there was an"]
#[doc = " error handling the message (for example, if the writer function is meant to"]
#[doc = " send messages to a remote logging server and there is a network error), it"]
#[doc = " should return %G_LOG_WRITER_UNHANDLED. This allows writer functions to be"]
#[doc = " chained and fall back to simpler handlers in case of failure."]
#[doc = ""]
#[doc = " Returns: %G_LOG_WRITER_HANDLED if the log entry was handled successfully;"]
#[doc = "    %G_LOG_WRITER_UNHANDLED otherwise"]
#[doc = " Since: 2.50"]
pub type GLogWriterFunc = ::std::option::Option<
    unsafe extern "C" fn(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
        user_data: gpointer,
    ) -> GLogWriterOutput,
>;
extern "C" {
    pub fn g_log_structured(log_domain: *const gchar, log_level: GLogLevelFlags, ...);
}
extern "C" {
    pub fn g_log_structured_array(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
    );
}
extern "C" {
    pub fn g_log_variant(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        fields: *mut GVariant,
    );
}
extern "C" {
    pub fn g_log_set_writer_func(
        func: GLogWriterFunc,
        user_data: gpointer,
        user_data_free: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_log_writer_supports_color(output_fd: gint) -> gboolean;
}
extern "C" {
    pub fn g_log_writer_is_journald(output_fd: gint) -> gboolean;
}
extern "C" {
    pub fn g_log_writer_format_fields(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
        use_color: gboolean,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_log_writer_journald(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
        user_data: gpointer,
    ) -> GLogWriterOutput;
}
extern "C" {
    pub fn g_log_writer_standard_streams(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
        user_data: gpointer,
    ) -> GLogWriterOutput;
}
extern "C" {
    pub fn g_log_writer_default(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
        user_data: gpointer,
    ) -> GLogWriterOutput;
}
extern "C" {
    pub fn _g_log_fallback_handler(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        message: *const gchar,
        unused_data: gpointer,
    );
}
extern "C" {
    pub fn g_return_if_fail_warning(
        log_domain: *const ::std::os::raw::c_char,
        pretty_function: *const ::std::os::raw::c_char,
        expression: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_warn_message(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        warnexpr: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_assert_warning(
        log_domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        pretty_function: *const ::std::os::raw::c_char,
        expression: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_log_structured_standard(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        file: *const gchar,
        line: *const gchar,
        func: *const gchar,
        message_format: *const gchar,
        ...
    );
}
#[doc = " GPrintFunc:"]
#[doc = " @string: the message to output"]
#[doc = ""]
#[doc = " Specifies the type of the print handler functions."]
#[doc = " These are called with the complete formatted string to output."]
pub type GPrintFunc = ::std::option::Option<unsafe extern "C" fn(string: *const gchar)>;
extern "C" {
    pub fn g_print(format: *const gchar, ...);
}
extern "C" {
    pub fn g_set_print_handler(func: GPrintFunc) -> GPrintFunc;
}
extern "C" {
    pub fn g_printerr(format: *const gchar, ...);
}
extern "C" {
    pub fn g_set_printerr_handler(func: GPrintFunc) -> GPrintFunc;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GOptionContext {
    _unused: [u8; 0],
}
#[doc = " GOptionContext:"]
#[doc = ""]
#[doc = " A `GOptionContext` struct defines which options"]
#[doc = " are accepted by the commandline option parser. The struct has only private"]
#[doc = " fields and should not be directly accessed."]
pub type GOptionContext = _GOptionContext;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GOptionGroup {
    _unused: [u8; 0],
}
#[doc = " GOptionGroup:"]
#[doc = ""]
#[doc = " A `GOptionGroup` struct defines the options in a single"]
#[doc = " group. The struct has only private fields and should not be directly accessed."]
#[doc = ""]
#[doc = " All options in a group share the same translation function. Libraries which"]
#[doc = " need to parse commandline options are expected to provide a function for"]
#[doc = " getting a `GOptionGroup` holding their options, which"]
#[doc = " the application can then add to its #GOptionContext."]
pub type GOptionGroup = _GOptionGroup;
#[doc = " GOptionEntry:"]
#[doc = " @long_name: The long name of an option can be used to specify it"]
#[doc = "     in a commandline as `--long_name`. Every option must have a"]
#[doc = "     long name. To resolve conflicts if multiple option groups contain"]
#[doc = "     the same long name, it is also possible to specify the option as"]
#[doc = "     `--groupname-long_name`."]
#[doc = " @short_name: If an option has a short name, it can be specified"]
#[doc = "     `-short_name` in a commandline. @short_name must be  a printable"]
#[doc = "     ASCII character different from '-', or zero if the option has no"]
#[doc = "     short name."]
#[doc = " @flags: Flags from #GOptionFlags"]
#[doc = " @arg: The type of the option, as a #GOptionArg"]
#[doc = " @arg_data: If the @arg type is %G_OPTION_ARG_CALLBACK, then @arg_data"]
#[doc = "     must point to a #GOptionArgFunc callback function, which will be"]
#[doc = "     called to handle the extra argument. Otherwise, @arg_data is a"]
#[doc = "     pointer to a location to store the value, the required type of"]
#[doc = "     the location depends on the @arg type:"]
#[doc = "     - %G_OPTION_ARG_NONE: %gboolean"]
#[doc = "     - %G_OPTION_ARG_STRING: %gchar*"]
#[doc = "     - %G_OPTION_ARG_INT: %gint"]
#[doc = "     - %G_OPTION_ARG_FILENAME: %gchar*"]
#[doc = "     - %G_OPTION_ARG_STRING_ARRAY: %gchar**"]
#[doc = "     - %G_OPTION_ARG_FILENAME_ARRAY: %gchar**"]
#[doc = "     - %G_OPTION_ARG_DOUBLE: %gdouble"]
#[doc = "     If @arg type is %G_OPTION_ARG_STRING or %G_OPTION_ARG_FILENAME,"]
#[doc = "     the location will contain a newly allocated string if the option"]
#[doc = "     was given. That string needs to be freed by the callee using g_free()."]
#[doc = "     Likewise if @arg type is %G_OPTION_ARG_STRING_ARRAY or"]
#[doc = "     %G_OPTION_ARG_FILENAME_ARRAY, the data should be freed using g_strfreev()."]
#[doc = " @description: the description for the option in `--help`"]
#[doc = "     output. The @description is translated using the @translate_func"]
#[doc = "     of the group, see g_option_group_set_translation_domain()."]
#[doc = " @arg_description: The placeholder to use for the extra argument parsed"]
#[doc = "     by the option in `--help` output. The @arg_description is translated"]
#[doc = "     using the @translate_func of the group, see"]
#[doc = "     g_option_group_set_translation_domain()."]
#[doc = ""]
#[doc = " A GOptionEntry struct defines a single option. To have an effect, they"]
#[doc = " must be added to a #GOptionGroup with g_option_context_add_main_entries()"]
#[doc = " or g_option_group_add_entries()."]
pub type GOptionEntry = _GOptionEntry;
pub const GOptionFlags_G_OPTION_FLAG_NONE: GOptionFlags = 0;
pub const GOptionFlags_G_OPTION_FLAG_HIDDEN: GOptionFlags = 1;
pub const GOptionFlags_G_OPTION_FLAG_IN_MAIN: GOptionFlags = 2;
pub const GOptionFlags_G_OPTION_FLAG_REVERSE: GOptionFlags = 4;
pub const GOptionFlags_G_OPTION_FLAG_NO_ARG: GOptionFlags = 8;
pub const GOptionFlags_G_OPTION_FLAG_FILENAME: GOptionFlags = 16;
pub const GOptionFlags_G_OPTION_FLAG_OPTIONAL_ARG: GOptionFlags = 32;
pub const GOptionFlags_G_OPTION_FLAG_NOALIAS: GOptionFlags = 64;
#[doc = " GOptionFlags:"]
#[doc = " @G_OPTION_FLAG_NONE: No flags. Since: 2.42."]
#[doc = " @G_OPTION_FLAG_HIDDEN: The option doesn't appear in `--help` output."]
#[doc = " @G_OPTION_FLAG_IN_MAIN: The option appears in the main section of the"]
#[doc = "     `--help` output, even if it is defined in a group."]
#[doc = " @G_OPTION_FLAG_REVERSE: For options of the %G_OPTION_ARG_NONE kind, this"]
#[doc = "     flag indicates that the sense of the option is reversed."]
#[doc = " @G_OPTION_FLAG_NO_ARG: For options of the %G_OPTION_ARG_CALLBACK kind,"]
#[doc = "     this flag indicates that the callback does not take any argument"]
#[doc = "     (like a %G_OPTION_ARG_NONE option). Since 2.8"]
#[doc = " @G_OPTION_FLAG_FILENAME: For options of the %G_OPTION_ARG_CALLBACK"]
#[doc = "     kind, this flag indicates that the argument should be passed to the"]
#[doc = "     callback in the GLib filename encoding rather than UTF-8. Since 2.8"]
#[doc = " @G_OPTION_FLAG_OPTIONAL_ARG: For options of the %G_OPTION_ARG_CALLBACK"]
#[doc = "     kind, this flag indicates that the argument supply is optional."]
#[doc = "     If no argument is given then data of %GOptionParseFunc will be"]
#[doc = "     set to NULL. Since 2.8"]
#[doc = " @G_OPTION_FLAG_NOALIAS: This flag turns off the automatic conflict"]
#[doc = "     resolution which prefixes long option names with `groupname-` if"]
#[doc = "     there is a conflict. This option should only be used in situations"]
#[doc = "     where aliasing is necessary to model some legacy commandline interface."]
#[doc = "     It is not safe to use this option, unless all option groups are under"]
#[doc = "     your direct control. Since 2.8."]
#[doc = ""]
#[doc = " Flags which modify individual options."]
pub type GOptionFlags = ::std::os::raw::c_uint;
pub const GOptionArg_G_OPTION_ARG_NONE: GOptionArg = 0;
pub const GOptionArg_G_OPTION_ARG_STRING: GOptionArg = 1;
pub const GOptionArg_G_OPTION_ARG_INT: GOptionArg = 2;
pub const GOptionArg_G_OPTION_ARG_CALLBACK: GOptionArg = 3;
pub const GOptionArg_G_OPTION_ARG_FILENAME: GOptionArg = 4;
pub const GOptionArg_G_OPTION_ARG_STRING_ARRAY: GOptionArg = 5;
pub const GOptionArg_G_OPTION_ARG_FILENAME_ARRAY: GOptionArg = 6;
pub const GOptionArg_G_OPTION_ARG_DOUBLE: GOptionArg = 7;
pub const GOptionArg_G_OPTION_ARG_INT64: GOptionArg = 8;
#[doc = " GOptionArg:"]
#[doc = " @G_OPTION_ARG_NONE: No extra argument. This is useful for simple flags."]
#[doc = " @G_OPTION_ARG_STRING: The option takes a UTF-8 string argument."]
#[doc = " @G_OPTION_ARG_INT: The option takes an integer argument."]
#[doc = " @G_OPTION_ARG_CALLBACK: The option provides a callback (of type"]
#[doc = "     #GOptionArgFunc) to parse the extra argument."]
#[doc = " @G_OPTION_ARG_FILENAME: The option takes a filename as argument, which will"]
#[doc = "be in the GLib filename encoding rather than UTF-8."]
#[doc = " @G_OPTION_ARG_STRING_ARRAY: The option takes a string argument, multiple"]
#[doc = "     uses of the option are collected into an array of strings."]
#[doc = " @G_OPTION_ARG_FILENAME_ARRAY: The option takes a filename as argument,"]
#[doc = "     multiple uses of the option are collected into an array of strings."]
#[doc = " @G_OPTION_ARG_DOUBLE: The option takes a double argument. The argument"]
#[doc = "     can be formatted either for the user's locale or for the \"C\" locale."]
#[doc = "     Since 2.12"]
#[doc = " @G_OPTION_ARG_INT64: The option takes a 64-bit integer. Like"]
#[doc = "     %G_OPTION_ARG_INT but for larger numbers. The number can be in"]
#[doc = "     decimal base, or in hexadecimal (when prefixed with `0x`, for"]
#[doc = "     example, `0xffffffff`). Since 2.12"]
#[doc = ""]
#[doc = " The #GOptionArg enum values determine which type of extra argument the"]
#[doc = " options expect to find. If an option expects an extra argument, it can"]
#[doc = " be specified in several ways; with a short option: `-x arg`, with a long"]
#[doc = " option: `--name arg` or combined in a single argument: `--name=arg`."]
pub type GOptionArg = ::std::os::raw::c_uint;
#[doc = " GOptionArgFunc:"]
#[doc = " @option_name: The name of the option being parsed. This will be either a"]
#[doc = "  single dash followed by a single letter (for a short name) or two dashes"]
#[doc = "  followed by a long option name."]
#[doc = " @value: The value to be parsed."]
#[doc = " @data: User data added to the #GOptionGroup containing the option when it"]
#[doc = "  was created with g_option_group_new()"]
#[doc = " @error: A return location for errors. The error code %G_OPTION_ERROR_FAILED"]
#[doc = "  is intended to be used for errors in #GOptionArgFunc callbacks."]
#[doc = ""]
#[doc = " The type of function to be passed as callback for %G_OPTION_ARG_CALLBACK"]
#[doc = " options."]
#[doc = ""]
#[doc = " Returns: %TRUE if the option was successfully parsed, %FALSE if an error"]
#[doc = "  occurred, in which case @error should be set with g_set_error()"]
pub type GOptionArgFunc = ::std::option::Option<
    unsafe extern "C" fn(
        option_name: *const gchar,
        value: *const gchar,
        data: gpointer,
        error: *mut *mut GError,
    ) -> gboolean,
>;
#[doc = " GOptionParseFunc:"]
#[doc = " @context: The active #GOptionContext"]
#[doc = " @group: The group to which the function belongs"]
#[doc = " @data: User data added to the #GOptionGroup containing the option when it"]
#[doc = "  was created with g_option_group_new()"]
#[doc = " @error: A return location for error details"]
#[doc = ""]
#[doc = " The type of function that can be called before and after parsing."]
#[doc = ""]
#[doc = " Returns: %TRUE if the function completed successfully, %FALSE if an error"]
#[doc = "  occurred, in which case @error should be set with g_set_error()"]
pub type GOptionParseFunc = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut GOptionContext,
        group: *mut GOptionGroup,
        data: gpointer,
        error: *mut *mut GError,
    ) -> gboolean,
>;
#[doc = " GOptionErrorFunc:"]
#[doc = " @context: The active #GOptionContext"]
#[doc = " @group: The group to which the function belongs"]
#[doc = " @data: User data added to the #GOptionGroup containing the option when it"]
#[doc = "  was created with g_option_group_new()"]
#[doc = " @error: The #GError containing details about the parse error"]
#[doc = ""]
#[doc = " The type of function to be used as callback when a parse error occurs."]
pub type GOptionErrorFunc = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut GOptionContext,
        group: *mut GOptionGroup,
        data: gpointer,
        error: *mut *mut GError,
    ),
>;
pub const GOptionError_G_OPTION_ERROR_UNKNOWN_OPTION: GOptionError = 0;
pub const GOptionError_G_OPTION_ERROR_BAD_VALUE: GOptionError = 1;
pub const GOptionError_G_OPTION_ERROR_FAILED: GOptionError = 2;
#[doc = " GOptionError:"]
#[doc = " @G_OPTION_ERROR_UNKNOWN_OPTION: An option was not known to the parser."]
#[doc = "  This error will only be reported, if the parser hasn't been instructed"]
#[doc = "  to ignore unknown options, see g_option_context_set_ignore_unknown_options()."]
#[doc = " @G_OPTION_ERROR_BAD_VALUE: A value couldn't be parsed."]
#[doc = " @G_OPTION_ERROR_FAILED: A #GOptionArgFunc callback failed."]
#[doc = ""]
#[doc = " Error codes returned by option parsing."]
pub type GOptionError = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_option_error_quark() -> GQuark;
}
#[doc = " GOptionEntry:"]
#[doc = " @long_name: The long name of an option can be used to specify it"]
#[doc = "     in a commandline as `--long_name`. Every option must have a"]
#[doc = "     long name. To resolve conflicts if multiple option groups contain"]
#[doc = "     the same long name, it is also possible to specify the option as"]
#[doc = "     `--groupname-long_name`."]
#[doc = " @short_name: If an option has a short name, it can be specified"]
#[doc = "     `-short_name` in a commandline. @short_name must be  a printable"]
#[doc = "     ASCII character different from '-', or zero if the option has no"]
#[doc = "     short name."]
#[doc = " @flags: Flags from #GOptionFlags"]
#[doc = " @arg: The type of the option, as a #GOptionArg"]
#[doc = " @arg_data: If the @arg type is %G_OPTION_ARG_CALLBACK, then @arg_data"]
#[doc = "     must point to a #GOptionArgFunc callback function, which will be"]
#[doc = "     called to handle the extra argument. Otherwise, @arg_data is a"]
#[doc = "     pointer to a location to store the value, the required type of"]
#[doc = "     the location depends on the @arg type:"]
#[doc = "     - %G_OPTION_ARG_NONE: %gboolean"]
#[doc = "     - %G_OPTION_ARG_STRING: %gchar*"]
#[doc = "     - %G_OPTION_ARG_INT: %gint"]
#[doc = "     - %G_OPTION_ARG_FILENAME: %gchar*"]
#[doc = "     - %G_OPTION_ARG_STRING_ARRAY: %gchar**"]
#[doc = "     - %G_OPTION_ARG_FILENAME_ARRAY: %gchar**"]
#[doc = "     - %G_OPTION_ARG_DOUBLE: %gdouble"]
#[doc = "     If @arg type is %G_OPTION_ARG_STRING or %G_OPTION_ARG_FILENAME,"]
#[doc = "     the location will contain a newly allocated string if the option"]
#[doc = "     was given. That string needs to be freed by the callee using g_free()."]
#[doc = "     Likewise if @arg type is %G_OPTION_ARG_STRING_ARRAY or"]
#[doc = "     %G_OPTION_ARG_FILENAME_ARRAY, the data should be freed using g_strfreev()."]
#[doc = " @description: the description for the option in `--help`"]
#[doc = "     output. The @description is translated using the @translate_func"]
#[doc = "     of the group, see g_option_group_set_translation_domain()."]
#[doc = " @arg_description: The placeholder to use for the extra argument parsed"]
#[doc = "     by the option in `--help` output. The @arg_description is translated"]
#[doc = "     using the @translate_func of the group, see"]
#[doc = "     g_option_group_set_translation_domain()."]
#[doc = ""]
#[doc = " A GOptionEntry struct defines a single option. To have an effect, they"]
#[doc = " must be added to a #GOptionGroup with g_option_context_add_main_entries()"]
#[doc = " or g_option_group_add_entries()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GOptionEntry {
    pub long_name: *const gchar,
    pub short_name: gchar,
    pub flags: gint,
    pub arg: GOptionArg,
    pub arg_data: gpointer,
    pub description: *const gchar,
    pub arg_description: *const gchar,
}
#[test]
fn bindgen_test_layout__GOptionEntry() {
    assert_eq!(
        ::std::mem::size_of::<_GOptionEntry>(),
        48usize,
        concat!("Size of: ", stringify!(_GOptionEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<_GOptionEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(_GOptionEntry))
    );
    fn test_field_long_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GOptionEntry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).long_name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GOptionEntry),
                "::",
                stringify!(long_name)
            )
        );
    }
    test_field_long_name();
    fn test_field_short_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GOptionEntry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).short_name) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_GOptionEntry),
                "::",
                stringify!(short_name)
            )
        );
    }
    test_field_short_name();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GOptionEntry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_GOptionEntry),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_arg() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GOptionEntry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).arg) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_GOptionEntry),
                "::",
                stringify!(arg)
            )
        );
    }
    test_field_arg();
    fn test_field_arg_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GOptionEntry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).arg_data) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_GOptionEntry),
                "::",
                stringify!(arg_data)
            )
        );
    }
    test_field_arg_data();
    fn test_field_description() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GOptionEntry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).description) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_GOptionEntry),
                "::",
                stringify!(description)
            )
        );
    }
    test_field_description();
    fn test_field_arg_description() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GOptionEntry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).arg_description) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_GOptionEntry),
                "::",
                stringify!(arg_description)
            )
        );
    }
    test_field_arg_description();
}
extern "C" {
    pub fn g_option_context_new(parameter_string: *const gchar) -> *mut GOptionContext;
}
extern "C" {
    pub fn g_option_context_set_summary(context: *mut GOptionContext, summary: *const gchar);
}
extern "C" {
    pub fn g_option_context_get_summary(context: *mut GOptionContext) -> *const gchar;
}
extern "C" {
    pub fn g_option_context_set_description(
        context: *mut GOptionContext,
        description: *const gchar,
    );
}
extern "C" {
    pub fn g_option_context_get_description(context: *mut GOptionContext) -> *const gchar;
}
extern "C" {
    pub fn g_option_context_free(context: *mut GOptionContext);
}
extern "C" {
    pub fn g_option_context_set_help_enabled(context: *mut GOptionContext, help_enabled: gboolean);
}
extern "C" {
    pub fn g_option_context_get_help_enabled(context: *mut GOptionContext) -> gboolean;
}
extern "C" {
    pub fn g_option_context_set_ignore_unknown_options(
        context: *mut GOptionContext,
        ignore_unknown: gboolean,
    );
}
extern "C" {
    pub fn g_option_context_get_ignore_unknown_options(context: *mut GOptionContext) -> gboolean;
}
extern "C" {
    pub fn g_option_context_set_strict_posix(context: *mut GOptionContext, strict_posix: gboolean);
}
extern "C" {
    pub fn g_option_context_get_strict_posix(context: *mut GOptionContext) -> gboolean;
}
extern "C" {
    pub fn g_option_context_add_main_entries(
        context: *mut GOptionContext,
        entries: *const GOptionEntry,
        translation_domain: *const gchar,
    );
}
extern "C" {
    pub fn g_option_context_parse(
        context: *mut GOptionContext,
        argc: *mut gint,
        argv: *mut *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_option_context_parse_strv(
        context: *mut GOptionContext,
        arguments: *mut *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_option_context_set_translate_func(
        context: *mut GOptionContext,
        func: GTranslateFunc,
        data: gpointer,
        destroy_notify: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_option_context_set_translation_domain(
        context: *mut GOptionContext,
        domain: *const gchar,
    );
}
extern "C" {
    pub fn g_option_context_add_group(context: *mut GOptionContext, group: *mut GOptionGroup);
}
extern "C" {
    pub fn g_option_context_set_main_group(context: *mut GOptionContext, group: *mut GOptionGroup);
}
extern "C" {
    pub fn g_option_context_get_main_group(context: *mut GOptionContext) -> *mut GOptionGroup;
}
extern "C" {
    pub fn g_option_context_get_help(
        context: *mut GOptionContext,
        main_help: gboolean,
        group: *mut GOptionGroup,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_option_group_new(
        name: *const gchar,
        description: *const gchar,
        help_description: *const gchar,
        user_data: gpointer,
        destroy: GDestroyNotify,
    ) -> *mut GOptionGroup;
}
extern "C" {
    pub fn g_option_group_set_parse_hooks(
        group: *mut GOptionGroup,
        pre_parse_func: GOptionParseFunc,
        post_parse_func: GOptionParseFunc,
    );
}
extern "C" {
    pub fn g_option_group_set_error_hook(group: *mut GOptionGroup, error_func: GOptionErrorFunc);
}
extern "C" {
    pub fn g_option_group_free(group: *mut GOptionGroup);
}
extern "C" {
    pub fn g_option_group_ref(group: *mut GOptionGroup) -> *mut GOptionGroup;
}
extern "C" {
    pub fn g_option_group_unref(group: *mut GOptionGroup);
}
extern "C" {
    pub fn g_option_group_add_entries(group: *mut GOptionGroup, entries: *const GOptionEntry);
}
extern "C" {
    pub fn g_option_group_set_translate_func(
        group: *mut GOptionGroup,
        func: GTranslateFunc,
        data: gpointer,
        destroy_notify: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_option_group_set_translation_domain(group: *mut GOptionGroup, domain: *const gchar);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPatternSpec {
    _unused: [u8; 0],
}
pub type GPatternSpec = _GPatternSpec;
extern "C" {
    pub fn g_pattern_spec_new(pattern: *const gchar) -> *mut GPatternSpec;
}
extern "C" {
    pub fn g_pattern_spec_free(pspec: *mut GPatternSpec);
}
extern "C" {
    pub fn g_pattern_spec_equal(pspec1: *mut GPatternSpec, pspec2: *mut GPatternSpec) -> gboolean;
}
extern "C" {
    pub fn g_pattern_match(
        pspec: *mut GPatternSpec,
        string_length: guint,
        string: *const gchar,
        string_reversed: *const gchar,
    ) -> gboolean;
}
extern "C" {
    pub fn g_pattern_match_string(pspec: *mut GPatternSpec, string: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_pattern_match_simple(pattern: *const gchar, string: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_spaced_primes_closest(num: guint) -> guint;
}
extern "C" {
    pub fn g_qsort_with_data(
        pbase: gconstpointer,
        total_elems: gint,
        size: gsize,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    );
}
#[doc = " GQueue:"]
#[doc = " @head: a pointer to the first element of the queue"]
#[doc = " @tail: a pointer to the last element of the queue"]
#[doc = " @length: the number of elements in the queue"]
#[doc = ""]
#[doc = " Contains the public fields of a"]
#[doc = " [Queue][glib-Double-ended-Queues]."]
pub type GQueue = _GQueue;
#[doc = " GQueue:"]
#[doc = " @head: a pointer to the first element of the queue"]
#[doc = " @tail: a pointer to the last element of the queue"]
#[doc = " @length: the number of elements in the queue"]
#[doc = ""]
#[doc = " Contains the public fields of a"]
#[doc = " [Queue][glib-Double-ended-Queues]."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GQueue {
    pub head: *mut GList,
    pub tail: *mut GList,
    pub length: guint,
}
#[test]
fn bindgen_test_layout__GQueue() {
    assert_eq!(
        ::std::mem::size_of::<_GQueue>(),
        24usize,
        concat!("Size of: ", stringify!(_GQueue))
    );
    assert_eq!(
        ::std::mem::align_of::<_GQueue>(),
        8usize,
        concat!("Alignment of ", stringify!(_GQueue))
    );
    fn test_field_head() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GQueue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).head) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GQueue),
                "::",
                stringify!(head)
            )
        );
    }
    test_field_head();
    fn test_field_tail() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GQueue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tail) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_GQueue),
                "::",
                stringify!(tail)
            )
        );
    }
    test_field_tail();
    fn test_field_length() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GQueue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_GQueue),
                "::",
                stringify!(length)
            )
        );
    }
    test_field_length();
}
extern "C" {
    pub fn g_queue_new() -> *mut GQueue;
}
extern "C" {
    pub fn g_queue_free(queue: *mut GQueue);
}
extern "C" {
    pub fn g_queue_free_full(queue: *mut GQueue, free_func: GDestroyNotify);
}
extern "C" {
    pub fn g_queue_init(queue: *mut GQueue);
}
extern "C" {
    pub fn g_queue_clear(queue: *mut GQueue);
}
extern "C" {
    pub fn g_queue_is_empty(queue: *mut GQueue) -> gboolean;
}
extern "C" {
    pub fn g_queue_clear_full(queue: *mut GQueue, free_func: GDestroyNotify);
}
extern "C" {
    pub fn g_queue_get_length(queue: *mut GQueue) -> guint;
}
extern "C" {
    pub fn g_queue_reverse(queue: *mut GQueue);
}
extern "C" {
    pub fn g_queue_copy(queue: *mut GQueue) -> *mut GQueue;
}
extern "C" {
    pub fn g_queue_foreach(queue: *mut GQueue, func: GFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_queue_find(queue: *mut GQueue, data: gconstpointer) -> *mut GList;
}
extern "C" {
    pub fn g_queue_find_custom(
        queue: *mut GQueue,
        data: gconstpointer,
        func: GCompareFunc,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_queue_sort(queue: *mut GQueue, compare_func: GCompareDataFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_queue_push_head(queue: *mut GQueue, data: gpointer);
}
extern "C" {
    pub fn g_queue_push_tail(queue: *mut GQueue, data: gpointer);
}
extern "C" {
    pub fn g_queue_push_nth(queue: *mut GQueue, data: gpointer, n: gint);
}
extern "C" {
    pub fn g_queue_pop_head(queue: *mut GQueue) -> gpointer;
}
extern "C" {
    pub fn g_queue_pop_tail(queue: *mut GQueue) -> gpointer;
}
extern "C" {
    pub fn g_queue_pop_nth(queue: *mut GQueue, n: guint) -> gpointer;
}
extern "C" {
    pub fn g_queue_peek_head(queue: *mut GQueue) -> gpointer;
}
extern "C" {
    pub fn g_queue_peek_tail(queue: *mut GQueue) -> gpointer;
}
extern "C" {
    pub fn g_queue_peek_nth(queue: *mut GQueue, n: guint) -> gpointer;
}
extern "C" {
    pub fn g_queue_index(queue: *mut GQueue, data: gconstpointer) -> gint;
}
extern "C" {
    pub fn g_queue_remove(queue: *mut GQueue, data: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_queue_remove_all(queue: *mut GQueue, data: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_queue_insert_before(queue: *mut GQueue, sibling: *mut GList, data: gpointer);
}
extern "C" {
    pub fn g_queue_insert_before_link(queue: *mut GQueue, sibling: *mut GList, link_: *mut GList);
}
extern "C" {
    pub fn g_queue_insert_after(queue: *mut GQueue, sibling: *mut GList, data: gpointer);
}
extern "C" {
    pub fn g_queue_insert_after_link(queue: *mut GQueue, sibling: *mut GList, link_: *mut GList);
}
extern "C" {
    pub fn g_queue_insert_sorted(
        queue: *mut GQueue,
        data: gpointer,
        func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_queue_push_head_link(queue: *mut GQueue, link_: *mut GList);
}
extern "C" {
    pub fn g_queue_push_tail_link(queue: *mut GQueue, link_: *mut GList);
}
extern "C" {
    pub fn g_queue_push_nth_link(queue: *mut GQueue, n: gint, link_: *mut GList);
}
extern "C" {
    pub fn g_queue_pop_head_link(queue: *mut GQueue) -> *mut GList;
}
extern "C" {
    pub fn g_queue_pop_tail_link(queue: *mut GQueue) -> *mut GList;
}
extern "C" {
    pub fn g_queue_pop_nth_link(queue: *mut GQueue, n: guint) -> *mut GList;
}
extern "C" {
    pub fn g_queue_peek_head_link(queue: *mut GQueue) -> *mut GList;
}
extern "C" {
    pub fn g_queue_peek_tail_link(queue: *mut GQueue) -> *mut GList;
}
extern "C" {
    pub fn g_queue_peek_nth_link(queue: *mut GQueue, n: guint) -> *mut GList;
}
extern "C" {
    pub fn g_queue_link_index(queue: *mut GQueue, link_: *mut GList) -> gint;
}
extern "C" {
    pub fn g_queue_unlink(queue: *mut GQueue, link_: *mut GList);
}
extern "C" {
    pub fn g_queue_delete_link(queue: *mut GQueue, link_: *mut GList);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRand {
    _unused: [u8; 0],
}
pub type GRand = _GRand;
extern "C" {
    pub fn g_rand_new_with_seed(seed: guint32) -> *mut GRand;
}
extern "C" {
    pub fn g_rand_new_with_seed_array(seed: *const guint32, seed_length: guint) -> *mut GRand;
}
extern "C" {
    pub fn g_rand_new() -> *mut GRand;
}
extern "C" {
    pub fn g_rand_free(rand_: *mut GRand);
}
extern "C" {
    pub fn g_rand_copy(rand_: *mut GRand) -> *mut GRand;
}
extern "C" {
    pub fn g_rand_set_seed(rand_: *mut GRand, seed: guint32);
}
extern "C" {
    pub fn g_rand_set_seed_array(rand_: *mut GRand, seed: *const guint32, seed_length: guint);
}
extern "C" {
    pub fn g_rand_int(rand_: *mut GRand) -> guint32;
}
extern "C" {
    pub fn g_rand_int_range(rand_: *mut GRand, begin: gint32, end: gint32) -> gint32;
}
extern "C" {
    pub fn g_rand_double(rand_: *mut GRand) -> gdouble;
}
extern "C" {
    pub fn g_rand_double_range(rand_: *mut GRand, begin: gdouble, end: gdouble) -> gdouble;
}
extern "C" {
    pub fn g_random_set_seed(seed: guint32);
}
extern "C" {
    pub fn g_random_int() -> guint32;
}
extern "C" {
    pub fn g_random_int_range(begin: gint32, end: gint32) -> gint32;
}
extern "C" {
    pub fn g_random_double() -> gdouble;
}
extern "C" {
    pub fn g_random_double_range(begin: gdouble, end: gdouble) -> gdouble;
}
extern "C" {
    pub fn g_rc_box_alloc(block_size: gsize) -> gpointer;
}
extern "C" {
    pub fn g_rc_box_alloc0(block_size: gsize) -> gpointer;
}
extern "C" {
    pub fn g_rc_box_dup(block_size: gsize, mem_block: gconstpointer) -> gpointer;
}
extern "C" {
    pub fn g_rc_box_acquire(mem_block: gpointer) -> gpointer;
}
extern "C" {
    pub fn g_rc_box_release(mem_block: gpointer);
}
extern "C" {
    pub fn g_rc_box_release_full(mem_block: gpointer, clear_func: GDestroyNotify);
}
extern "C" {
    pub fn g_rc_box_get_size(mem_block: gpointer) -> gsize;
}
extern "C" {
    pub fn g_atomic_rc_box_alloc(block_size: gsize) -> gpointer;
}
extern "C" {
    pub fn g_atomic_rc_box_alloc0(block_size: gsize) -> gpointer;
}
extern "C" {
    pub fn g_atomic_rc_box_dup(block_size: gsize, mem_block: gconstpointer) -> gpointer;
}
extern "C" {
    pub fn g_atomic_rc_box_acquire(mem_block: gpointer) -> gpointer;
}
extern "C" {
    pub fn g_atomic_rc_box_release(mem_block: gpointer);
}
extern "C" {
    pub fn g_atomic_rc_box_release_full(mem_block: gpointer, clear_func: GDestroyNotify);
}
extern "C" {
    pub fn g_atomic_rc_box_get_size(mem_block: gpointer) -> gsize;
}
extern "C" {
    pub fn g_ref_count_init(rc: *mut grefcount);
}
extern "C" {
    pub fn g_ref_count_inc(rc: *mut grefcount);
}
extern "C" {
    pub fn g_ref_count_dec(rc: *mut grefcount) -> gboolean;
}
extern "C" {
    pub fn g_ref_count_compare(rc: *mut grefcount, val: gint) -> gboolean;
}
extern "C" {
    pub fn g_atomic_ref_count_init(arc: *mut gatomicrefcount);
}
extern "C" {
    pub fn g_atomic_ref_count_inc(arc: *mut gatomicrefcount);
}
extern "C" {
    pub fn g_atomic_ref_count_dec(arc: *mut gatomicrefcount) -> gboolean;
}
extern "C" {
    pub fn g_atomic_ref_count_compare(arc: *mut gatomicrefcount, val: gint) -> gboolean;
}
extern "C" {
    pub fn g_ref_string_new(str_: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_ref_string_new_len(
        str_: *const ::std::os::raw::c_char,
        len: gssize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_ref_string_new_intern(
        str_: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_ref_string_acquire(str_: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_ref_string_release(str_: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn g_ref_string_length(str_: *mut ::std::os::raw::c_char) -> gsize;
}
#[doc = " GRefString:"]
#[doc = ""]
#[doc = " A typedef for a reference-counted string. A pointer to a #GRefString can be"]
#[doc = " treated like a standard `char*` array by all code, but can additionally have"]
#[doc = " `g_ref_string_*()` methods called on it. `g_ref_string_*()` methods cannot be"]
#[doc = " called on `char*` arrays not allocated using g_ref_string_new()."]
#[doc = ""]
#[doc = " If using #GRefString with autocleanups, g_autoptr() must be used rather than"]
#[doc = " g_autofree(), so that the reference counting metadata is also freed."]
#[doc = ""]
#[doc = " Since: 2.58"]
pub type GRefString = ::std::os::raw::c_char;
pub const GRegexError_G_REGEX_ERROR_COMPILE: GRegexError = 0;
pub const GRegexError_G_REGEX_ERROR_OPTIMIZE: GRegexError = 1;
pub const GRegexError_G_REGEX_ERROR_REPLACE: GRegexError = 2;
pub const GRegexError_G_REGEX_ERROR_MATCH: GRegexError = 3;
pub const GRegexError_G_REGEX_ERROR_INTERNAL: GRegexError = 4;
pub const GRegexError_G_REGEX_ERROR_STRAY_BACKSLASH: GRegexError = 101;
pub const GRegexError_G_REGEX_ERROR_MISSING_CONTROL_CHAR: GRegexError = 102;
pub const GRegexError_G_REGEX_ERROR_UNRECOGNIZED_ESCAPE: GRegexError = 103;
pub const GRegexError_G_REGEX_ERROR_QUANTIFIERS_OUT_OF_ORDER: GRegexError = 104;
pub const GRegexError_G_REGEX_ERROR_QUANTIFIER_TOO_BIG: GRegexError = 105;
pub const GRegexError_G_REGEX_ERROR_UNTERMINATED_CHARACTER_CLASS: GRegexError = 106;
pub const GRegexError_G_REGEX_ERROR_INVALID_ESCAPE_IN_CHARACTER_CLASS: GRegexError = 107;
pub const GRegexError_G_REGEX_ERROR_RANGE_OUT_OF_ORDER: GRegexError = 108;
pub const GRegexError_G_REGEX_ERROR_NOTHING_TO_REPEAT: GRegexError = 109;
pub const GRegexError_G_REGEX_ERROR_UNRECOGNIZED_CHARACTER: GRegexError = 112;
pub const GRegexError_G_REGEX_ERROR_POSIX_NAMED_CLASS_OUTSIDE_CLASS: GRegexError = 113;
pub const GRegexError_G_REGEX_ERROR_UNMATCHED_PARENTHESIS: GRegexError = 114;
pub const GRegexError_G_REGEX_ERROR_INEXISTENT_SUBPATTERN_REFERENCE: GRegexError = 115;
pub const GRegexError_G_REGEX_ERROR_UNTERMINATED_COMMENT: GRegexError = 118;
pub const GRegexError_G_REGEX_ERROR_EXPRESSION_TOO_LARGE: GRegexError = 120;
pub const GRegexError_G_REGEX_ERROR_MEMORY_ERROR: GRegexError = 121;
pub const GRegexError_G_REGEX_ERROR_VARIABLE_LENGTH_LOOKBEHIND: GRegexError = 125;
pub const GRegexError_G_REGEX_ERROR_MALFORMED_CONDITION: GRegexError = 126;
pub const GRegexError_G_REGEX_ERROR_TOO_MANY_CONDITIONAL_BRANCHES: GRegexError = 127;
pub const GRegexError_G_REGEX_ERROR_ASSERTION_EXPECTED: GRegexError = 128;
pub const GRegexError_G_REGEX_ERROR_UNKNOWN_POSIX_CLASS_NAME: GRegexError = 130;
pub const GRegexError_G_REGEX_ERROR_POSIX_COLLATING_ELEMENTS_NOT_SUPPORTED: GRegexError = 131;
pub const GRegexError_G_REGEX_ERROR_HEX_CODE_TOO_LARGE: GRegexError = 134;
pub const GRegexError_G_REGEX_ERROR_INVALID_CONDITION: GRegexError = 135;
pub const GRegexError_G_REGEX_ERROR_SINGLE_BYTE_MATCH_IN_LOOKBEHIND: GRegexError = 136;
pub const GRegexError_G_REGEX_ERROR_INFINITE_LOOP: GRegexError = 140;
pub const GRegexError_G_REGEX_ERROR_MISSING_SUBPATTERN_NAME_TERMINATOR: GRegexError = 142;
pub const GRegexError_G_REGEX_ERROR_DUPLICATE_SUBPATTERN_NAME: GRegexError = 143;
pub const GRegexError_G_REGEX_ERROR_MALFORMED_PROPERTY: GRegexError = 146;
pub const GRegexError_G_REGEX_ERROR_UNKNOWN_PROPERTY: GRegexError = 147;
pub const GRegexError_G_REGEX_ERROR_SUBPATTERN_NAME_TOO_LONG: GRegexError = 148;
pub const GRegexError_G_REGEX_ERROR_TOO_MANY_SUBPATTERNS: GRegexError = 149;
pub const GRegexError_G_REGEX_ERROR_INVALID_OCTAL_VALUE: GRegexError = 151;
pub const GRegexError_G_REGEX_ERROR_TOO_MANY_BRANCHES_IN_DEFINE: GRegexError = 154;
pub const GRegexError_G_REGEX_ERROR_DEFINE_REPETION: GRegexError = 155;
pub const GRegexError_G_REGEX_ERROR_INCONSISTENT_NEWLINE_OPTIONS: GRegexError = 156;
pub const GRegexError_G_REGEX_ERROR_MISSING_BACK_REFERENCE: GRegexError = 157;
pub const GRegexError_G_REGEX_ERROR_INVALID_RELATIVE_REFERENCE: GRegexError = 158;
pub const GRegexError_G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_FORBIDDEN: GRegexError = 159;
pub const GRegexError_G_REGEX_ERROR_UNKNOWN_BACKTRACKING_CONTROL_VERB: GRegexError = 160;
pub const GRegexError_G_REGEX_ERROR_NUMBER_TOO_BIG: GRegexError = 161;
pub const GRegexError_G_REGEX_ERROR_MISSING_SUBPATTERN_NAME: GRegexError = 162;
pub const GRegexError_G_REGEX_ERROR_MISSING_DIGIT: GRegexError = 163;
pub const GRegexError_G_REGEX_ERROR_INVALID_DATA_CHARACTER: GRegexError = 164;
pub const GRegexError_G_REGEX_ERROR_EXTRA_SUBPATTERN_NAME: GRegexError = 165;
pub const GRegexError_G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_REQUIRED: GRegexError = 166;
pub const GRegexError_G_REGEX_ERROR_INVALID_CONTROL_CHAR: GRegexError = 168;
pub const GRegexError_G_REGEX_ERROR_MISSING_NAME: GRegexError = 169;
pub const GRegexError_G_REGEX_ERROR_NOT_SUPPORTED_IN_CLASS: GRegexError = 171;
pub const GRegexError_G_REGEX_ERROR_TOO_MANY_FORWARD_REFERENCES: GRegexError = 172;
pub const GRegexError_G_REGEX_ERROR_NAME_TOO_LONG: GRegexError = 175;
pub const GRegexError_G_REGEX_ERROR_CHARACTER_VALUE_TOO_LARGE: GRegexError = 176;
#[doc = " GRegexError:"]
#[doc = " @G_REGEX_ERROR_COMPILE: Compilation of the regular expression failed."]
#[doc = " @G_REGEX_ERROR_OPTIMIZE: Optimization of the regular expression failed."]
#[doc = " @G_REGEX_ERROR_REPLACE: Replacement failed due to an ill-formed replacement"]
#[doc = "     string."]
#[doc = " @G_REGEX_ERROR_MATCH: The match process failed."]
#[doc = " @G_REGEX_ERROR_INTERNAL: Internal error of the regular expression engine."]
#[doc = "     Since 2.16"]
#[doc = " @G_REGEX_ERROR_STRAY_BACKSLASH: \"\\\\\" at end of pattern. Since 2.16"]
#[doc = " @G_REGEX_ERROR_MISSING_CONTROL_CHAR: \"\\\\c\" at end of pattern. Since 2.16"]
#[doc = " @G_REGEX_ERROR_UNRECOGNIZED_ESCAPE: Unrecognized character follows \"\\\\\"."]
#[doc = "     Since 2.16"]
#[doc = " @G_REGEX_ERROR_QUANTIFIERS_OUT_OF_ORDER: Numbers out of order in \"{}\""]
#[doc = "     quantifier. Since 2.16"]
#[doc = " @G_REGEX_ERROR_QUANTIFIER_TOO_BIG: Number too big in \"{}\" quantifier."]
#[doc = "     Since 2.16"]
#[doc = " @G_REGEX_ERROR_UNTERMINATED_CHARACTER_CLASS: Missing terminating \"]\" for"]
#[doc = "     character class. Since 2.16"]
#[doc = " @G_REGEX_ERROR_INVALID_ESCAPE_IN_CHARACTER_CLASS: Invalid escape sequence"]
#[doc = "     in character class. Since 2.16"]
#[doc = " @G_REGEX_ERROR_RANGE_OUT_OF_ORDER: Range out of order in character class."]
#[doc = "     Since 2.16"]
#[doc = " @G_REGEX_ERROR_NOTHING_TO_REPEAT: Nothing to repeat. Since 2.16"]
#[doc = " @G_REGEX_ERROR_UNRECOGNIZED_CHARACTER: Unrecognized character after \"(?\","]
#[doc = "     \"(?<\" or \"(?P\". Since 2.16"]
#[doc = " @G_REGEX_ERROR_POSIX_NAMED_CLASS_OUTSIDE_CLASS: POSIX named classes are"]
#[doc = "     supported only within a class. Since 2.16"]
#[doc = " @G_REGEX_ERROR_UNMATCHED_PARENTHESIS: Missing terminating \")\" or \")\""]
#[doc = "     without opening \"(\". Since 2.16"]
#[doc = " @G_REGEX_ERROR_INEXISTENT_SUBPATTERN_REFERENCE: Reference to non-existent"]
#[doc = "     subpattern. Since 2.16"]
#[doc = " @G_REGEX_ERROR_UNTERMINATED_COMMENT: Missing terminating \")\" after comment."]
#[doc = "     Since 2.16"]
#[doc = " @G_REGEX_ERROR_EXPRESSION_TOO_LARGE: Regular expression too large."]
#[doc = "     Since 2.16"]
#[doc = " @G_REGEX_ERROR_MEMORY_ERROR: Failed to get memory. Since 2.16"]
#[doc = " @G_REGEX_ERROR_VARIABLE_LENGTH_LOOKBEHIND: Lookbehind assertion is not"]
#[doc = "     fixed length. Since 2.16"]
#[doc = " @G_REGEX_ERROR_MALFORMED_CONDITION: Malformed number or name after \"(?(\"."]
#[doc = "     Since 2.16"]
#[doc = " @G_REGEX_ERROR_TOO_MANY_CONDITIONAL_BRANCHES: Conditional group contains"]
#[doc = "     more than two branches. Since 2.16"]
#[doc = " @G_REGEX_ERROR_ASSERTION_EXPECTED: Assertion expected after \"(?(\"."]
#[doc = "     Since 2.16"]
#[doc = " @G_REGEX_ERROR_UNKNOWN_POSIX_CLASS_NAME: Unknown POSIX class name."]
#[doc = "     Since 2.16"]
#[doc = " @G_REGEX_ERROR_POSIX_COLLATING_ELEMENTS_NOT_SUPPORTED: POSIX collating"]
#[doc = "     elements are not supported. Since 2.16"]
#[doc = " @G_REGEX_ERROR_HEX_CODE_TOO_LARGE: Character value in \"\\\\x{...}\" sequence"]
#[doc = "     is too large. Since 2.16"]
#[doc = " @G_REGEX_ERROR_INVALID_CONDITION: Invalid condition \"(?(0)\". Since 2.16"]
#[doc = " @G_REGEX_ERROR_SINGLE_BYTE_MATCH_IN_LOOKBEHIND: \\\\C not allowed in"]
#[doc = "     lookbehind assertion. Since 2.16"]
#[doc = " @G_REGEX_ERROR_INFINITE_LOOP: Recursive call could loop indefinitely."]
#[doc = "     Since 2.16"]
#[doc = " @G_REGEX_ERROR_MISSING_SUBPATTERN_NAME_TERMINATOR: Missing terminator"]
#[doc = "     in subpattern name. Since 2.16"]
#[doc = " @G_REGEX_ERROR_DUPLICATE_SUBPATTERN_NAME: Two named subpatterns have"]
#[doc = "     the same name. Since 2.16"]
#[doc = " @G_REGEX_ERROR_MALFORMED_PROPERTY: Malformed \"\\\\P\" or \"\\\\p\" sequence."]
#[doc = "     Since 2.16"]
#[doc = " @G_REGEX_ERROR_UNKNOWN_PROPERTY: Unknown property name after \"\\\\P\" or"]
#[doc = "     \"\\\\p\". Since 2.16"]
#[doc = " @G_REGEX_ERROR_SUBPATTERN_NAME_TOO_LONG: Subpattern name is too long"]
#[doc = "     (maximum 32 characters). Since 2.16"]
#[doc = " @G_REGEX_ERROR_TOO_MANY_SUBPATTERNS: Too many named subpatterns (maximum"]
#[doc = "     10,000). Since 2.16"]
#[doc = " @G_REGEX_ERROR_INVALID_OCTAL_VALUE: Octal value is greater than \"\\\\377\"."]
#[doc = "     Since 2.16"]
#[doc = " @G_REGEX_ERROR_TOO_MANY_BRANCHES_IN_DEFINE: \"DEFINE\" group contains more"]
#[doc = "     than one branch. Since 2.16"]
#[doc = " @G_REGEX_ERROR_DEFINE_REPETION: Repeating a \"DEFINE\" group is not allowed."]
#[doc = "     This error is never raised. Since: 2.16 Deprecated: 2.34"]
#[doc = " @G_REGEX_ERROR_INCONSISTENT_NEWLINE_OPTIONS: Inconsistent newline options."]
#[doc = "     Since 2.16"]
#[doc = " @G_REGEX_ERROR_MISSING_BACK_REFERENCE: \"\\\\g\" is not followed by a braced,"]
#[doc = "      angle-bracketed, or quoted name or number, or by a plain number. Since: 2.16"]
#[doc = " @G_REGEX_ERROR_INVALID_RELATIVE_REFERENCE: relative reference must not be zero. Since: 2.34"]
#[doc = " @G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_FORBIDDEN: the backtracing"]
#[doc = "     control verb used does not allow an argument. Since: 2.34"]
#[doc = " @G_REGEX_ERROR_UNKNOWN_BACKTRACKING_CONTROL_VERB: unknown backtracing"]
#[doc = "     control verb. Since: 2.34"]
#[doc = " @G_REGEX_ERROR_NUMBER_TOO_BIG: number is too big in escape sequence. Since: 2.34"]
#[doc = " @G_REGEX_ERROR_MISSING_SUBPATTERN_NAME: Missing subpattern name. Since: 2.34"]
#[doc = " @G_REGEX_ERROR_MISSING_DIGIT: Missing digit. Since 2.34"]
#[doc = " @G_REGEX_ERROR_INVALID_DATA_CHARACTER: In JavaScript compatibility mode,"]
#[doc = "     \"[\" is an invalid data character. Since: 2.34"]
#[doc = " @G_REGEX_ERROR_EXTRA_SUBPATTERN_NAME: different names for subpatterns of the"]
#[doc = "     same number are not allowed. Since: 2.34"]
#[doc = " @G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_REQUIRED: the backtracing control"]
#[doc = "     verb requires an argument. Since: 2.34"]
#[doc = " @G_REGEX_ERROR_INVALID_CONTROL_CHAR: \"\\\\c\" must be followed by an ASCII"]
#[doc = "     character. Since: 2.34"]
#[doc = " @G_REGEX_ERROR_MISSING_NAME: \"\\\\k\" is not followed by a braced, angle-bracketed, or"]
#[doc = "     quoted name. Since: 2.34"]
#[doc = " @G_REGEX_ERROR_NOT_SUPPORTED_IN_CLASS: \"\\\\N\" is not supported in a class. Since: 2.34"]
#[doc = " @G_REGEX_ERROR_TOO_MANY_FORWARD_REFERENCES: too many forward references. Since: 2.34"]
#[doc = " @G_REGEX_ERROR_NAME_TOO_LONG: the name is too long in \"(*MARK)\", \"(*PRUNE)\","]
#[doc = "     \"(*SKIP)\", or \"(*THEN)\". Since: 2.34"]
#[doc = " @G_REGEX_ERROR_CHARACTER_VALUE_TOO_LARGE: the character value in the \\\\u sequence is"]
#[doc = "     too large. Since: 2.34"]
#[doc = ""]
#[doc = " Error codes returned by regular expressions functions."]
#[doc = ""]
#[doc = " Since: 2.14"]
pub type GRegexError = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_regex_error_quark() -> GQuark;
}
pub const GRegexCompileFlags_G_REGEX_CASELESS: GRegexCompileFlags = 1;
pub const GRegexCompileFlags_G_REGEX_MULTILINE: GRegexCompileFlags = 2;
pub const GRegexCompileFlags_G_REGEX_DOTALL: GRegexCompileFlags = 4;
pub const GRegexCompileFlags_G_REGEX_EXTENDED: GRegexCompileFlags = 8;
pub const GRegexCompileFlags_G_REGEX_ANCHORED: GRegexCompileFlags = 16;
pub const GRegexCompileFlags_G_REGEX_DOLLAR_ENDONLY: GRegexCompileFlags = 32;
pub const GRegexCompileFlags_G_REGEX_UNGREEDY: GRegexCompileFlags = 512;
pub const GRegexCompileFlags_G_REGEX_RAW: GRegexCompileFlags = 2048;
pub const GRegexCompileFlags_G_REGEX_NO_AUTO_CAPTURE: GRegexCompileFlags = 4096;
pub const GRegexCompileFlags_G_REGEX_OPTIMIZE: GRegexCompileFlags = 8192;
pub const GRegexCompileFlags_G_REGEX_FIRSTLINE: GRegexCompileFlags = 262144;
pub const GRegexCompileFlags_G_REGEX_DUPNAMES: GRegexCompileFlags = 524288;
pub const GRegexCompileFlags_G_REGEX_NEWLINE_CR: GRegexCompileFlags = 1048576;
pub const GRegexCompileFlags_G_REGEX_NEWLINE_LF: GRegexCompileFlags = 2097152;
pub const GRegexCompileFlags_G_REGEX_NEWLINE_CRLF: GRegexCompileFlags = 3145728;
pub const GRegexCompileFlags_G_REGEX_NEWLINE_ANYCRLF: GRegexCompileFlags = 5242880;
pub const GRegexCompileFlags_G_REGEX_BSR_ANYCRLF: GRegexCompileFlags = 8388608;
pub const GRegexCompileFlags_G_REGEX_JAVASCRIPT_COMPAT: GRegexCompileFlags = 33554432;
#[doc = " GRegexCompileFlags:"]
#[doc = " @G_REGEX_CASELESS: Letters in the pattern match both upper- and"]
#[doc = "     lowercase letters. This option can be changed within a pattern"]
#[doc = "     by a \"(?i)\" option setting."]
#[doc = " @G_REGEX_MULTILINE: By default, GRegex treats the strings as consisting"]
#[doc = "     of a single line of characters (even if it actually contains"]
#[doc = "     newlines). The \"start of line\" metacharacter (\"^\") matches only"]
#[doc = "     at the start of the string, while the \"end of line\" metacharacter"]
#[doc = "     (\"$\") matches only at the end of the string, or before a terminating"]
#[doc = "     newline (unless #G_REGEX_DOLLAR_ENDONLY is set). When"]
#[doc = "     #G_REGEX_MULTILINE is set, the \"start of line\" and \"end of line\""]
#[doc = "     constructs match immediately following or immediately before any"]
#[doc = "     newline in the string, respectively, as well as at the very start"]
#[doc = "     and end. This can be changed within a pattern by a \"(?m)\" option"]
#[doc = "     setting."]
#[doc = " @G_REGEX_DOTALL: A dot metacharacter (\".\") in the pattern matches all"]
#[doc = "     characters, including newlines. Without it, newlines are excluded."]
#[doc = "     This option can be changed within a pattern by a (\"?s\") option setting."]
#[doc = " @G_REGEX_EXTENDED: Whitespace data characters in the pattern are"]
#[doc = "     totally ignored except when escaped or inside a character class."]
#[doc = "     Whitespace does not include the VT character (code 11). In addition,"]
#[doc = "     characters between an unescaped \"#\" outside a character class and"]
#[doc = "     the next newline character, inclusive, are also ignored. This can"]
#[doc = "     be changed within a pattern by a \"(?x)\" option setting."]
#[doc = " @G_REGEX_ANCHORED: The pattern is forced to be \"anchored\", that is,"]
#[doc = "     it is constrained to match only at the first matching point in the"]
#[doc = "     string that is being searched. This effect can also be achieved by"]
#[doc = "     appropriate constructs in the pattern itself such as the \"^\""]
#[doc = "     metacharacter."]
#[doc = " @G_REGEX_DOLLAR_ENDONLY: A dollar metacharacter (\"$\") in the pattern"]
#[doc = "     matches only at the end of the string. Without this option, a"]
#[doc = "     dollar also matches immediately before the final character if"]
#[doc = "     it is a newline (but not before any other newlines). This option"]
#[doc = "     is ignored if #G_REGEX_MULTILINE is set."]
#[doc = " @G_REGEX_UNGREEDY: Inverts the \"greediness\" of the quantifiers so that"]
#[doc = "     they are not greedy by default, but become greedy if followed by \"?\"."]
#[doc = "     It can also be set by a \"(?U)\" option setting within the pattern."]
#[doc = " @G_REGEX_RAW: Usually strings must be valid UTF-8 strings, using this"]
#[doc = "     flag they are considered as a raw sequence of bytes."]
#[doc = " @G_REGEX_NO_AUTO_CAPTURE: Disables the use of numbered capturing"]
#[doc = "     parentheses in the pattern. Any opening parenthesis that is not"]
#[doc = "     followed by \"?\" behaves as if it were followed by \"?:\" but named"]
#[doc = "     parentheses can still be used for capturing (and they acquire numbers"]
#[doc = "     in the usual way)."]
#[doc = " @G_REGEX_OPTIMIZE: Optimize the regular expression. If the pattern will"]
#[doc = "     be used many times, then it may be worth the effort to optimize it"]
#[doc = "     to improve the speed of matches."]
#[doc = " @G_REGEX_FIRSTLINE: Limits an unanchored pattern to match before (or at) the"]
#[doc = "     first newline. Since: 2.34"]
#[doc = " @G_REGEX_DUPNAMES: Names used to identify capturing subpatterns need not"]
#[doc = "     be unique. This can be helpful for certain types of pattern when it"]
#[doc = "     is known that only one instance of the named subpattern can ever be"]
#[doc = "     matched."]
#[doc = " @G_REGEX_NEWLINE_CR: Usually any newline character or character sequence is"]
#[doc = "     recognized. If this option is set, the only recognized newline character"]
#[doc = "     is '\\r'."]
#[doc = " @G_REGEX_NEWLINE_LF: Usually any newline character or character sequence is"]
#[doc = "     recognized. If this option is set, the only recognized newline character"]
#[doc = "     is '\\n'."]
#[doc = " @G_REGEX_NEWLINE_CRLF: Usually any newline character or character sequence is"]
#[doc = "     recognized. If this option is set, the only recognized newline character"]
#[doc = "     sequence is '\\r\\n'."]
#[doc = " @G_REGEX_NEWLINE_ANYCRLF: Usually any newline character or character sequence"]
#[doc = "     is recognized. If this option is set, the only recognized newline character"]
#[doc = "     sequences are '\\r', '\\n', and '\\r\\n'. Since: 2.34"]
#[doc = " @G_REGEX_BSR_ANYCRLF: Usually any newline character or character sequence"]
#[doc = "     is recognised. If this option is set, then \"\\R\" only recognizes the newline"]
#[doc = "    characters '\\r', '\\n' and '\\r\\n'. Since: 2.34"]
#[doc = " @G_REGEX_JAVASCRIPT_COMPAT: Changes behaviour so that it is compatible with"]
#[doc = "     JavaScript rather than PCRE. Since: 2.34"]
#[doc = ""]
#[doc = " Flags specifying compile-time options."]
#[doc = ""]
#[doc = " Since: 2.14"]
pub type GRegexCompileFlags = ::std::os::raw::c_uint;
pub const GRegexMatchFlags_G_REGEX_MATCH_ANCHORED: GRegexMatchFlags = 16;
pub const GRegexMatchFlags_G_REGEX_MATCH_NOTBOL: GRegexMatchFlags = 128;
pub const GRegexMatchFlags_G_REGEX_MATCH_NOTEOL: GRegexMatchFlags = 256;
pub const GRegexMatchFlags_G_REGEX_MATCH_NOTEMPTY: GRegexMatchFlags = 1024;
pub const GRegexMatchFlags_G_REGEX_MATCH_PARTIAL: GRegexMatchFlags = 32768;
pub const GRegexMatchFlags_G_REGEX_MATCH_NEWLINE_CR: GRegexMatchFlags = 1048576;
pub const GRegexMatchFlags_G_REGEX_MATCH_NEWLINE_LF: GRegexMatchFlags = 2097152;
pub const GRegexMatchFlags_G_REGEX_MATCH_NEWLINE_CRLF: GRegexMatchFlags = 3145728;
pub const GRegexMatchFlags_G_REGEX_MATCH_NEWLINE_ANY: GRegexMatchFlags = 4194304;
pub const GRegexMatchFlags_G_REGEX_MATCH_NEWLINE_ANYCRLF: GRegexMatchFlags = 5242880;
pub const GRegexMatchFlags_G_REGEX_MATCH_BSR_ANYCRLF: GRegexMatchFlags = 8388608;
pub const GRegexMatchFlags_G_REGEX_MATCH_BSR_ANY: GRegexMatchFlags = 16777216;
pub const GRegexMatchFlags_G_REGEX_MATCH_PARTIAL_SOFT: GRegexMatchFlags = 32768;
pub const GRegexMatchFlags_G_REGEX_MATCH_PARTIAL_HARD: GRegexMatchFlags = 134217728;
pub const GRegexMatchFlags_G_REGEX_MATCH_NOTEMPTY_ATSTART: GRegexMatchFlags = 268435456;
#[doc = " GRegexMatchFlags:"]
#[doc = " @G_REGEX_MATCH_ANCHORED: The pattern is forced to be \"anchored\", that is,"]
#[doc = "     it is constrained to match only at the first matching point in the"]
#[doc = "     string that is being searched. This effect can also be achieved by"]
#[doc = "     appropriate constructs in the pattern itself such as the \"^\""]
#[doc = "     metacharacter."]
#[doc = " @G_REGEX_MATCH_NOTBOL: Specifies that first character of the string is"]
#[doc = "     not the beginning of a line, so the circumflex metacharacter should"]
#[doc = "     not match before it. Setting this without #G_REGEX_MULTILINE (at"]
#[doc = "     compile time) causes circumflex never to match. This option affects"]
#[doc = "     only the behaviour of the circumflex metacharacter, it does not"]
#[doc = "     affect \"\\A\"."]
#[doc = " @G_REGEX_MATCH_NOTEOL: Specifies that the end of the subject string is"]
#[doc = "     not the end of a line, so the dollar metacharacter should not match"]
#[doc = "     it nor (except in multiline mode) a newline immediately before it."]
#[doc = "     Setting this without #G_REGEX_MULTILINE (at compile time) causes"]
#[doc = "     dollar never to match. This option affects only the behaviour of"]
#[doc = "     the dollar metacharacter, it does not affect \"\\Z\" or \"\\z\"."]
#[doc = " @G_REGEX_MATCH_NOTEMPTY: An empty string is not considered to be a valid"]
#[doc = "     match if this option is set. If there are alternatives in the pattern,"]
#[doc = "     they are tried. If all the alternatives match the empty string, the"]
#[doc = "     entire match fails. For example, if the pattern \"a?b?\" is applied to"]
#[doc = "     a string not beginning with \"a\" or \"b\", it matches the empty string"]
#[doc = "     at the start of the string. With this flag set, this match is not"]
#[doc = "     valid, so GRegex searches further into the string for occurrences"]
#[doc = "     of \"a\" or \"b\"."]
#[doc = " @G_REGEX_MATCH_PARTIAL: Turns on the partial matching feature, for more"]
#[doc = "     documentation on partial matching see g_match_info_is_partial_match()."]
#[doc = " @G_REGEX_MATCH_NEWLINE_CR: Overrides the newline definition set when"]
#[doc = "     creating a new #GRegex, setting the '\\r' character as line terminator."]
#[doc = " @G_REGEX_MATCH_NEWLINE_LF: Overrides the newline definition set when"]
#[doc = "     creating a new #GRegex, setting the '\\n' character as line terminator."]
#[doc = " @G_REGEX_MATCH_NEWLINE_CRLF: Overrides the newline definition set when"]
#[doc = "     creating a new #GRegex, setting the '\\r\\n' characters sequence as line terminator."]
#[doc = " @G_REGEX_MATCH_NEWLINE_ANY: Overrides the newline definition set when"]
#[doc = "     creating a new #GRegex, any Unicode newline sequence"]
#[doc = "     is recognised as a newline. These are '\\r', '\\n' and '\\rn', and the"]
#[doc = "     single characters U+000B LINE TABULATION, U+000C FORM FEED (FF),"]
#[doc = "     U+0085 NEXT LINE (NEL), U+2028 LINE SEPARATOR and"]
#[doc = "     U+2029 PARAGRAPH SEPARATOR."]
#[doc = " @G_REGEX_MATCH_NEWLINE_ANYCRLF: Overrides the newline definition set when"]
#[doc = "     creating a new #GRegex; any '\\r', '\\n', or '\\r\\n' character sequence"]
#[doc = "     is recognized as a newline. Since: 2.34"]
#[doc = " @G_REGEX_MATCH_BSR_ANYCRLF: Overrides the newline definition for \"\\R\" set when"]
#[doc = "     creating a new #GRegex; only '\\r', '\\n', or '\\r\\n' character sequences"]
#[doc = "     are recognized as a newline by \"\\R\". Since: 2.34"]
#[doc = " @G_REGEX_MATCH_BSR_ANY: Overrides the newline definition for \"\\R\" set when"]
#[doc = "     creating a new #GRegex; any Unicode newline character or character sequence"]
#[doc = "     are recognized as a newline by \"\\R\". These are '\\r', '\\n' and '\\rn', and the"]
#[doc = "     single characters U+000B LINE TABULATION, U+000C FORM FEED (FF),"]
#[doc = "     U+0085 NEXT LINE (NEL), U+2028 LINE SEPARATOR and"]
#[doc = "     U+2029 PARAGRAPH SEPARATOR. Since: 2.34"]
#[doc = " @G_REGEX_MATCH_PARTIAL_SOFT: An alias for #G_REGEX_MATCH_PARTIAL. Since: 2.34"]
#[doc = " @G_REGEX_MATCH_PARTIAL_HARD: Turns on the partial matching feature. In contrast to"]
#[doc = "     to #G_REGEX_MATCH_PARTIAL_SOFT, this stops matching as soon as a partial match"]
#[doc = "     is found, without continuing to search for a possible complete match. See"]
#[doc = "     g_match_info_is_partial_match() for more information. Since: 2.34"]
#[doc = " @G_REGEX_MATCH_NOTEMPTY_ATSTART: Like #G_REGEX_MATCH_NOTEMPTY, but only applied to"]
#[doc = "     the start of the matched string. For anchored"]
#[doc = "     patterns this can only happen for pattern containing \"\\K\". Since: 2.34"]
#[doc = ""]
#[doc = " Flags specifying match-time options."]
#[doc = ""]
#[doc = " Since: 2.14"]
pub type GRegexMatchFlags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRegex {
    _unused: [u8; 0],
}
#[doc = " GRegex:"]
#[doc = ""]
#[doc = " A GRegex is the \"compiled\" form of a regular expression pattern."]
#[doc = " This structure is opaque and its fields cannot be accessed directly."]
#[doc = ""]
#[doc = " Since: 2.14"]
pub type GRegex = _GRegex;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMatchInfo {
    _unused: [u8; 0],
}
#[doc = " GMatchInfo:"]
#[doc = ""]
#[doc = " A GMatchInfo is an opaque struct used to return information about"]
#[doc = " matches."]
pub type GMatchInfo = _GMatchInfo;
#[doc = " GRegexEvalCallback:"]
#[doc = " @match_info: the #GMatchInfo generated by the match."]
#[doc = "     Use g_match_info_get_regex() and g_match_info_get_string() if you"]
#[doc = "     need the #GRegex or the matched string."]
#[doc = " @result: a #GString containing the new string"]
#[doc = " @user_data: user data passed to g_regex_replace_eval()"]
#[doc = ""]
#[doc = " Specifies the type of the function passed to g_regex_replace_eval()."]
#[doc = " It is called for each occurrence of the pattern in the string passed"]
#[doc = " to g_regex_replace_eval(), and it should append the replacement to"]
#[doc = " @result."]
#[doc = ""]
#[doc = " Returns: %FALSE to continue the replacement process, %TRUE to stop it"]
#[doc = ""]
#[doc = " Since: 2.14"]
pub type GRegexEvalCallback = ::std::option::Option<
    unsafe extern "C" fn(
        match_info: *const GMatchInfo,
        result: *mut GString,
        user_data: gpointer,
    ) -> gboolean,
>;
extern "C" {
    pub fn g_regex_new(
        pattern: *const gchar,
        compile_options: GRegexCompileFlags,
        match_options: GRegexMatchFlags,
        error: *mut *mut GError,
    ) -> *mut GRegex;
}
extern "C" {
    pub fn g_regex_ref(regex: *mut GRegex) -> *mut GRegex;
}
extern "C" {
    pub fn g_regex_unref(regex: *mut GRegex);
}
extern "C" {
    pub fn g_regex_get_pattern(regex: *const GRegex) -> *const gchar;
}
extern "C" {
    pub fn g_regex_get_max_backref(regex: *const GRegex) -> gint;
}
extern "C" {
    pub fn g_regex_get_capture_count(regex: *const GRegex) -> gint;
}
extern "C" {
    pub fn g_regex_get_has_cr_or_lf(regex: *const GRegex) -> gboolean;
}
extern "C" {
    pub fn g_regex_get_max_lookbehind(regex: *const GRegex) -> gint;
}
extern "C" {
    pub fn g_regex_get_string_number(regex: *const GRegex, name: *const gchar) -> gint;
}
extern "C" {
    pub fn g_regex_escape_string(string: *const gchar, length: gint) -> *mut gchar;
}
extern "C" {
    pub fn g_regex_escape_nul(string: *const gchar, length: gint) -> *mut gchar;
}
extern "C" {
    pub fn g_regex_get_compile_flags(regex: *const GRegex) -> GRegexCompileFlags;
}
extern "C" {
    pub fn g_regex_get_match_flags(regex: *const GRegex) -> GRegexMatchFlags;
}
extern "C" {
    pub fn g_regex_match_simple(
        pattern: *const gchar,
        string: *const gchar,
        compile_options: GRegexCompileFlags,
        match_options: GRegexMatchFlags,
    ) -> gboolean;
}
extern "C" {
    pub fn g_regex_match(
        regex: *const GRegex,
        string: *const gchar,
        match_options: GRegexMatchFlags,
        match_info: *mut *mut GMatchInfo,
    ) -> gboolean;
}
extern "C" {
    pub fn g_regex_match_full(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        match_options: GRegexMatchFlags,
        match_info: *mut *mut GMatchInfo,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_regex_match_all(
        regex: *const GRegex,
        string: *const gchar,
        match_options: GRegexMatchFlags,
        match_info: *mut *mut GMatchInfo,
    ) -> gboolean;
}
extern "C" {
    pub fn g_regex_match_all_full(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        match_options: GRegexMatchFlags,
        match_info: *mut *mut GMatchInfo,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_regex_split_simple(
        pattern: *const gchar,
        string: *const gchar,
        compile_options: GRegexCompileFlags,
        match_options: GRegexMatchFlags,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_regex_split(
        regex: *const GRegex,
        string: *const gchar,
        match_options: GRegexMatchFlags,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_regex_split_full(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        match_options: GRegexMatchFlags,
        max_tokens: gint,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_regex_replace(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        replacement: *const gchar,
        match_options: GRegexMatchFlags,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_regex_replace_literal(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        replacement: *const gchar,
        match_options: GRegexMatchFlags,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_regex_replace_eval(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        match_options: GRegexMatchFlags,
        eval: GRegexEvalCallback,
        user_data: gpointer,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_regex_check_replacement(
        replacement: *const gchar,
        has_references: *mut gboolean,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_match_info_get_regex(match_info: *const GMatchInfo) -> *mut GRegex;
}
extern "C" {
    pub fn g_match_info_get_string(match_info: *const GMatchInfo) -> *const gchar;
}
extern "C" {
    pub fn g_match_info_ref(match_info: *mut GMatchInfo) -> *mut GMatchInfo;
}
extern "C" {
    pub fn g_match_info_unref(match_info: *mut GMatchInfo);
}
extern "C" {
    pub fn g_match_info_free(match_info: *mut GMatchInfo);
}
extern "C" {
    pub fn g_match_info_next(match_info: *mut GMatchInfo, error: *mut *mut GError) -> gboolean;
}
extern "C" {
    pub fn g_match_info_matches(match_info: *const GMatchInfo) -> gboolean;
}
extern "C" {
    pub fn g_match_info_get_match_count(match_info: *const GMatchInfo) -> gint;
}
extern "C" {
    pub fn g_match_info_is_partial_match(match_info: *const GMatchInfo) -> gboolean;
}
extern "C" {
    pub fn g_match_info_expand_references(
        match_info: *const GMatchInfo,
        string_to_expand: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_match_info_fetch(match_info: *const GMatchInfo, match_num: gint) -> *mut gchar;
}
extern "C" {
    pub fn g_match_info_fetch_pos(
        match_info: *const GMatchInfo,
        match_num: gint,
        start_pos: *mut gint,
        end_pos: *mut gint,
    ) -> gboolean;
}
extern "C" {
    pub fn g_match_info_fetch_named(
        match_info: *const GMatchInfo,
        name: *const gchar,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_match_info_fetch_named_pos(
        match_info: *const GMatchInfo,
        name: *const gchar,
        start_pos: *mut gint,
        end_pos: *mut gint,
    ) -> gboolean;
}
extern "C" {
    pub fn g_match_info_fetch_all(match_info: *const GMatchInfo) -> *mut *mut gchar;
}
pub type GScanner = _GScanner;
pub type GScannerConfig = _GScannerConfig;
pub type GTokenValue = _GTokenValue;
pub type GScannerMsgFunc = ::std::option::Option<
    unsafe extern "C" fn(scanner: *mut GScanner, message: *mut gchar, error: gboolean),
>;
pub const GErrorType_G_ERR_UNKNOWN: GErrorType = 0;
pub const GErrorType_G_ERR_UNEXP_EOF: GErrorType = 1;
pub const GErrorType_G_ERR_UNEXP_EOF_IN_STRING: GErrorType = 2;
pub const GErrorType_G_ERR_UNEXP_EOF_IN_COMMENT: GErrorType = 3;
pub const GErrorType_G_ERR_NON_DIGIT_IN_CONST: GErrorType = 4;
pub const GErrorType_G_ERR_DIGIT_RADIX: GErrorType = 5;
pub const GErrorType_G_ERR_FLOAT_RADIX: GErrorType = 6;
pub const GErrorType_G_ERR_FLOAT_MALFORMED: GErrorType = 7;
pub type GErrorType = ::std::os::raw::c_uint;
pub const GTokenType_G_TOKEN_EOF: GTokenType = 0;
pub const GTokenType_G_TOKEN_LEFT_PAREN: GTokenType = 40;
pub const GTokenType_G_TOKEN_RIGHT_PAREN: GTokenType = 41;
pub const GTokenType_G_TOKEN_LEFT_CURLY: GTokenType = 123;
pub const GTokenType_G_TOKEN_RIGHT_CURLY: GTokenType = 125;
pub const GTokenType_G_TOKEN_LEFT_BRACE: GTokenType = 91;
pub const GTokenType_G_TOKEN_RIGHT_BRACE: GTokenType = 93;
pub const GTokenType_G_TOKEN_EQUAL_SIGN: GTokenType = 61;
pub const GTokenType_G_TOKEN_COMMA: GTokenType = 44;
pub const GTokenType_G_TOKEN_NONE: GTokenType = 256;
pub const GTokenType_G_TOKEN_ERROR: GTokenType = 257;
pub const GTokenType_G_TOKEN_CHAR: GTokenType = 258;
pub const GTokenType_G_TOKEN_BINARY: GTokenType = 259;
pub const GTokenType_G_TOKEN_OCTAL: GTokenType = 260;
pub const GTokenType_G_TOKEN_INT: GTokenType = 261;
pub const GTokenType_G_TOKEN_HEX: GTokenType = 262;
pub const GTokenType_G_TOKEN_FLOAT: GTokenType = 263;
pub const GTokenType_G_TOKEN_STRING: GTokenType = 264;
pub const GTokenType_G_TOKEN_SYMBOL: GTokenType = 265;
pub const GTokenType_G_TOKEN_IDENTIFIER: GTokenType = 266;
pub const GTokenType_G_TOKEN_IDENTIFIER_NULL: GTokenType = 267;
pub const GTokenType_G_TOKEN_COMMENT_SINGLE: GTokenType = 268;
pub const GTokenType_G_TOKEN_COMMENT_MULTI: GTokenType = 269;
pub const GTokenType_G_TOKEN_LAST: GTokenType = 270;
pub type GTokenType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GTokenValue {
    pub v_symbol: gpointer,
    pub v_identifier: *mut gchar,
    pub v_binary: gulong,
    pub v_octal: gulong,
    pub v_int: gulong,
    pub v_int64: guint64,
    pub v_float: gdouble,
    pub v_hex: gulong,
    pub v_string: *mut gchar,
    pub v_comment: *mut gchar,
    pub v_char: guchar,
    pub v_error: guint,
}
#[test]
fn bindgen_test_layout__GTokenValue() {
    assert_eq!(
        ::std::mem::size_of::<_GTokenValue>(),
        8usize,
        concat!("Size of: ", stringify!(_GTokenValue))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTokenValue>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTokenValue))
    );
    fn test_field_v_symbol() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GTokenValue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).v_symbol) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GTokenValue),
                "::",
                stringify!(v_symbol)
            )
        );
    }
    test_field_v_symbol();
    fn test_field_v_identifier() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GTokenValue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).v_identifier) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GTokenValue),
                "::",
                stringify!(v_identifier)
            )
        );
    }
    test_field_v_identifier();
    fn test_field_v_binary() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GTokenValue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).v_binary) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GTokenValue),
                "::",
                stringify!(v_binary)
            )
        );
    }
    test_field_v_binary();
    fn test_field_v_octal() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GTokenValue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).v_octal) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GTokenValue),
                "::",
                stringify!(v_octal)
            )
        );
    }
    test_field_v_octal();
    fn test_field_v_int() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GTokenValue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).v_int) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GTokenValue),
                "::",
                stringify!(v_int)
            )
        );
    }
    test_field_v_int();
    fn test_field_v_int64() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GTokenValue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).v_int64) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GTokenValue),
                "::",
                stringify!(v_int64)
            )
        );
    }
    test_field_v_int64();
    fn test_field_v_float() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GTokenValue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).v_float) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GTokenValue),
                "::",
                stringify!(v_float)
            )
        );
    }
    test_field_v_float();
    fn test_field_v_hex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GTokenValue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).v_hex) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GTokenValue),
                "::",
                stringify!(v_hex)
            )
        );
    }
    test_field_v_hex();
    fn test_field_v_string() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GTokenValue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).v_string) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GTokenValue),
                "::",
                stringify!(v_string)
            )
        );
    }
    test_field_v_string();
    fn test_field_v_comment() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GTokenValue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).v_comment) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GTokenValue),
                "::",
                stringify!(v_comment)
            )
        );
    }
    test_field_v_comment();
    fn test_field_v_char() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GTokenValue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).v_char) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GTokenValue),
                "::",
                stringify!(v_char)
            )
        );
    }
    test_field_v_char();
    fn test_field_v_error() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GTokenValue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).v_error) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GTokenValue),
                "::",
                stringify!(v_error)
            )
        );
    }
    test_field_v_error();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GScannerConfig {
    pub cset_skip_characters: *mut gchar,
    pub cset_identifier_first: *mut gchar,
    pub cset_identifier_nth: *mut gchar,
    pub cpair_comment_single: *mut gchar,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub padding_dummy: guint,
}
#[test]
fn bindgen_test_layout__GScannerConfig() {
    assert_eq!(
        ::std::mem::size_of::<_GScannerConfig>(),
        40usize,
        concat!("Size of: ", stringify!(_GScannerConfig))
    );
    assert_eq!(
        ::std::mem::align_of::<_GScannerConfig>(),
        8usize,
        concat!("Alignment of ", stringify!(_GScannerConfig))
    );
    fn test_field_cset_skip_characters() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GScannerConfig>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cset_skip_characters) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GScannerConfig),
                "::",
                stringify!(cset_skip_characters)
            )
        );
    }
    test_field_cset_skip_characters();
    fn test_field_cset_identifier_first() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GScannerConfig>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cset_identifier_first) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_GScannerConfig),
                "::",
                stringify!(cset_identifier_first)
            )
        );
    }
    test_field_cset_identifier_first();
    fn test_field_cset_identifier_nth() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GScannerConfig>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cset_identifier_nth) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_GScannerConfig),
                "::",
                stringify!(cset_identifier_nth)
            )
        );
    }
    test_field_cset_identifier_nth();
    fn test_field_cpair_comment_single() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GScannerConfig>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cpair_comment_single) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_GScannerConfig),
                "::",
                stringify!(cpair_comment_single)
            )
        );
    }
    test_field_cpair_comment_single();
    fn test_field_padding_dummy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GScannerConfig>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).padding_dummy) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(_GScannerConfig),
                "::",
                stringify!(padding_dummy)
            )
        );
    }
    test_field_padding_dummy();
}
impl _GScannerConfig {
    #[inline]
    pub fn case_sensitive(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_case_sensitive(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn skip_comment_multi(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_skip_comment_multi(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn skip_comment_single(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_skip_comment_single(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_comment_multi(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_comment_multi(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_identifier(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_identifier(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_identifier_1char(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_identifier_1char(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_identifier_NULL(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_identifier_NULL(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_symbols(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_symbols(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_binary(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_binary(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_octal(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_octal(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_float(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_float(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_hex(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_hex(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_hex_dollar(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_hex_dollar(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_string_sq(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_string_sq(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_string_dq(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_string_dq(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn numbers_2_int(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_numbers_2_int(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int_2_float(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_int_2_float(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn identifier_2_string(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_identifier_2_string(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn char_2_token(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_char_2_token(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn symbol_2_token(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_symbol_2_token(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scope_0_fallback(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scope_0_fallback(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn store_int64(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_store_int64(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        case_sensitive: guint,
        skip_comment_multi: guint,
        skip_comment_single: guint,
        scan_comment_multi: guint,
        scan_identifier: guint,
        scan_identifier_1char: guint,
        scan_identifier_NULL: guint,
        scan_symbols: guint,
        scan_binary: guint,
        scan_octal: guint,
        scan_float: guint,
        scan_hex: guint,
        scan_hex_dollar: guint,
        scan_string_sq: guint,
        scan_string_dq: guint,
        numbers_2_int: guint,
        int_2_float: guint,
        identifier_2_string: guint,
        char_2_token: guint,
        symbol_2_token: guint,
        scope_0_fallback: guint,
        store_int64: guint,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let case_sensitive: u32 = unsafe { ::std::mem::transmute(case_sensitive) };
            case_sensitive as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let skip_comment_multi: u32 = unsafe { ::std::mem::transmute(skip_comment_multi) };
            skip_comment_multi as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let skip_comment_single: u32 = unsafe { ::std::mem::transmute(skip_comment_single) };
            skip_comment_single as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let scan_comment_multi: u32 = unsafe { ::std::mem::transmute(scan_comment_multi) };
            scan_comment_multi as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let scan_identifier: u32 = unsafe { ::std::mem::transmute(scan_identifier) };
            scan_identifier as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let scan_identifier_1char: u32 =
                unsafe { ::std::mem::transmute(scan_identifier_1char) };
            scan_identifier_1char as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let scan_identifier_NULL: u32 = unsafe { ::std::mem::transmute(scan_identifier_NULL) };
            scan_identifier_NULL as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let scan_symbols: u32 = unsafe { ::std::mem::transmute(scan_symbols) };
            scan_symbols as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let scan_binary: u32 = unsafe { ::std::mem::transmute(scan_binary) };
            scan_binary as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let scan_octal: u32 = unsafe { ::std::mem::transmute(scan_octal) };
            scan_octal as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let scan_float: u32 = unsafe { ::std::mem::transmute(scan_float) };
            scan_float as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let scan_hex: u32 = unsafe { ::std::mem::transmute(scan_hex) };
            scan_hex as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let scan_hex_dollar: u32 = unsafe { ::std::mem::transmute(scan_hex_dollar) };
            scan_hex_dollar as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let scan_string_sq: u32 = unsafe { ::std::mem::transmute(scan_string_sq) };
            scan_string_sq as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let scan_string_dq: u32 = unsafe { ::std::mem::transmute(scan_string_dq) };
            scan_string_dq as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let numbers_2_int: u32 = unsafe { ::std::mem::transmute(numbers_2_int) };
            numbers_2_int as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let int_2_float: u32 = unsafe { ::std::mem::transmute(int_2_float) };
            int_2_float as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let identifier_2_string: u32 = unsafe { ::std::mem::transmute(identifier_2_string) };
            identifier_2_string as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let char_2_token: u32 = unsafe { ::std::mem::transmute(char_2_token) };
            char_2_token as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let symbol_2_token: u32 = unsafe { ::std::mem::transmute(symbol_2_token) };
            symbol_2_token as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let scope_0_fallback: u32 = unsafe { ::std::mem::transmute(scope_0_fallback) };
            scope_0_fallback as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let store_int64: u32 = unsafe { ::std::mem::transmute(store_int64) };
            store_int64 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GScanner {
    pub user_data: gpointer,
    pub max_parse_errors: guint,
    pub parse_errors: guint,
    pub input_name: *const gchar,
    pub qdata: *mut GData,
    pub config: *mut GScannerConfig,
    pub token: GTokenType,
    pub value: GTokenValue,
    pub line: guint,
    pub position: guint,
    pub next_token: GTokenType,
    pub next_value: GTokenValue,
    pub next_line: guint,
    pub next_position: guint,
    pub symbol_table: *mut GHashTable,
    pub input_fd: gint,
    pub text: *const gchar,
    pub text_end: *const gchar,
    pub buffer: *mut gchar,
    pub scope_id: guint,
    pub msg_handler: GScannerMsgFunc,
}
#[test]
fn bindgen_test_layout__GScanner() {
    assert_eq!(
        ::std::mem::size_of::<_GScanner>(),
        144usize,
        concat!("Size of: ", stringify!(_GScanner))
    );
    assert_eq!(
        ::std::mem::align_of::<_GScanner>(),
        8usize,
        concat!("Alignment of ", stringify!(_GScanner))
    );
    fn test_field_user_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GScanner>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).user_data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GScanner),
                "::",
                stringify!(user_data)
            )
        );
    }
    test_field_user_data();
    fn test_field_max_parse_errors() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GScanner>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).max_parse_errors) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_GScanner),
                "::",
                stringify!(max_parse_errors)
            )
        );
    }
    test_field_max_parse_errors();
    fn test_field_parse_errors() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GScanner>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).parse_errors) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_GScanner),
                "::",
                stringify!(parse_errors)
            )
        );
    }
    test_field_parse_errors();
    fn test_field_input_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GScanner>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).input_name) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_GScanner),
                "::",
                stringify!(input_name)
            )
        );
    }
    test_field_input_name();
    fn test_field_qdata() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GScanner>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).qdata) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_GScanner),
                "::",
                stringify!(qdata)
            )
        );
    }
    test_field_qdata();
    fn test_field_config() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GScanner>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).config) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_GScanner),
                "::",
                stringify!(config)
            )
        );
    }
    test_field_config();
    fn test_field_token() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GScanner>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).token) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_GScanner),
                "::",
                stringify!(token)
            )
        );
    }
    test_field_token();
    fn test_field_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GScanner>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_GScanner),
                "::",
                stringify!(value)
            )
        );
    }
    test_field_value();
    fn test_field_line() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GScanner>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).line) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_GScanner),
                "::",
                stringify!(line)
            )
        );
    }
    test_field_line();
    fn test_field_position() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GScanner>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).position) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(_GScanner),
                "::",
                stringify!(position)
            )
        );
    }
    test_field_position();
    fn test_field_next_token() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GScanner>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next_token) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_GScanner),
                "::",
                stringify!(next_token)
            )
        );
    }
    test_field_next_token();
    fn test_field_next_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GScanner>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next_value) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_GScanner),
                "::",
                stringify!(next_value)
            )
        );
    }
    test_field_next_value();
    fn test_field_next_line() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GScanner>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next_line) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_GScanner),
                "::",
                stringify!(next_line)
            )
        );
    }
    test_field_next_line();
    fn test_field_next_position() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GScanner>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next_position) as usize - ptr as usize
            },
            84usize,
            concat!(
                "Offset of field: ",
                stringify!(_GScanner),
                "::",
                stringify!(next_position)
            )
        );
    }
    test_field_next_position();
    fn test_field_symbol_table() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GScanner>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).symbol_table) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_GScanner),
                "::",
                stringify!(symbol_table)
            )
        );
    }
    test_field_symbol_table();
    fn test_field_input_fd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GScanner>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).input_fd) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_GScanner),
                "::",
                stringify!(input_fd)
            )
        );
    }
    test_field_input_fd();
    fn test_field_text() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GScanner>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).text) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_GScanner),
                "::",
                stringify!(text)
            )
        );
    }
    test_field_text();
    fn test_field_text_end() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GScanner>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).text_end) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(_GScanner),
                "::",
                stringify!(text_end)
            )
        );
    }
    test_field_text_end();
    fn test_field_buffer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GScanner>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(_GScanner),
                "::",
                stringify!(buffer)
            )
        );
    }
    test_field_buffer();
    fn test_field_scope_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GScanner>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).scope_id) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(_GScanner),
                "::",
                stringify!(scope_id)
            )
        );
    }
    test_field_scope_id();
    fn test_field_msg_handler() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GScanner>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).msg_handler) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(_GScanner),
                "::",
                stringify!(msg_handler)
            )
        );
    }
    test_field_msg_handler();
}
extern "C" {
    pub fn g_scanner_new(config_templ: *const GScannerConfig) -> *mut GScanner;
}
extern "C" {
    pub fn g_scanner_destroy(scanner: *mut GScanner);
}
extern "C" {
    pub fn g_scanner_input_file(scanner: *mut GScanner, input_fd: gint);
}
extern "C" {
    pub fn g_scanner_sync_file_offset(scanner: *mut GScanner);
}
extern "C" {
    pub fn g_scanner_input_text(scanner: *mut GScanner, text: *const gchar, text_len: guint);
}
extern "C" {
    pub fn g_scanner_get_next_token(scanner: *mut GScanner) -> GTokenType;
}
extern "C" {
    pub fn g_scanner_peek_next_token(scanner: *mut GScanner) -> GTokenType;
}
extern "C" {
    pub fn g_scanner_cur_token(scanner: *mut GScanner) -> GTokenType;
}
extern "C" {
    pub fn g_scanner_cur_value(scanner: *mut GScanner) -> GTokenValue;
}
extern "C" {
    pub fn g_scanner_cur_line(scanner: *mut GScanner) -> guint;
}
extern "C" {
    pub fn g_scanner_cur_position(scanner: *mut GScanner) -> guint;
}
extern "C" {
    pub fn g_scanner_eof(scanner: *mut GScanner) -> gboolean;
}
extern "C" {
    pub fn g_scanner_set_scope(scanner: *mut GScanner, scope_id: guint) -> guint;
}
extern "C" {
    pub fn g_scanner_scope_add_symbol(
        scanner: *mut GScanner,
        scope_id: guint,
        symbol: *const gchar,
        value: gpointer,
    );
}
extern "C" {
    pub fn g_scanner_scope_remove_symbol(
        scanner: *mut GScanner,
        scope_id: guint,
        symbol: *const gchar,
    );
}
extern "C" {
    pub fn g_scanner_scope_lookup_symbol(
        scanner: *mut GScanner,
        scope_id: guint,
        symbol: *const gchar,
    ) -> gpointer;
}
extern "C" {
    pub fn g_scanner_scope_foreach_symbol(
        scanner: *mut GScanner,
        scope_id: guint,
        func: GHFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_scanner_lookup_symbol(scanner: *mut GScanner, symbol: *const gchar) -> gpointer;
}
extern "C" {
    pub fn g_scanner_unexp_token(
        scanner: *mut GScanner,
        expected_token: GTokenType,
        identifier_spec: *const gchar,
        symbol_spec: *const gchar,
        symbol_name: *const gchar,
        message: *const gchar,
        is_error: gint,
    );
}
extern "C" {
    pub fn g_scanner_error(scanner: *mut GScanner, format: *const gchar, ...);
}
extern "C" {
    pub fn g_scanner_warn(scanner: *mut GScanner, format: *const gchar, ...);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSequence {
    _unused: [u8; 0],
}
pub type GSequence = _GSequence;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSequenceNode {
    _unused: [u8; 0],
}
pub type GSequenceIter = _GSequenceNode;
pub type GSequenceIterCompareFunc = ::std::option::Option<
    unsafe extern "C" fn(a: *mut GSequenceIter, b: *mut GSequenceIter, data: gpointer) -> gint,
>;
extern "C" {
    pub fn g_sequence_new(data_destroy: GDestroyNotify) -> *mut GSequence;
}
extern "C" {
    pub fn g_sequence_free(seq: *mut GSequence);
}
extern "C" {
    pub fn g_sequence_get_length(seq: *mut GSequence) -> gint;
}
extern "C" {
    pub fn g_sequence_foreach(seq: *mut GSequence, func: GFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_sequence_foreach_range(
        begin: *mut GSequenceIter,
        end: *mut GSequenceIter,
        func: GFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_sequence_sort(seq: *mut GSequence, cmp_func: GCompareDataFunc, cmp_data: gpointer);
}
extern "C" {
    pub fn g_sequence_sort_iter(
        seq: *mut GSequence,
        cmp_func: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    );
}
extern "C" {
    pub fn g_sequence_is_empty(seq: *mut GSequence) -> gboolean;
}
extern "C" {
    pub fn g_sequence_get_begin_iter(seq: *mut GSequence) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_get_end_iter(seq: *mut GSequence) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_get_iter_at_pos(seq: *mut GSequence, pos: gint) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_append(seq: *mut GSequence, data: gpointer) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_prepend(seq: *mut GSequence, data: gpointer) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_insert_before(iter: *mut GSequenceIter, data: gpointer)
        -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_move(src: *mut GSequenceIter, dest: *mut GSequenceIter);
}
extern "C" {
    pub fn g_sequence_swap(a: *mut GSequenceIter, b: *mut GSequenceIter);
}
extern "C" {
    pub fn g_sequence_insert_sorted(
        seq: *mut GSequence,
        data: gpointer,
        cmp_func: GCompareDataFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_insert_sorted_iter(
        seq: *mut GSequence,
        data: gpointer,
        iter_cmp: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_sort_changed(
        iter: *mut GSequenceIter,
        cmp_func: GCompareDataFunc,
        cmp_data: gpointer,
    );
}
extern "C" {
    pub fn g_sequence_sort_changed_iter(
        iter: *mut GSequenceIter,
        iter_cmp: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    );
}
extern "C" {
    pub fn g_sequence_remove(iter: *mut GSequenceIter);
}
extern "C" {
    pub fn g_sequence_remove_range(begin: *mut GSequenceIter, end: *mut GSequenceIter);
}
extern "C" {
    pub fn g_sequence_move_range(
        dest: *mut GSequenceIter,
        begin: *mut GSequenceIter,
        end: *mut GSequenceIter,
    );
}
extern "C" {
    pub fn g_sequence_search(
        seq: *mut GSequence,
        data: gpointer,
        cmp_func: GCompareDataFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_search_iter(
        seq: *mut GSequence,
        data: gpointer,
        iter_cmp: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_lookup(
        seq: *mut GSequence,
        data: gpointer,
        cmp_func: GCompareDataFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_lookup_iter(
        seq: *mut GSequence,
        data: gpointer,
        iter_cmp: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_get(iter: *mut GSequenceIter) -> gpointer;
}
extern "C" {
    pub fn g_sequence_set(iter: *mut GSequenceIter, data: gpointer);
}
extern "C" {
    pub fn g_sequence_iter_is_begin(iter: *mut GSequenceIter) -> gboolean;
}
extern "C" {
    pub fn g_sequence_iter_is_end(iter: *mut GSequenceIter) -> gboolean;
}
extern "C" {
    pub fn g_sequence_iter_next(iter: *mut GSequenceIter) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_iter_prev(iter: *mut GSequenceIter) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_iter_get_position(iter: *mut GSequenceIter) -> gint;
}
extern "C" {
    pub fn g_sequence_iter_move(iter: *mut GSequenceIter, delta: gint) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_iter_get_sequence(iter: *mut GSequenceIter) -> *mut GSequence;
}
extern "C" {
    pub fn g_sequence_iter_compare(a: *mut GSequenceIter, b: *mut GSequenceIter) -> gint;
}
extern "C" {
    pub fn g_sequence_range_get_midpoint(
        begin: *mut GSequenceIter,
        end: *mut GSequenceIter,
    ) -> *mut GSequenceIter;
}
pub const GShellError_G_SHELL_ERROR_BAD_QUOTING: GShellError = 0;
pub const GShellError_G_SHELL_ERROR_EMPTY_STRING: GShellError = 1;
pub const GShellError_G_SHELL_ERROR_FAILED: GShellError = 2;
pub type GShellError = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_shell_error_quark() -> GQuark;
}
extern "C" {
    pub fn g_shell_quote(unquoted_string: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_shell_unquote(quoted_string: *const gchar, error: *mut *mut GError) -> *mut gchar;
}
extern "C" {
    pub fn g_shell_parse_argv(
        command_line: *const gchar,
        argcp: *mut gint,
        argvp: *mut *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_slice_alloc(block_size: gsize) -> gpointer;
}
extern "C" {
    pub fn g_slice_alloc0(block_size: gsize) -> gpointer;
}
extern "C" {
    pub fn g_slice_copy(block_size: gsize, mem_block: gconstpointer) -> gpointer;
}
extern "C" {
    pub fn g_slice_free1(block_size: gsize, mem_block: gpointer);
}
extern "C" {
    pub fn g_slice_free_chain_with_offset(
        block_size: gsize,
        mem_chain: gpointer,
        next_offset: gsize,
    );
}
pub const GSliceConfig_G_SLICE_CONFIG_ALWAYS_MALLOC: GSliceConfig = 1;
pub const GSliceConfig_G_SLICE_CONFIG_BYPASS_MAGAZINES: GSliceConfig = 2;
pub const GSliceConfig_G_SLICE_CONFIG_WORKING_SET_MSECS: GSliceConfig = 3;
pub const GSliceConfig_G_SLICE_CONFIG_COLOR_INCREMENT: GSliceConfig = 4;
pub const GSliceConfig_G_SLICE_CONFIG_CHUNK_SIZES: GSliceConfig = 5;
pub const GSliceConfig_G_SLICE_CONFIG_CONTENTION_COUNTER: GSliceConfig = 6;
pub type GSliceConfig = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_slice_set_config(ckey: GSliceConfig, value: gint64);
}
extern "C" {
    pub fn g_slice_get_config(ckey: GSliceConfig) -> gint64;
}
extern "C" {
    pub fn g_slice_get_config_state(
        ckey: GSliceConfig,
        address: gint64,
        n_values: *mut guint,
    ) -> *mut gint64;
}
pub const GSpawnError_G_SPAWN_ERROR_FORK: GSpawnError = 0;
pub const GSpawnError_G_SPAWN_ERROR_READ: GSpawnError = 1;
pub const GSpawnError_G_SPAWN_ERROR_CHDIR: GSpawnError = 2;
pub const GSpawnError_G_SPAWN_ERROR_ACCES: GSpawnError = 3;
pub const GSpawnError_G_SPAWN_ERROR_PERM: GSpawnError = 4;
pub const GSpawnError_G_SPAWN_ERROR_TOO_BIG: GSpawnError = 5;
pub const GSpawnError_G_SPAWN_ERROR_2BIG: GSpawnError = 5;
pub const GSpawnError_G_SPAWN_ERROR_NOEXEC: GSpawnError = 6;
pub const GSpawnError_G_SPAWN_ERROR_NAMETOOLONG: GSpawnError = 7;
pub const GSpawnError_G_SPAWN_ERROR_NOENT: GSpawnError = 8;
pub const GSpawnError_G_SPAWN_ERROR_NOMEM: GSpawnError = 9;
pub const GSpawnError_G_SPAWN_ERROR_NOTDIR: GSpawnError = 10;
pub const GSpawnError_G_SPAWN_ERROR_LOOP: GSpawnError = 11;
pub const GSpawnError_G_SPAWN_ERROR_TXTBUSY: GSpawnError = 12;
pub const GSpawnError_G_SPAWN_ERROR_IO: GSpawnError = 13;
pub const GSpawnError_G_SPAWN_ERROR_NFILE: GSpawnError = 14;
pub const GSpawnError_G_SPAWN_ERROR_MFILE: GSpawnError = 15;
pub const GSpawnError_G_SPAWN_ERROR_INVAL: GSpawnError = 16;
pub const GSpawnError_G_SPAWN_ERROR_ISDIR: GSpawnError = 17;
pub const GSpawnError_G_SPAWN_ERROR_LIBBAD: GSpawnError = 18;
pub const GSpawnError_G_SPAWN_ERROR_FAILED: GSpawnError = 19;
#[doc = " GSpawnError:"]
#[doc = " @G_SPAWN_ERROR_FORK: Fork failed due to lack of memory."]
#[doc = " @G_SPAWN_ERROR_READ: Read or select on pipes failed."]
#[doc = " @G_SPAWN_ERROR_CHDIR: Changing to working directory failed."]
#[doc = " @G_SPAWN_ERROR_ACCES: execv() returned `EACCES`"]
#[doc = " @G_SPAWN_ERROR_PERM: execv() returned `EPERM`"]
#[doc = " @G_SPAWN_ERROR_TOO_BIG: execv() returned `E2BIG`"]
#[doc = " @G_SPAWN_ERROR_2BIG: deprecated alias for %G_SPAWN_ERROR_TOO_BIG (deprecated since GLib 2.32)"]
#[doc = " @G_SPAWN_ERROR_NOEXEC: execv() returned `ENOEXEC`"]
#[doc = " @G_SPAWN_ERROR_NAMETOOLONG: execv() returned `ENAMETOOLONG`"]
#[doc = " @G_SPAWN_ERROR_NOENT: execv() returned `ENOENT`"]
#[doc = " @G_SPAWN_ERROR_NOMEM: execv() returned `ENOMEM`"]
#[doc = " @G_SPAWN_ERROR_NOTDIR: execv() returned `ENOTDIR`"]
#[doc = " @G_SPAWN_ERROR_LOOP: execv() returned `ELOOP`"]
#[doc = " @G_SPAWN_ERROR_TXTBUSY: execv() returned `ETXTBUSY`"]
#[doc = " @G_SPAWN_ERROR_IO: execv() returned `EIO`"]
#[doc = " @G_SPAWN_ERROR_NFILE: execv() returned `ENFILE`"]
#[doc = " @G_SPAWN_ERROR_MFILE: execv() returned `EMFILE`"]
#[doc = " @G_SPAWN_ERROR_INVAL: execv() returned `EINVAL`"]
#[doc = " @G_SPAWN_ERROR_ISDIR: execv() returned `EISDIR`"]
#[doc = " @G_SPAWN_ERROR_LIBBAD: execv() returned `ELIBBAD`"]
#[doc = " @G_SPAWN_ERROR_FAILED: Some other fatal failure,"]
#[doc = "   `error->message` should explain."]
#[doc = ""]
#[doc = " Error codes returned by spawning processes."]
pub type GSpawnError = ::std::os::raw::c_uint;
#[doc = " GSpawnChildSetupFunc:"]
#[doc = " @user_data: (closure): user data to pass to the function."]
#[doc = ""]
#[doc = " Specifies the type of the setup function passed to g_spawn_async(),"]
#[doc = " g_spawn_sync() and g_spawn_async_with_pipes(), which can, in very"]
#[doc = " limited ways, be used to affect the child's execution."]
#[doc = ""]
#[doc = " On POSIX platforms, the function is called in the child after GLib"]
#[doc = " has performed all the setup it plans to perform, but before calling"]
#[doc = " exec(). Actions taken in this function will only affect the child,"]
#[doc = " not the parent."]
#[doc = ""]
#[doc = " On Windows, the function is called in the parent. Its usefulness on"]
#[doc = " Windows is thus questionable. In many cases executing the child setup"]
#[doc = " function in the parent can have ill effects, and you should be very"]
#[doc = " careful when porting software to Windows that uses child setup"]
#[doc = " functions."]
#[doc = ""]
#[doc = " However, even on POSIX, you are extremely limited in what you can"]
#[doc = " safely do from a #GSpawnChildSetupFunc, because any mutexes that were"]
#[doc = " held by other threads in the parent process at the time of the fork()"]
#[doc = " will still be locked in the child process, and they will never be"]
#[doc = " unlocked (since the threads that held them don't exist in the child)."]
#[doc = " POSIX allows only async-signal-safe functions (see signal(7)) to be"]
#[doc = " called in the child between fork() and exec(), which drastically limits"]
#[doc = " the usefulness of child setup functions."]
#[doc = ""]
#[doc = " In particular, it is not safe to call any function which may"]
#[doc = " call malloc(), which includes POSIX functions such as setenv()."]
#[doc = " If you need to set up the child environment differently from"]
#[doc = " the parent, you should use g_get_environ(), g_environ_setenv(),"]
#[doc = " and g_environ_unsetenv(), and then pass the complete environment"]
#[doc = " list to the `g_spawn...` function."]
pub type GSpawnChildSetupFunc = ::std::option::Option<unsafe extern "C" fn(user_data: gpointer)>;
pub const GSpawnFlags_G_SPAWN_DEFAULT: GSpawnFlags = 0;
pub const GSpawnFlags_G_SPAWN_LEAVE_DESCRIPTORS_OPEN: GSpawnFlags = 1;
pub const GSpawnFlags_G_SPAWN_DO_NOT_REAP_CHILD: GSpawnFlags = 2;
pub const GSpawnFlags_G_SPAWN_SEARCH_PATH: GSpawnFlags = 4;
pub const GSpawnFlags_G_SPAWN_STDOUT_TO_DEV_NULL: GSpawnFlags = 8;
pub const GSpawnFlags_G_SPAWN_STDERR_TO_DEV_NULL: GSpawnFlags = 16;
pub const GSpawnFlags_G_SPAWN_CHILD_INHERITS_STDIN: GSpawnFlags = 32;
pub const GSpawnFlags_G_SPAWN_FILE_AND_ARGV_ZERO: GSpawnFlags = 64;
pub const GSpawnFlags_G_SPAWN_SEARCH_PATH_FROM_ENVP: GSpawnFlags = 128;
pub const GSpawnFlags_G_SPAWN_CLOEXEC_PIPES: GSpawnFlags = 256;
#[doc = " GSpawnFlags:"]
#[doc = " @G_SPAWN_DEFAULT: no flags, default behaviour"]
#[doc = " @G_SPAWN_LEAVE_DESCRIPTORS_OPEN: the parent's open file descriptors will"]
#[doc = "     be inherited by the child; otherwise all descriptors except stdin,"]
#[doc = "     stdout and stderr will be closed before calling exec() in the child."]
#[doc = " @G_SPAWN_DO_NOT_REAP_CHILD: the child will not be automatically reaped;"]
#[doc = "     you must use g_child_watch_add() yourself (or call waitpid() or handle"]
#[doc = "     `SIGCHLD` yourself), or the child will become a zombie."]
#[doc = " @G_SPAWN_SEARCH_PATH: `argv[0]` need not be an absolute path, it will be"]
#[doc = "     looked for in the user's `PATH`."]
#[doc = " @G_SPAWN_STDOUT_TO_DEV_NULL: the child's standard output will be discarded,"]
#[doc = "     instead of going to the same location as the parent's standard output."]
#[doc = " @G_SPAWN_STDERR_TO_DEV_NULL: the child's standard error will be discarded."]
#[doc = " @G_SPAWN_CHILD_INHERITS_STDIN: the child will inherit the parent's standard"]
#[doc = "     input (by default, the child's standard input is attached to `/dev/null`)."]
#[doc = " @G_SPAWN_FILE_AND_ARGV_ZERO: the first element of `argv` is the file to"]
#[doc = "     execute, while the remaining elements are the actual argument vector"]
#[doc = "     to pass to the file. Normally g_spawn_async_with_pipes() uses `argv[0]`"]
#[doc = "     as the file to execute, and passes all of `argv` to the child."]
#[doc = " @G_SPAWN_SEARCH_PATH_FROM_ENVP: if `argv[0]` is not an abolute path,"]
#[doc = "     it will be looked for in the `PATH` from the passed child environment."]
#[doc = "     Since: 2.34"]
#[doc = " @G_SPAWN_CLOEXEC_PIPES: create all pipes with the `O_CLOEXEC` flag set."]
#[doc = "     Since: 2.40"]
#[doc = ""]
#[doc = " Flags passed to g_spawn_sync(), g_spawn_async() and g_spawn_async_with_pipes()."]
pub type GSpawnFlags = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_spawn_error_quark() -> GQuark;
}
extern "C" {
    pub fn g_spawn_exit_error_quark() -> GQuark;
}
extern "C" {
    pub fn g_spawn_async(
        working_directory: *const gchar,
        argv: *mut *mut gchar,
        envp: *mut *mut gchar,
        flags: GSpawnFlags,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        child_pid: *mut GPid,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_spawn_async_with_pipes(
        working_directory: *const gchar,
        argv: *mut *mut gchar,
        envp: *mut *mut gchar,
        flags: GSpawnFlags,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        child_pid: *mut GPid,
        standard_input: *mut gint,
        standard_output: *mut gint,
        standard_error: *mut gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_spawn_async_with_fds(
        working_directory: *const gchar,
        argv: *mut *mut gchar,
        envp: *mut *mut gchar,
        flags: GSpawnFlags,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        child_pid: *mut GPid,
        stdin_fd: gint,
        stdout_fd: gint,
        stderr_fd: gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_spawn_sync(
        working_directory: *const gchar,
        argv: *mut *mut gchar,
        envp: *mut *mut gchar,
        flags: GSpawnFlags,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        standard_output: *mut *mut gchar,
        standard_error: *mut *mut gchar,
        exit_status: *mut gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_spawn_command_line_sync(
        command_line: *const gchar,
        standard_output: *mut *mut gchar,
        standard_error: *mut *mut gchar,
        exit_status: *mut gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_spawn_command_line_async(
        command_line: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_spawn_check_exit_status(exit_status: gint, error: *mut *mut GError) -> gboolean;
}
extern "C" {
    pub fn g_spawn_close_pid(pid: GPid);
}
pub const GAsciiType_G_ASCII_ALNUM: GAsciiType = 1;
pub const GAsciiType_G_ASCII_ALPHA: GAsciiType = 2;
pub const GAsciiType_G_ASCII_CNTRL: GAsciiType = 4;
pub const GAsciiType_G_ASCII_DIGIT: GAsciiType = 8;
pub const GAsciiType_G_ASCII_GRAPH: GAsciiType = 16;
pub const GAsciiType_G_ASCII_LOWER: GAsciiType = 32;
pub const GAsciiType_G_ASCII_PRINT: GAsciiType = 64;
pub const GAsciiType_G_ASCII_PUNCT: GAsciiType = 128;
pub const GAsciiType_G_ASCII_SPACE: GAsciiType = 256;
pub const GAsciiType_G_ASCII_UPPER: GAsciiType = 512;
pub const GAsciiType_G_ASCII_XDIGIT: GAsciiType = 1024;
pub type GAsciiType = ::std::os::raw::c_uint;
extern "C" {
    pub static g_ascii_table: *const guint16;
}
extern "C" {
    pub fn g_ascii_tolower(c: gchar) -> gchar;
}
extern "C" {
    pub fn g_ascii_toupper(c: gchar) -> gchar;
}
extern "C" {
    pub fn g_ascii_digit_value(c: gchar) -> gint;
}
extern "C" {
    pub fn g_ascii_xdigit_value(c: gchar) -> gint;
}
extern "C" {
    pub fn g_strdelimit(
        string: *mut gchar,
        delimiters: *const gchar,
        new_delimiter: gchar,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_strcanon(
        string: *mut gchar,
        valid_chars: *const gchar,
        substitutor: gchar,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_strerror(errnum: gint) -> *const gchar;
}
extern "C" {
    pub fn g_strsignal(signum: gint) -> *const gchar;
}
extern "C" {
    pub fn g_strreverse(string: *mut gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_strlcpy(dest: *mut gchar, src: *const gchar, dest_size: gsize) -> gsize;
}
extern "C" {
    pub fn g_strlcat(dest: *mut gchar, src: *const gchar, dest_size: gsize) -> gsize;
}
extern "C" {
    pub fn g_strstr_len(
        haystack: *const gchar,
        haystack_len: gssize,
        needle: *const gchar,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_strrstr(haystack: *const gchar, needle: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_strrstr_len(
        haystack: *const gchar,
        haystack_len: gssize,
        needle: *const gchar,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_str_has_suffix(str_: *const gchar, suffix: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_str_has_prefix(str_: *const gchar, prefix: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_strtod(nptr: *const gchar, endptr: *mut *mut gchar) -> gdouble;
}
extern "C" {
    pub fn g_ascii_strtod(nptr: *const gchar, endptr: *mut *mut gchar) -> gdouble;
}
extern "C" {
    pub fn g_ascii_strtoull(nptr: *const gchar, endptr: *mut *mut gchar, base: guint) -> guint64;
}
extern "C" {
    pub fn g_ascii_strtoll(nptr: *const gchar, endptr: *mut *mut gchar, base: guint) -> gint64;
}
extern "C" {
    pub fn g_ascii_dtostr(buffer: *mut gchar, buf_len: gint, d: gdouble) -> *mut gchar;
}
extern "C" {
    pub fn g_ascii_formatd(
        buffer: *mut gchar,
        buf_len: gint,
        format: *const gchar,
        d: gdouble,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_strchug(string: *mut gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_strchomp(string: *mut gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_ascii_strcasecmp(s1: *const gchar, s2: *const gchar) -> gint;
}
extern "C" {
    pub fn g_ascii_strncasecmp(s1: *const gchar, s2: *const gchar, n: gsize) -> gint;
}
extern "C" {
    pub fn g_ascii_strdown(str_: *const gchar, len: gssize) -> *mut gchar;
}
extern "C" {
    pub fn g_ascii_strup(str_: *const gchar, len: gssize) -> *mut gchar;
}
extern "C" {
    pub fn g_str_is_ascii(str_: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_strcasecmp(s1: *const gchar, s2: *const gchar) -> gint;
}
extern "C" {
    pub fn g_strncasecmp(s1: *const gchar, s2: *const gchar, n: guint) -> gint;
}
extern "C" {
    pub fn g_strdown(string: *mut gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_strup(string: *mut gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_strdup(str_: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_strdup_printf(format: *const gchar, ...) -> *mut gchar;
}
extern "C" {
    pub fn g_strdup_vprintf(format: *const gchar, args: va_list) -> *mut gchar;
}
extern "C" {
    pub fn g_strndup(str_: *const gchar, n: gsize) -> *mut gchar;
}
extern "C" {
    pub fn g_strnfill(length: gsize, fill_char: gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_strconcat(string1: *const gchar, ...) -> *mut gchar;
}
extern "C" {
    pub fn g_strjoin(separator: *const gchar, ...) -> *mut gchar;
}
extern "C" {
    pub fn g_strcompress(source: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_strescape(source: *const gchar, exceptions: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_memdup(mem: gconstpointer, byte_size: guint) -> gpointer;
}
pub type GStrv = *mut *mut gchar;
extern "C" {
    pub fn g_strsplit(
        string: *const gchar,
        delimiter: *const gchar,
        max_tokens: gint,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_strsplit_set(
        string: *const gchar,
        delimiters: *const gchar,
        max_tokens: gint,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_strjoinv(separator: *const gchar, str_array: *mut *mut gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_strfreev(str_array: *mut *mut gchar);
}
extern "C" {
    pub fn g_strdupv(str_array: *mut *mut gchar) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_strv_length(str_array: *mut *mut gchar) -> guint;
}
extern "C" {
    pub fn g_stpcpy(dest: *mut gchar, src: *const ::std::os::raw::c_char) -> *mut gchar;
}
extern "C" {
    pub fn g_str_to_ascii(str_: *const gchar, from_locale: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_str_tokenize_and_fold(
        string: *const gchar,
        translit_locale: *const gchar,
        ascii_alternates: *mut *mut *mut gchar,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_str_match_string(
        search_term: *const gchar,
        potential_hit: *const gchar,
        accept_alternates: gboolean,
    ) -> gboolean;
}
extern "C" {
    pub fn g_strv_contains(strv: *const *const gchar, str_: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_strv_equal(strv1: *const *const gchar, strv2: *const *const gchar) -> gboolean;
}
pub const GNumberParserError_G_NUMBER_PARSER_ERROR_INVALID: GNumberParserError = 0;
pub const GNumberParserError_G_NUMBER_PARSER_ERROR_OUT_OF_BOUNDS: GNumberParserError = 1;
#[doc = " GNumberParserError:"]
#[doc = " @G_NUMBER_PARSER_ERROR_INVALID: String was not a valid number."]
#[doc = " @G_NUMBER_PARSER_ERROR_OUT_OF_BOUNDS: String was a number, but out of bounds."]
#[doc = ""]
#[doc = " Error codes returned by functions converting a string to a number."]
#[doc = ""]
#[doc = " Since: 2.54"]
pub type GNumberParserError = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_number_parser_error_quark() -> GQuark;
}
extern "C" {
    pub fn g_ascii_string_to_signed(
        str_: *const gchar,
        base: guint,
        min: gint64,
        max: gint64,
        out_num: *mut gint64,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_ascii_string_to_unsigned(
        str_: *const gchar,
        base: guint,
        min: guint64,
        max: guint64,
        out_num: *mut guint64,
        error: *mut *mut GError,
    ) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GStringChunk {
    _unused: [u8; 0],
}
pub type GStringChunk = _GStringChunk;
extern "C" {
    pub fn g_string_chunk_new(size: gsize) -> *mut GStringChunk;
}
extern "C" {
    pub fn g_string_chunk_free(chunk: *mut GStringChunk);
}
extern "C" {
    pub fn g_string_chunk_clear(chunk: *mut GStringChunk);
}
extern "C" {
    pub fn g_string_chunk_insert(chunk: *mut GStringChunk, string: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_string_chunk_insert_len(
        chunk: *mut GStringChunk,
        string: *const gchar,
        len: gssize,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_string_chunk_insert_const(
        chunk: *mut GStringChunk,
        string: *const gchar,
    ) -> *mut gchar;
}
extern "C" {
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strcoll_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: size_t,
        __l: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        __string: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: size_t) -> size_t;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strerror_l(
        __errnum: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn bcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(
        __src: *const ::std::os::raw::c_void,
        __dest: *mut ::std::os::raw::c_void,
        __n: size_t,
    );
}
extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn index(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(__l: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(__ll: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: size_t,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn explicit_bzero(__s: *mut ::std::os::raw::c_void, __n: size_t);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GTestCase {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GTestSuite {
    _unused: [u8; 0],
}
pub type GTestFunc = ::std::option::Option<unsafe extern "C" fn()>;
pub type GTestDataFunc = ::std::option::Option<unsafe extern "C" fn(user_data: gconstpointer)>;
pub type GTestFixtureFunc =
    ::std::option::Option<unsafe extern "C" fn(fixture: gpointer, user_data: gconstpointer)>;
extern "C" {
    pub fn g_strcmp0(
        str1: *const ::std::os::raw::c_char,
        str2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn g_test_minimized_result(
        minimized_quantity: f64,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn g_test_maximized_result(
        maximized_quantity: f64,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn g_test_init(
        argc: *mut ::std::os::raw::c_int,
        argv: *mut *mut *mut ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn g_test_subprocess() -> gboolean;
}
extern "C" {
    pub fn g_test_run() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn g_test_add_func(testpath: *const ::std::os::raw::c_char, test_func: GTestFunc);
}
extern "C" {
    pub fn g_test_add_data_func(
        testpath: *const ::std::os::raw::c_char,
        test_data: gconstpointer,
        test_func: GTestDataFunc,
    );
}
extern "C" {
    pub fn g_test_add_data_func_full(
        testpath: *const ::std::os::raw::c_char,
        test_data: gpointer,
        test_func: GTestDataFunc,
        data_free_func: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_test_fail();
}
extern "C" {
    pub fn g_test_incomplete(msg: *const gchar);
}
extern "C" {
    pub fn g_test_skip(msg: *const gchar);
}
extern "C" {
    pub fn g_test_failed() -> gboolean;
}
extern "C" {
    pub fn g_test_set_nonfatal_assertions();
}
extern "C" {
    pub fn g_test_message(format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn g_test_bug_base(uri_pattern: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn g_test_bug(bug_uri_snippet: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn g_test_summary(summary: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn g_test_timer_start();
}
extern "C" {
    pub fn g_test_timer_elapsed() -> f64;
}
extern "C" {
    pub fn g_test_timer_last() -> f64;
}
extern "C" {
    pub fn g_test_queue_free(gfree_pointer: gpointer);
}
extern "C" {
    pub fn g_test_queue_destroy(destroy_func: GDestroyNotify, destroy_data: gpointer);
}
pub const GTestTrapFlags_G_TEST_TRAP_SILENCE_STDOUT: GTestTrapFlags = 128;
pub const GTestTrapFlags_G_TEST_TRAP_SILENCE_STDERR: GTestTrapFlags = 256;
pub const GTestTrapFlags_G_TEST_TRAP_INHERIT_STDIN: GTestTrapFlags = 512;
#[doc = " GTestTrapFlags:"]
#[doc = " @G_TEST_TRAP_SILENCE_STDOUT: Redirect stdout of the test child to"]
#[doc = "     `/dev/null` so it cannot be observed on the console during test"]
#[doc = "     runs. The actual output is still captured though to allow later"]
#[doc = "     tests with g_test_trap_assert_stdout()."]
#[doc = " @G_TEST_TRAP_SILENCE_STDERR: Redirect stderr of the test child to"]
#[doc = "     `/dev/null` so it cannot be observed on the console during test"]
#[doc = "     runs. The actual output is still captured though to allow later"]
#[doc = "     tests with g_test_trap_assert_stderr()."]
#[doc = " @G_TEST_TRAP_INHERIT_STDIN: If this flag is given, stdin of the"]
#[doc = "     child process is shared with stdin of its parent process."]
#[doc = "     It is redirected to `/dev/null` otherwise."]
#[doc = ""]
#[doc = " Test traps are guards around forked tests."]
#[doc = " These flags determine what traps to set."]
#[doc = ""]
#[doc = " Deprecated: 2.38: #GTestTrapFlags is used only with g_test_trap_fork(),"]
#[doc = " which is deprecated. g_test_trap_subprocess() uses"]
#[doc = " #GTestSubprocessFlags."]
pub type GTestTrapFlags = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_test_trap_fork(usec_timeout: guint64, test_trap_flags: GTestTrapFlags) -> gboolean;
}
pub const GTestSubprocessFlags_G_TEST_SUBPROCESS_INHERIT_STDIN: GTestSubprocessFlags = 1;
pub const GTestSubprocessFlags_G_TEST_SUBPROCESS_INHERIT_STDOUT: GTestSubprocessFlags = 2;
pub const GTestSubprocessFlags_G_TEST_SUBPROCESS_INHERIT_STDERR: GTestSubprocessFlags = 4;
pub type GTestSubprocessFlags = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_test_trap_subprocess(
        test_path: *const ::std::os::raw::c_char,
        usec_timeout: guint64,
        test_flags: GTestSubprocessFlags,
    );
}
extern "C" {
    pub fn g_test_trap_has_passed() -> gboolean;
}
extern "C" {
    pub fn g_test_trap_reached_timeout() -> gboolean;
}
extern "C" {
    pub fn g_test_rand_int() -> gint32;
}
extern "C" {
    pub fn g_test_rand_int_range(begin: gint32, end: gint32) -> gint32;
}
extern "C" {
    pub fn g_test_rand_double() -> f64;
}
extern "C" {
    pub fn g_test_rand_double_range(range_start: f64, range_end: f64) -> f64;
}
extern "C" {
    pub fn g_test_create_case(
        test_name: *const ::std::os::raw::c_char,
        data_size: gsize,
        test_data: gconstpointer,
        data_setup: GTestFixtureFunc,
        data_test: GTestFixtureFunc,
        data_teardown: GTestFixtureFunc,
    ) -> *mut GTestCase;
}
extern "C" {
    pub fn g_test_create_suite(suite_name: *const ::std::os::raw::c_char) -> *mut GTestSuite;
}
extern "C" {
    pub fn g_test_get_root() -> *mut GTestSuite;
}
extern "C" {
    pub fn g_test_suite_add(suite: *mut GTestSuite, test_case: *mut GTestCase);
}
extern "C" {
    pub fn g_test_suite_add_suite(suite: *mut GTestSuite, nestedsuite: *mut GTestSuite);
}
extern "C" {
    pub fn g_test_run_suite(suite: *mut GTestSuite) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn g_test_trap_assertions(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        assertion_flags: guint64,
        pattern: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_assertion_message(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        message: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_assertion_message_expr(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        expr: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_assertion_message_cmpstr(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        expr: *const ::std::os::raw::c_char,
        arg1: *const ::std::os::raw::c_char,
        cmp: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_assertion_message_cmpnum(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        expr: *const ::std::os::raw::c_char,
        arg1: u128,
        cmp: *const ::std::os::raw::c_char,
        arg2: u128,
        numtype: ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_assertion_message_error(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        expr: *const ::std::os::raw::c_char,
        error: *const GError,
        error_domain: GQuark,
        error_code: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn g_test_add_vtable(
        testpath: *const ::std::os::raw::c_char,
        data_size: gsize,
        test_data: gconstpointer,
        data_setup: GTestFixtureFunc,
        data_test: GTestFixtureFunc,
        data_teardown: GTestFixtureFunc,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GTestConfig {
    pub test_initialized: gboolean,
    pub test_quick: gboolean,
    pub test_perf: gboolean,
    pub test_verbose: gboolean,
    pub test_quiet: gboolean,
    pub test_undefined: gboolean,
}
#[test]
fn bindgen_test_layout_GTestConfig() {
    assert_eq!(
        ::std::mem::size_of::<GTestConfig>(),
        24usize,
        concat!("Size of: ", stringify!(GTestConfig))
    );
    assert_eq!(
        ::std::mem::align_of::<GTestConfig>(),
        4usize,
        concat!("Alignment of ", stringify!(GTestConfig))
    );
    fn test_field_test_initialized() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<GTestConfig>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).test_initialized) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(GTestConfig),
                "::",
                stringify!(test_initialized)
            )
        );
    }
    test_field_test_initialized();
    fn test_field_test_quick() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<GTestConfig>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).test_quick) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(GTestConfig),
                "::",
                stringify!(test_quick)
            )
        );
    }
    test_field_test_quick();
    fn test_field_test_perf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<GTestConfig>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).test_perf) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(GTestConfig),
                "::",
                stringify!(test_perf)
            )
        );
    }
    test_field_test_perf();
    fn test_field_test_verbose() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<GTestConfig>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).test_verbose) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(GTestConfig),
                "::",
                stringify!(test_verbose)
            )
        );
    }
    test_field_test_verbose();
    fn test_field_test_quiet() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<GTestConfig>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).test_quiet) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(GTestConfig),
                "::",
                stringify!(test_quiet)
            )
        );
    }
    test_field_test_quiet();
    fn test_field_test_undefined() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<GTestConfig>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).test_undefined) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(GTestConfig),
                "::",
                stringify!(test_undefined)
            )
        );
    }
    test_field_test_undefined();
}
extern "C" {
    pub static g_test_config_vars: *const GTestConfig;
}
pub const GTestResult_G_TEST_RUN_SUCCESS: GTestResult = 0;
pub const GTestResult_G_TEST_RUN_SKIPPED: GTestResult = 1;
pub const GTestResult_G_TEST_RUN_FAILURE: GTestResult = 2;
pub const GTestResult_G_TEST_RUN_INCOMPLETE: GTestResult = 3;
pub type GTestResult = ::std::os::raw::c_uint;
pub const GTestLogType_G_TEST_LOG_NONE: GTestLogType = 0;
pub const GTestLogType_G_TEST_LOG_ERROR: GTestLogType = 1;
pub const GTestLogType_G_TEST_LOG_START_BINARY: GTestLogType = 2;
pub const GTestLogType_G_TEST_LOG_LIST_CASE: GTestLogType = 3;
pub const GTestLogType_G_TEST_LOG_SKIP_CASE: GTestLogType = 4;
pub const GTestLogType_G_TEST_LOG_START_CASE: GTestLogType = 5;
pub const GTestLogType_G_TEST_LOG_STOP_CASE: GTestLogType = 6;
pub const GTestLogType_G_TEST_LOG_MIN_RESULT: GTestLogType = 7;
pub const GTestLogType_G_TEST_LOG_MAX_RESULT: GTestLogType = 8;
pub const GTestLogType_G_TEST_LOG_MESSAGE: GTestLogType = 9;
pub const GTestLogType_G_TEST_LOG_START_SUITE: GTestLogType = 10;
pub const GTestLogType_G_TEST_LOG_STOP_SUITE: GTestLogType = 11;
pub type GTestLogType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GTestLogMsg {
    pub log_type: GTestLogType,
    pub n_strings: guint,
    pub strings: *mut *mut gchar,
    pub n_nums: guint,
    pub nums: *mut u128,
}
#[test]
fn bindgen_test_layout_GTestLogMsg() {
    assert_eq!(
        ::std::mem::size_of::<GTestLogMsg>(),
        32usize,
        concat!("Size of: ", stringify!(GTestLogMsg))
    );
    assert_eq!(
        ::std::mem::align_of::<GTestLogMsg>(),
        8usize,
        concat!("Alignment of ", stringify!(GTestLogMsg))
    );
    fn test_field_log_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<GTestLogMsg>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).log_type) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(GTestLogMsg),
                "::",
                stringify!(log_type)
            )
        );
    }
    test_field_log_type();
    fn test_field_n_strings() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<GTestLogMsg>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).n_strings) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(GTestLogMsg),
                "::",
                stringify!(n_strings)
            )
        );
    }
    test_field_n_strings();
    fn test_field_strings() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<GTestLogMsg>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).strings) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(GTestLogMsg),
                "::",
                stringify!(strings)
            )
        );
    }
    test_field_strings();
    fn test_field_n_nums() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<GTestLogMsg>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).n_nums) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(GTestLogMsg),
                "::",
                stringify!(n_nums)
            )
        );
    }
    test_field_n_nums();
    fn test_field_nums() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<GTestLogMsg>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nums) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(GTestLogMsg),
                "::",
                stringify!(nums)
            )
        );
    }
    test_field_nums();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GTestLogBuffer {
    pub data: *mut GString,
    pub msgs: *mut GSList,
}
#[test]
fn bindgen_test_layout_GTestLogBuffer() {
    assert_eq!(
        ::std::mem::size_of::<GTestLogBuffer>(),
        16usize,
        concat!("Size of: ", stringify!(GTestLogBuffer))
    );
    assert_eq!(
        ::std::mem::align_of::<GTestLogBuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(GTestLogBuffer))
    );
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<GTestLogBuffer>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(GTestLogBuffer),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_msgs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<GTestLogBuffer>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).msgs) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(GTestLogBuffer),
                "::",
                stringify!(msgs)
            )
        );
    }
    test_field_msgs();
}
extern "C" {
    pub fn g_test_log_type_name(log_type: GTestLogType) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_test_log_buffer_new() -> *mut GTestLogBuffer;
}
extern "C" {
    pub fn g_test_log_buffer_free(tbuffer: *mut GTestLogBuffer);
}
extern "C" {
    pub fn g_test_log_buffer_push(
        tbuffer: *mut GTestLogBuffer,
        n_bytes: guint,
        bytes: *const guint8,
    );
}
extern "C" {
    pub fn g_test_log_buffer_pop(tbuffer: *mut GTestLogBuffer) -> *mut GTestLogMsg;
}
extern "C" {
    pub fn g_test_log_msg_free(tmsg: *mut GTestLogMsg);
}
#[doc = " GTestLogFatalFunc:"]
#[doc = " @log_domain: the log domain of the message"]
#[doc = " @log_level: the log level of the message (including the fatal and recursion flags)"]
#[doc = " @message: the message to process"]
#[doc = " @user_data: user data, set in g_test_log_set_fatal_handler()"]
#[doc = ""]
#[doc = " Specifies the prototype of fatal log handler functions."]
#[doc = ""]
#[doc = " Returns: %TRUE if the program should abort, %FALSE otherwise"]
#[doc = ""]
#[doc = " Since: 2.22"]
pub type GTestLogFatalFunc = ::std::option::Option<
    unsafe extern "C" fn(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        message: *const gchar,
        user_data: gpointer,
    ) -> gboolean,
>;
extern "C" {
    pub fn g_test_log_set_fatal_handler(log_func: GTestLogFatalFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_test_expect_message(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        pattern: *const gchar,
    );
}
extern "C" {
    pub fn g_test_assert_expected_messages_internal(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
    );
}
pub const GTestFileType_G_TEST_DIST: GTestFileType = 0;
pub const GTestFileType_G_TEST_BUILT: GTestFileType = 1;
pub type GTestFileType = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_test_build_filename(
        file_type: GTestFileType,
        first_path: *const gchar,
        ...
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_test_get_dir(file_type: GTestFileType) -> *const gchar;
}
extern "C" {
    pub fn g_test_get_filename(
        file_type: GTestFileType,
        first_path: *const gchar,
        ...
    ) -> *const gchar;
}
pub type GThreadPool = _GThreadPool;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GThreadPool {
    pub func: GFunc,
    pub user_data: gpointer,
    pub exclusive: gboolean,
}
#[test]
fn bindgen_test_layout__GThreadPool() {
    assert_eq!(
        ::std::mem::size_of::<_GThreadPool>(),
        24usize,
        concat!("Size of: ", stringify!(_GThreadPool))
    );
    assert_eq!(
        ::std::mem::align_of::<_GThreadPool>(),
        8usize,
        concat!("Alignment of ", stringify!(_GThreadPool))
    );
    fn test_field_func() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GThreadPool>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GThreadPool),
                "::",
                stringify!(func)
            )
        );
    }
    test_field_func();
    fn test_field_user_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GThreadPool>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).user_data) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_GThreadPool),
                "::",
                stringify!(user_data)
            )
        );
    }
    test_field_user_data();
    fn test_field_exclusive() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GThreadPool>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).exclusive) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_GThreadPool),
                "::",
                stringify!(exclusive)
            )
        );
    }
    test_field_exclusive();
}
extern "C" {
    pub fn g_thread_pool_new(
        func: GFunc,
        user_data: gpointer,
        max_threads: gint,
        exclusive: gboolean,
        error: *mut *mut GError,
    ) -> *mut GThreadPool;
}
extern "C" {
    pub fn g_thread_pool_free(pool: *mut GThreadPool, immediate: gboolean, wait_: gboolean);
}
extern "C" {
    pub fn g_thread_pool_push(
        pool: *mut GThreadPool,
        data: gpointer,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_thread_pool_unprocessed(pool: *mut GThreadPool) -> guint;
}
extern "C" {
    pub fn g_thread_pool_set_sort_function(
        pool: *mut GThreadPool,
        func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_thread_pool_move_to_front(pool: *mut GThreadPool, data: gpointer) -> gboolean;
}
extern "C" {
    pub fn g_thread_pool_set_max_threads(
        pool: *mut GThreadPool,
        max_threads: gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_thread_pool_get_max_threads(pool: *mut GThreadPool) -> gint;
}
extern "C" {
    pub fn g_thread_pool_get_num_threads(pool: *mut GThreadPool) -> guint;
}
extern "C" {
    pub fn g_thread_pool_set_max_unused_threads(max_threads: gint);
}
extern "C" {
    pub fn g_thread_pool_get_max_unused_threads() -> gint;
}
extern "C" {
    pub fn g_thread_pool_get_num_unused_threads() -> guint;
}
extern "C" {
    pub fn g_thread_pool_stop_unused_threads();
}
extern "C" {
    pub fn g_thread_pool_set_max_idle_time(interval: guint);
}
extern "C" {
    pub fn g_thread_pool_get_max_idle_time() -> guint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTimer {
    _unused: [u8; 0],
}
pub type GTimer = _GTimer;
extern "C" {
    pub fn g_timer_new() -> *mut GTimer;
}
extern "C" {
    pub fn g_timer_destroy(timer: *mut GTimer);
}
extern "C" {
    pub fn g_timer_start(timer: *mut GTimer);
}
extern "C" {
    pub fn g_timer_stop(timer: *mut GTimer);
}
extern "C" {
    pub fn g_timer_reset(timer: *mut GTimer);
}
extern "C" {
    pub fn g_timer_continue(timer: *mut GTimer);
}
extern "C" {
    pub fn g_timer_elapsed(timer: *mut GTimer, microseconds: *mut gulong) -> gdouble;
}
extern "C" {
    pub fn g_timer_is_active(timer: *mut GTimer) -> gboolean;
}
extern "C" {
    pub fn g_usleep(microseconds: gulong);
}
extern "C" {
    pub fn g_time_val_add(time_: *mut GTimeVal, microseconds: glong);
}
extern "C" {
    pub fn g_time_val_from_iso8601(iso_date: *const gchar, time_: *mut GTimeVal) -> gboolean;
}
extern "C" {
    pub fn g_time_val_to_iso8601(time_: *mut GTimeVal) -> *mut gchar;
}
pub type GTrashStack = _GTrashStack;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTrashStack {
    pub next: *mut GTrashStack,
}
#[test]
fn bindgen_test_layout__GTrashStack() {
    assert_eq!(
        ::std::mem::size_of::<_GTrashStack>(),
        8usize,
        concat!("Size of: ", stringify!(_GTrashStack))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTrashStack>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTrashStack))
    );
    fn test_field_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GTrashStack>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GTrashStack),
                "::",
                stringify!(next)
            )
        );
    }
    test_field_next();
}
extern "C" {
    pub fn g_trash_stack_push(stack_p: *mut *mut GTrashStack, data_p: gpointer);
}
extern "C" {
    pub fn g_trash_stack_pop(stack_p: *mut *mut GTrashStack) -> gpointer;
}
extern "C" {
    pub fn g_trash_stack_peek(stack_p: *mut *mut GTrashStack) -> gpointer;
}
extern "C" {
    pub fn g_trash_stack_height(stack_p: *mut *mut GTrashStack) -> guint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTree {
    _unused: [u8; 0],
}
pub type GTree = _GTree;
pub type GTraverseFunc = ::std::option::Option<
    unsafe extern "C" fn(key: gpointer, value: gpointer, data: gpointer) -> gboolean,
>;
extern "C" {
    pub fn g_tree_new(key_compare_func: GCompareFunc) -> *mut GTree;
}
extern "C" {
    pub fn g_tree_new_with_data(
        key_compare_func: GCompareDataFunc,
        key_compare_data: gpointer,
    ) -> *mut GTree;
}
extern "C" {
    pub fn g_tree_new_full(
        key_compare_func: GCompareDataFunc,
        key_compare_data: gpointer,
        key_destroy_func: GDestroyNotify,
        value_destroy_func: GDestroyNotify,
    ) -> *mut GTree;
}
extern "C" {
    pub fn g_tree_ref(tree: *mut GTree) -> *mut GTree;
}
extern "C" {
    pub fn g_tree_unref(tree: *mut GTree);
}
extern "C" {
    pub fn g_tree_destroy(tree: *mut GTree);
}
extern "C" {
    pub fn g_tree_insert(tree: *mut GTree, key: gpointer, value: gpointer);
}
extern "C" {
    pub fn g_tree_replace(tree: *mut GTree, key: gpointer, value: gpointer);
}
extern "C" {
    pub fn g_tree_remove(tree: *mut GTree, key: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_tree_steal(tree: *mut GTree, key: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_tree_lookup(tree: *mut GTree, key: gconstpointer) -> gpointer;
}
extern "C" {
    pub fn g_tree_lookup_extended(
        tree: *mut GTree,
        lookup_key: gconstpointer,
        orig_key: *mut gpointer,
        value: *mut gpointer,
    ) -> gboolean;
}
extern "C" {
    pub fn g_tree_foreach(tree: *mut GTree, func: GTraverseFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_tree_traverse(
        tree: *mut GTree,
        traverse_func: GTraverseFunc,
        traverse_type: GTraverseType,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_tree_search(
        tree: *mut GTree,
        search_func: GCompareFunc,
        user_data: gconstpointer,
    ) -> gpointer;
}
extern "C" {
    pub fn g_tree_height(tree: *mut GTree) -> gint;
}
extern "C" {
    pub fn g_tree_nnodes(tree: *mut GTree) -> gint;
}
extern "C" {
    pub fn g_uri_unescape_string(
        escaped_string: *const ::std::os::raw::c_char,
        illegal_characters: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_uri_unescape_segment(
        escaped_string: *const ::std::os::raw::c_char,
        escaped_string_end: *const ::std::os::raw::c_char,
        illegal_characters: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_uri_parse_scheme(uri: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_uri_escape_string(
        unescaped: *const ::std::os::raw::c_char,
        reserved_chars_allowed: *const ::std::os::raw::c_char,
        allow_utf8: gboolean,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_uuid_string_is_valid(str_: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_uuid_string_random() -> *mut gchar;
}
extern "C" {
    pub static glib_major_version: guint;
}
extern "C" {
    pub static glib_minor_version: guint;
}
extern "C" {
    pub static glib_micro_version: guint;
}
extern "C" {
    pub static glib_interface_age: guint;
}
extern "C" {
    pub static glib_binary_age: guint;
}
extern "C" {
    pub fn glib_check_version(
        required_major: guint,
        required_minor: guint,
        required_micro: guint,
    ) -> *const gchar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GAllocator {
    _unused: [u8; 0],
}
pub type GAllocator = _GAllocator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMemChunk {
    _unused: [u8; 0],
}
pub type GMemChunk = _GMemChunk;
extern "C" {
    pub fn g_mem_chunk_new(
        name: *const gchar,
        atom_size: gint,
        area_size: gsize,
        type_: gint,
    ) -> *mut GMemChunk;
}
extern "C" {
    pub fn g_mem_chunk_destroy(mem_chunk: *mut GMemChunk);
}
extern "C" {
    pub fn g_mem_chunk_alloc(mem_chunk: *mut GMemChunk) -> gpointer;
}
extern "C" {
    pub fn g_mem_chunk_alloc0(mem_chunk: *mut GMemChunk) -> gpointer;
}
extern "C" {
    pub fn g_mem_chunk_free(mem_chunk: *mut GMemChunk, mem: gpointer);
}
extern "C" {
    pub fn g_mem_chunk_clean(mem_chunk: *mut GMemChunk);
}
extern "C" {
    pub fn g_mem_chunk_reset(mem_chunk: *mut GMemChunk);
}
extern "C" {
    pub fn g_mem_chunk_print(mem_chunk: *mut GMemChunk);
}
extern "C" {
    pub fn g_mem_chunk_info();
}
extern "C" {
    pub fn g_blow_chunks();
}
extern "C" {
    pub fn g_allocator_new(name: *const gchar, n_preallocs: guint) -> *mut GAllocator;
}
extern "C" {
    pub fn g_allocator_free(allocator: *mut GAllocator);
}
extern "C" {
    pub fn g_list_push_allocator(allocator: *mut GAllocator);
}
extern "C" {
    pub fn g_list_pop_allocator();
}
extern "C" {
    pub fn g_slist_push_allocator(allocator: *mut GAllocator);
}
extern "C" {
    pub fn g_slist_pop_allocator();
}
extern "C" {
    pub fn g_node_push_allocator(allocator: *mut GAllocator);
}
extern "C" {
    pub fn g_node_pop_allocator();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCache {
    _unused: [u8; 0],
}
pub type GCache = _GCache;
pub type GCacheNewFunc = ::std::option::Option<unsafe extern "C" fn(key: gpointer) -> gpointer>;
pub type GCacheDupFunc = ::std::option::Option<unsafe extern "C" fn(value: gpointer) -> gpointer>;
pub type GCacheDestroyFunc = ::std::option::Option<unsafe extern "C" fn(value: gpointer)>;
extern "C" {
    pub fn g_cache_new(
        value_new_func: GCacheNewFunc,
        value_destroy_func: GCacheDestroyFunc,
        key_dup_func: GCacheDupFunc,
        key_destroy_func: GCacheDestroyFunc,
        hash_key_func: GHashFunc,
        hash_value_func: GHashFunc,
        key_equal_func: GEqualFunc,
    ) -> *mut GCache;
}
extern "C" {
    pub fn g_cache_destroy(cache: *mut GCache);
}
extern "C" {
    pub fn g_cache_insert(cache: *mut GCache, key: gpointer) -> gpointer;
}
extern "C" {
    pub fn g_cache_remove(cache: *mut GCache, value: gconstpointer);
}
extern "C" {
    pub fn g_cache_key_foreach(cache: *mut GCache, func: GHFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_cache_value_foreach(cache: *mut GCache, func: GHFunc, user_data: gpointer);
}
pub type GCompletion = _GCompletion;
pub type GCompletionFunc =
    ::std::option::Option<unsafe extern "C" fn(arg1: gpointer) -> *mut gchar>;
pub type GCompletionStrncmpFunc = ::std::option::Option<
    unsafe extern "C" fn(s1: *const gchar, s2: *const gchar, n: gsize) -> gint,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCompletion {
    pub items: *mut GList,
    pub func: GCompletionFunc,
    pub prefix: *mut gchar,
    pub cache: *mut GList,
    pub strncmp_func: GCompletionStrncmpFunc,
}
#[test]
fn bindgen_test_layout__GCompletion() {
    assert_eq!(
        ::std::mem::size_of::<_GCompletion>(),
        40usize,
        concat!("Size of: ", stringify!(_GCompletion))
    );
    assert_eq!(
        ::std::mem::align_of::<_GCompletion>(),
        8usize,
        concat!("Alignment of ", stringify!(_GCompletion))
    );
    fn test_field_items() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GCompletion>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).items) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GCompletion),
                "::",
                stringify!(items)
            )
        );
    }
    test_field_items();
    fn test_field_func() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GCompletion>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_GCompletion),
                "::",
                stringify!(func)
            )
        );
    }
    test_field_func();
    fn test_field_prefix() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GCompletion>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).prefix) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_GCompletion),
                "::",
                stringify!(prefix)
            )
        );
    }
    test_field_prefix();
    fn test_field_cache() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GCompletion>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cache) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_GCompletion),
                "::",
                stringify!(cache)
            )
        );
    }
    test_field_cache();
    fn test_field_strncmp_func() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GCompletion>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).strncmp_func) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_GCompletion),
                "::",
                stringify!(strncmp_func)
            )
        );
    }
    test_field_strncmp_func();
}
extern "C" {
    pub fn g_completion_new(func: GCompletionFunc) -> *mut GCompletion;
}
extern "C" {
    pub fn g_completion_add_items(cmp: *mut GCompletion, items: *mut GList);
}
extern "C" {
    pub fn g_completion_remove_items(cmp: *mut GCompletion, items: *mut GList);
}
extern "C" {
    pub fn g_completion_clear_items(cmp: *mut GCompletion);
}
extern "C" {
    pub fn g_completion_complete(
        cmp: *mut GCompletion,
        prefix: *const gchar,
        new_prefix: *mut *mut gchar,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_completion_complete_utf8(
        cmp: *mut GCompletion,
        prefix: *const gchar,
        new_prefix: *mut *mut gchar,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_completion_set_compare(cmp: *mut GCompletion, strncmp_func: GCompletionStrncmpFunc);
}
extern "C" {
    pub fn g_completion_free(cmp: *mut GCompletion);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRelation {
    _unused: [u8; 0],
}
pub type GRelation = _GRelation;
pub type GTuples = _GTuples;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTuples {
    pub len: guint,
}
#[test]
fn bindgen_test_layout__GTuples() {
    assert_eq!(
        ::std::mem::size_of::<_GTuples>(),
        4usize,
        concat!("Size of: ", stringify!(_GTuples))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTuples>(),
        4usize,
        concat!("Alignment of ", stringify!(_GTuples))
    );
    fn test_field_len() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GTuples>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GTuples),
                "::",
                stringify!(len)
            )
        );
    }
    test_field_len();
}
extern "C" {
    pub fn g_relation_new(fields: gint) -> *mut GRelation;
}
extern "C" {
    pub fn g_relation_destroy(relation: *mut GRelation);
}
extern "C" {
    pub fn g_relation_index(
        relation: *mut GRelation,
        field: gint,
        hash_func: GHashFunc,
        key_equal_func: GEqualFunc,
    );
}
extern "C" {
    pub fn g_relation_insert(relation: *mut GRelation, ...);
}
extern "C" {
    pub fn g_relation_delete(relation: *mut GRelation, key: gconstpointer, field: gint) -> gint;
}
extern "C" {
    pub fn g_relation_select(
        relation: *mut GRelation,
        key: gconstpointer,
        field: gint,
    ) -> *mut GTuples;
}
extern "C" {
    pub fn g_relation_count(relation: *mut GRelation, key: gconstpointer, field: gint) -> gint;
}
extern "C" {
    pub fn g_relation_exists(relation: *mut GRelation, ...) -> gboolean;
}
extern "C" {
    pub fn g_relation_print(relation: *mut GRelation);
}
extern "C" {
    pub fn g_tuples_destroy(tuples: *mut GTuples);
}
extern "C" {
    pub fn g_tuples_index(tuples: *mut GTuples, index_: gint, field: gint) -> gpointer;
}
pub const GThreadPriority_G_THREAD_PRIORITY_LOW: GThreadPriority = 0;
pub const GThreadPriority_G_THREAD_PRIORITY_NORMAL: GThreadPriority = 1;
pub const GThreadPriority_G_THREAD_PRIORITY_HIGH: GThreadPriority = 2;
pub const GThreadPriority_G_THREAD_PRIORITY_URGENT: GThreadPriority = 3;
pub type GThreadPriority = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GThread {
    pub func: GThreadFunc,
    pub data: gpointer,
    pub joinable: gboolean,
    pub priority: GThreadPriority,
}
#[test]
fn bindgen_test_layout__GThread() {
    assert_eq!(
        ::std::mem::size_of::<_GThread>(),
        24usize,
        concat!("Size of: ", stringify!(_GThread))
    );
    assert_eq!(
        ::std::mem::align_of::<_GThread>(),
        8usize,
        concat!("Alignment of ", stringify!(_GThread))
    );
    fn test_field_func() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GThread>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GThread),
                "::",
                stringify!(func)
            )
        );
    }
    test_field_func();
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GThread>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_GThread),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_joinable() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GThread>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).joinable) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_GThread),
                "::",
                stringify!(joinable)
            )
        );
    }
    test_field_joinable();
    fn test_field_priority() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GThread>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).priority) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(_GThread),
                "::",
                stringify!(priority)
            )
        );
    }
    test_field_priority();
}
pub type GThreadFunctions = _GThreadFunctions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GThreadFunctions {
    pub mutex_new: ::std::option::Option<unsafe extern "C" fn() -> *mut GMutex>,
    pub mutex_lock: ::std::option::Option<unsafe extern "C" fn(mutex: *mut GMutex)>,
    pub mutex_trylock: ::std::option::Option<unsafe extern "C" fn(mutex: *mut GMutex) -> gboolean>,
    pub mutex_unlock: ::std::option::Option<unsafe extern "C" fn(mutex: *mut GMutex)>,
    pub mutex_free: ::std::option::Option<unsafe extern "C" fn(mutex: *mut GMutex)>,
    pub cond_new: ::std::option::Option<unsafe extern "C" fn() -> *mut GCond>,
    pub cond_signal: ::std::option::Option<unsafe extern "C" fn(cond: *mut GCond)>,
    pub cond_broadcast: ::std::option::Option<unsafe extern "C" fn(cond: *mut GCond)>,
    pub cond_wait:
        ::std::option::Option<unsafe extern "C" fn(cond: *mut GCond, mutex: *mut GMutex)>,
    pub cond_timed_wait: ::std::option::Option<
        unsafe extern "C" fn(
            cond: *mut GCond,
            mutex: *mut GMutex,
            end_time: *mut GTimeVal,
        ) -> gboolean,
    >,
    pub cond_free: ::std::option::Option<unsafe extern "C" fn(cond: *mut GCond)>,
    pub private_new:
        ::std::option::Option<unsafe extern "C" fn(destructor: GDestroyNotify) -> *mut GPrivate>,
    pub private_get:
        ::std::option::Option<unsafe extern "C" fn(private_key: *mut GPrivate) -> gpointer>,
    pub private_set:
        ::std::option::Option<unsafe extern "C" fn(private_key: *mut GPrivate, data: gpointer)>,
    pub thread_create: ::std::option::Option<
        unsafe extern "C" fn(
            func: GThreadFunc,
            data: gpointer,
            stack_size: gulong,
            joinable: gboolean,
            bound: gboolean,
            priority: GThreadPriority,
            thread: gpointer,
            error: *mut *mut GError,
        ),
    >,
    pub thread_yield: ::std::option::Option<unsafe extern "C" fn()>,
    pub thread_join: ::std::option::Option<unsafe extern "C" fn(thread: gpointer)>,
    pub thread_exit: ::std::option::Option<unsafe extern "C" fn()>,
    pub thread_set_priority:
        ::std::option::Option<unsafe extern "C" fn(thread: gpointer, priority: GThreadPriority)>,
    pub thread_self: ::std::option::Option<unsafe extern "C" fn(thread: gpointer)>,
    pub thread_equal: ::std::option::Option<
        unsafe extern "C" fn(thread1: gpointer, thread2: gpointer) -> gboolean,
    >,
}
#[test]
fn bindgen_test_layout__GThreadFunctions() {
    assert_eq!(
        ::std::mem::size_of::<_GThreadFunctions>(),
        168usize,
        concat!("Size of: ", stringify!(_GThreadFunctions))
    );
    assert_eq!(
        ::std::mem::align_of::<_GThreadFunctions>(),
        8usize,
        concat!("Alignment of ", stringify!(_GThreadFunctions))
    );
    fn test_field_mutex_new() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GThreadFunctions>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mutex_new) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GThreadFunctions),
                "::",
                stringify!(mutex_new)
            )
        );
    }
    test_field_mutex_new();
    fn test_field_mutex_lock() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GThreadFunctions>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mutex_lock) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_GThreadFunctions),
                "::",
                stringify!(mutex_lock)
            )
        );
    }
    test_field_mutex_lock();
    fn test_field_mutex_trylock() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GThreadFunctions>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mutex_trylock) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_GThreadFunctions),
                "::",
                stringify!(mutex_trylock)
            )
        );
    }
    test_field_mutex_trylock();
    fn test_field_mutex_unlock() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GThreadFunctions>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mutex_unlock) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_GThreadFunctions),
                "::",
                stringify!(mutex_unlock)
            )
        );
    }
    test_field_mutex_unlock();
    fn test_field_mutex_free() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GThreadFunctions>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mutex_free) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_GThreadFunctions),
                "::",
                stringify!(mutex_free)
            )
        );
    }
    test_field_mutex_free();
    fn test_field_cond_new() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GThreadFunctions>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cond_new) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_GThreadFunctions),
                "::",
                stringify!(cond_new)
            )
        );
    }
    test_field_cond_new();
    fn test_field_cond_signal() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GThreadFunctions>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cond_signal) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_GThreadFunctions),
                "::",
                stringify!(cond_signal)
            )
        );
    }
    test_field_cond_signal();
    fn test_field_cond_broadcast() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GThreadFunctions>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cond_broadcast) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_GThreadFunctions),
                "::",
                stringify!(cond_broadcast)
            )
        );
    }
    test_field_cond_broadcast();
    fn test_field_cond_wait() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GThreadFunctions>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cond_wait) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_GThreadFunctions),
                "::",
                stringify!(cond_wait)
            )
        );
    }
    test_field_cond_wait();
    fn test_field_cond_timed_wait() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GThreadFunctions>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cond_timed_wait) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_GThreadFunctions),
                "::",
                stringify!(cond_timed_wait)
            )
        );
    }
    test_field_cond_timed_wait();
    fn test_field_cond_free() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GThreadFunctions>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cond_free) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_GThreadFunctions),
                "::",
                stringify!(cond_free)
            )
        );
    }
    test_field_cond_free();
    fn test_field_private_new() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GThreadFunctions>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).private_new) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_GThreadFunctions),
                "::",
                stringify!(private_new)
            )
        );
    }
    test_field_private_new();
    fn test_field_private_get() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GThreadFunctions>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).private_get) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_GThreadFunctions),
                "::",
                stringify!(private_get)
            )
        );
    }
    test_field_private_get();
    fn test_field_private_set() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GThreadFunctions>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).private_set) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_GThreadFunctions),
                "::",
                stringify!(private_set)
            )
        );
    }
    test_field_private_set();
    fn test_field_thread_create() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GThreadFunctions>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).thread_create) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(_GThreadFunctions),
                "::",
                stringify!(thread_create)
            )
        );
    }
    test_field_thread_create();
    fn test_field_thread_yield() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GThreadFunctions>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).thread_yield) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(_GThreadFunctions),
                "::",
                stringify!(thread_yield)
            )
        );
    }
    test_field_thread_yield();
    fn test_field_thread_join() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GThreadFunctions>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).thread_join) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(_GThreadFunctions),
                "::",
                stringify!(thread_join)
            )
        );
    }
    test_field_thread_join();
    fn test_field_thread_exit() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GThreadFunctions>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).thread_exit) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(_GThreadFunctions),
                "::",
                stringify!(thread_exit)
            )
        );
    }
    test_field_thread_exit();
    fn test_field_thread_set_priority() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GThreadFunctions>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).thread_set_priority) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(_GThreadFunctions),
                "::",
                stringify!(thread_set_priority)
            )
        );
    }
    test_field_thread_set_priority();
    fn test_field_thread_self() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GThreadFunctions>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).thread_self) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(_GThreadFunctions),
                "::",
                stringify!(thread_self)
            )
        );
    }
    test_field_thread_self();
    fn test_field_thread_equal() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GThreadFunctions>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).thread_equal) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(_GThreadFunctions),
                "::",
                stringify!(thread_equal)
            )
        );
    }
    test_field_thread_equal();
}
extern "C" {
    pub static mut g_thread_functions_for_glib_use: GThreadFunctions;
}
extern "C" {
    pub static mut g_thread_use_default_impl: gboolean;
}
extern "C" {
    pub static mut g_thread_gettime: ::std::option::Option<unsafe extern "C" fn() -> guint64>;
}
extern "C" {
    pub fn g_thread_create(
        func: GThreadFunc,
        data: gpointer,
        joinable: gboolean,
        error: *mut *mut GError,
    ) -> *mut GThread;
}
extern "C" {
    pub fn g_thread_create_full(
        func: GThreadFunc,
        data: gpointer,
        stack_size: gulong,
        joinable: gboolean,
        bound: gboolean,
        priority: GThreadPriority,
        error: *mut *mut GError,
    ) -> *mut GThread;
}
extern "C" {
    pub fn g_thread_set_priority(thread: *mut GThread, priority: GThreadPriority);
}
extern "C" {
    pub fn g_thread_foreach(thread_func: GFunc, user_data: gpointer);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sched_param() {
    assert_eq!(
        ::std::mem::size_of::<sched_param>(),
        4usize,
        concat!("Size of: ", stringify!(sched_param))
    );
    assert_eq!(
        ::std::mem::align_of::<sched_param>(),
        4usize,
        concat!("Alignment of ", stringify!(sched_param))
    );
    fn test_field_sched_priority() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sched_param>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sched_priority) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_param),
                "::",
                stringify!(sched_priority)
            )
        );
    }
    test_field_sched_priority();
}
pub type __cpu_mask = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu_set_t {
    pub __bits: [__cpu_mask; 16usize],
}
#[test]
fn bindgen_test_layout_cpu_set_t() {
    assert_eq!(
        ::std::mem::size_of::<cpu_set_t>(),
        128usize,
        concat!("Size of: ", stringify!(cpu_set_t))
    );
    assert_eq!(
        ::std::mem::align_of::<cpu_set_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cpu_set_t))
    );
    fn test_field___bits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cpu_set_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__bits) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cpu_set_t),
                "::",
                stringify!(__bits)
            )
        );
    }
    test_field___bits();
}
extern "C" {
    pub fn __sched_cpucount(__setsize: size_t, __setp: *const cpu_set_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __sched_cpualloc(__count: size_t) -> *mut cpu_set_t;
}
extern "C" {
    pub fn __sched_cpufree(__set: *mut cpu_set_t);
}
extern "C" {
    pub fn sched_setparam(__pid: __pid_t, __param: *const sched_param) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getparam(__pid: __pid_t, __param: *mut sched_param) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_setscheduler(
        __pid: __pid_t,
        __policy: ::std::os::raw::c_int,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getscheduler(__pid: __pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_yield() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_max(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_min(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_rr_get_interval(__pid: __pid_t, __t: *mut timespec) -> ::std::os::raw::c_int;
}
pub type __jmp_buf = [::std::os::raw::c_ulonglong; 22usize];
pub const PTHREAD_CREATE_JOINABLE: _bindgen_ty_11 = 0;
pub const PTHREAD_CREATE_DETACHED: _bindgen_ty_11 = 1;
pub type _bindgen_ty_11 = ::std::os::raw::c_uint;
pub const PTHREAD_MUTEX_TIMED_NP: _bindgen_ty_12 = 0;
pub const PTHREAD_MUTEX_RECURSIVE_NP: _bindgen_ty_12 = 1;
pub const PTHREAD_MUTEX_ERRORCHECK_NP: _bindgen_ty_12 = 2;
pub const PTHREAD_MUTEX_ADAPTIVE_NP: _bindgen_ty_12 = 3;
pub const PTHREAD_MUTEX_NORMAL: _bindgen_ty_12 = 0;
pub const PTHREAD_MUTEX_RECURSIVE: _bindgen_ty_12 = 1;
pub const PTHREAD_MUTEX_ERRORCHECK: _bindgen_ty_12 = 2;
pub const PTHREAD_MUTEX_DEFAULT: _bindgen_ty_12 = 0;
pub type _bindgen_ty_12 = ::std::os::raw::c_uint;
pub const PTHREAD_MUTEX_STALLED: _bindgen_ty_13 = 0;
pub const PTHREAD_MUTEX_STALLED_NP: _bindgen_ty_13 = 0;
pub const PTHREAD_MUTEX_ROBUST: _bindgen_ty_13 = 1;
pub const PTHREAD_MUTEX_ROBUST_NP: _bindgen_ty_13 = 1;
pub type _bindgen_ty_13 = ::std::os::raw::c_uint;
pub const PTHREAD_PRIO_NONE: _bindgen_ty_14 = 0;
pub const PTHREAD_PRIO_INHERIT: _bindgen_ty_14 = 1;
pub const PTHREAD_PRIO_PROTECT: _bindgen_ty_14 = 2;
pub type _bindgen_ty_14 = ::std::os::raw::c_uint;
pub const PTHREAD_RWLOCK_PREFER_READER_NP: _bindgen_ty_15 = 0;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NP: _bindgen_ty_15 = 1;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP: _bindgen_ty_15 = 2;
pub const PTHREAD_RWLOCK_DEFAULT_NP: _bindgen_ty_15 = 0;
pub type _bindgen_ty_15 = ::std::os::raw::c_uint;
pub const PTHREAD_INHERIT_SCHED: _bindgen_ty_16 = 0;
pub const PTHREAD_EXPLICIT_SCHED: _bindgen_ty_16 = 1;
pub type _bindgen_ty_16 = ::std::os::raw::c_uint;
pub const PTHREAD_SCOPE_SYSTEM: _bindgen_ty_17 = 0;
pub const PTHREAD_SCOPE_PROCESS: _bindgen_ty_17 = 1;
pub type _bindgen_ty_17 = ::std::os::raw::c_uint;
pub const PTHREAD_PROCESS_PRIVATE: _bindgen_ty_18 = 0;
pub const PTHREAD_PROCESS_SHARED: _bindgen_ty_18 = 1;
pub type _bindgen_ty_18 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pthread_cleanup_buffer {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __canceltype: ::std::os::raw::c_int,
    pub __prev: *mut _pthread_cleanup_buffer,
}
#[test]
fn bindgen_test_layout__pthread_cleanup_buffer() {
    assert_eq!(
        ::std::mem::size_of::<_pthread_cleanup_buffer>(),
        32usize,
        concat!("Size of: ", stringify!(_pthread_cleanup_buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<_pthread_cleanup_buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(_pthread_cleanup_buffer))
    );
    fn test_field___routine() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_pthread_cleanup_buffer>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__routine) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_pthread_cleanup_buffer),
                "::",
                stringify!(__routine)
            )
        );
    }
    test_field___routine();
    fn test_field___arg() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_pthread_cleanup_buffer>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__arg) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_pthread_cleanup_buffer),
                "::",
                stringify!(__arg)
            )
        );
    }
    test_field___arg();
    fn test_field___canceltype() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_pthread_cleanup_buffer>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__canceltype) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_pthread_cleanup_buffer),
                "::",
                stringify!(__canceltype)
            )
        );
    }
    test_field___canceltype();
    fn test_field___prev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_pthread_cleanup_buffer>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__prev) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_pthread_cleanup_buffer),
                "::",
                stringify!(__prev)
            )
        );
    }
    test_field___prev();
}
pub const PTHREAD_CANCEL_ENABLE: _bindgen_ty_19 = 0;
pub const PTHREAD_CANCEL_DISABLE: _bindgen_ty_19 = 1;
pub type _bindgen_ty_19 = ::std::os::raw::c_uint;
pub const PTHREAD_CANCEL_DEFERRED: _bindgen_ty_20 = 0;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: _bindgen_ty_20 = 1;
pub type _bindgen_ty_20 = ::std::os::raw::c_uint;
extern "C" {
    pub fn pthread_create(
        __newthread: *mut pthread_t,
        __attr: *const pthread_attr_t,
        __start_routine: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_exit(__retval: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn pthread_join(
        __th: pthread_t,
        __thread_return: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_detach(__th: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_self() -> pthread_t;
}
extern "C" {
    pub fn pthread_equal(__thread1: pthread_t, __thread2: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_init(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_destroy(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getdetachstate(
        __attr: *const pthread_attr_t,
        __detachstate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setdetachstate(
        __attr: *mut pthread_attr_t,
        __detachstate: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getguardsize(
        __attr: *const pthread_attr_t,
        __guardsize: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setguardsize(
        __attr: *mut pthread_attr_t,
        __guardsize: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedparam(
        __attr: *const pthread_attr_t,
        __param: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedparam(
        __attr: *mut pthread_attr_t,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedpolicy(
        __attr: *const pthread_attr_t,
        __policy: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedpolicy(
        __attr: *mut pthread_attr_t,
        __policy: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getinheritsched(
        __attr: *const pthread_attr_t,
        __inherit: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setinheritsched(
        __attr: *mut pthread_attr_t,
        __inherit: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getscope(
        __attr: *const pthread_attr_t,
        __scope: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setscope(
        __attr: *mut pthread_attr_t,
        __scope: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstackaddr(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstackaddr(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstacksize(
        __attr: *const pthread_attr_t,
        __stacksize: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstacksize(
        __attr: *mut pthread_attr_t,
        __stacksize: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstack(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::std::os::raw::c_void,
        __stacksize: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstack(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::std::os::raw::c_void,
        __stacksize: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setschedparam(
        __target_thread: pthread_t,
        __policy: ::std::os::raw::c_int,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getschedparam(
        __target_thread: pthread_t,
        __policy: *mut ::std::os::raw::c_int,
        __param: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setschedprio(
        __target_thread: pthread_t,
        __prio: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_once(
        __once_control: *mut pthread_once_t,
        __init_routine: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setcancelstate(
        __state: ::std::os::raw::c_int,
        __oldstate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setcanceltype(
        __type: ::std::os::raw::c_int,
        __oldtype: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cancel(__th: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_testcancel();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_unwind_buf_t {
    pub __cancel_jmp_buf: [__pthread_unwind_buf_t__bindgen_ty_1; 1usize],
    pub __pad: [*mut ::std::os::raw::c_void; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_unwind_buf_t__bindgen_ty_1 {
    pub __cancel_jmp_buf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___pthread_unwind_buf_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_unwind_buf_t__bindgen_ty_1>(),
        184usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_unwind_buf_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_unwind_buf_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_unwind_buf_t__bindgen_ty_1)
        )
    );
    fn test_field___cancel_jmp_buf() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<__pthread_unwind_buf_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__cancel_jmp_buf) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_unwind_buf_t__bindgen_ty_1),
                "::",
                stringify!(__cancel_jmp_buf)
            )
        );
    }
    test_field___cancel_jmp_buf();
    fn test_field___mask_was_saved() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<__pthread_unwind_buf_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__mask_was_saved) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_unwind_buf_t__bindgen_ty_1),
                "::",
                stringify!(__mask_was_saved)
            )
        );
    }
    test_field___mask_was_saved();
}
#[test]
fn bindgen_test_layout___pthread_unwind_buf_t() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_unwind_buf_t>(),
        216usize,
        concat!("Size of: ", stringify!(__pthread_unwind_buf_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_unwind_buf_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_unwind_buf_t))
    );
    fn test_field___cancel_jmp_buf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_unwind_buf_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__cancel_jmp_buf) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_unwind_buf_t),
                "::",
                stringify!(__cancel_jmp_buf)
            )
        );
    }
    test_field___cancel_jmp_buf();
    fn test_field___pad() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_unwind_buf_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pad) as usize - ptr as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_unwind_buf_t),
                "::",
                stringify!(__pad)
            )
        );
    }
    test_field___pad();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cleanup_frame {
    pub __cancel_routine:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __cancel_arg: *mut ::std::os::raw::c_void,
    pub __do_it: ::std::os::raw::c_int,
    pub __cancel_type: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___pthread_cleanup_frame() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cleanup_frame>(),
        24usize,
        concat!("Size of: ", stringify!(__pthread_cleanup_frame))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cleanup_frame>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cleanup_frame))
    );
    fn test_field___cancel_routine() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_cleanup_frame>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__cancel_routine) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cleanup_frame),
                "::",
                stringify!(__cancel_routine)
            )
        );
    }
    test_field___cancel_routine();
    fn test_field___cancel_arg() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_cleanup_frame>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__cancel_arg) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cleanup_frame),
                "::",
                stringify!(__cancel_arg)
            )
        );
    }
    test_field___cancel_arg();
    fn test_field___do_it() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_cleanup_frame>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__do_it) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cleanup_frame),
                "::",
                stringify!(__do_it)
            )
        );
    }
    test_field___do_it();
    fn test_field___cancel_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_cleanup_frame>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__cancel_type) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cleanup_frame),
                "::",
                stringify!(__cancel_type)
            )
        );
    }
    test_field___cancel_type();
}
extern "C" {
    pub fn __pthread_register_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unregister_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unwind_next(__buf: *mut __pthread_unwind_buf_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __jmp_buf_tag {
    _unused: [u8; 0],
}
extern "C" {
    pub fn __sigsetjmp(
        __env: *mut __jmp_buf_tag,
        __savemask: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_init(
        __mutex: *mut pthread_mutex_t,
        __mutexattr: *const pthread_mutexattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_destroy(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_trylock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_lock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_timedlock(
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_unlock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_getprioceiling(
        __mutex: *const pthread_mutex_t,
        __prioceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_setprioceiling(
        __mutex: *mut pthread_mutex_t,
        __prioceiling: ::std::os::raw::c_int,
        __old_ceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_consistent(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_init(__attr: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_destroy(__attr: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getpshared(
        __attr: *const pthread_mutexattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setpshared(
        __attr: *mut pthread_mutexattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_gettype(
        __attr: *const pthread_mutexattr_t,
        __kind: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_settype(
        __attr: *mut pthread_mutexattr_t,
        __kind: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprotocol(
        __attr: *const pthread_mutexattr_t,
        __protocol: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprotocol(
        __attr: *mut pthread_mutexattr_t,
        __protocol: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprioceiling(
        __attr: *const pthread_mutexattr_t,
        __prioceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprioceiling(
        __attr: *mut pthread_mutexattr_t,
        __prioceiling: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getrobust(
        __attr: *const pthread_mutexattr_t,
        __robustness: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setrobust(
        __attr: *mut pthread_mutexattr_t,
        __robustness: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_init(
        __rwlock: *mut pthread_rwlock_t,
        __attr: *const pthread_rwlockattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_destroy(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_rdlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_tryrdlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedrdlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_wrlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_trywrlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedwrlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_unlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_init(__attr: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_destroy(__attr: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getpshared(
        __attr: *const pthread_rwlockattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setpshared(
        __attr: *mut pthread_rwlockattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getkind_np(
        __attr: *const pthread_rwlockattr_t,
        __pref: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setkind_np(
        __attr: *mut pthread_rwlockattr_t,
        __pref: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_init(
        __cond: *mut pthread_cond_t,
        __cond_attr: *const pthread_condattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_destroy(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_signal(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_broadcast(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_wait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_timedwait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_init(__attr: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_destroy(__attr: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_getpshared(
        __attr: *const pthread_condattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_setpshared(
        __attr: *mut pthread_condattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_getclock(
        __attr: *const pthread_condattr_t,
        __clock_id: *mut __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_setclock(
        __attr: *mut pthread_condattr_t,
        __clock_id: __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_init(
        __lock: *mut pthread_spinlock_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_destroy(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_lock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_trylock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_unlock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_init(
        __barrier: *mut pthread_barrier_t,
        __attr: *const pthread_barrierattr_t,
        __count: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_destroy(__barrier: *mut pthread_barrier_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_wait(__barrier: *mut pthread_barrier_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_init(__attr: *mut pthread_barrierattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_destroy(__attr: *mut pthread_barrierattr_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_getpshared(
        __attr: *const pthread_barrierattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_setpshared(
        __attr: *mut pthread_barrierattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_create(
        __key: *mut pthread_key_t,
        __destr_function: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_delete(__key: pthread_key_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getspecific(__key: pthread_key_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pthread_setspecific(
        __key: pthread_key_t,
        __pointer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getcpuclockid(
        __thread_id: pthread_t,
        __clock_id: *mut __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_atfork(
        __prepare: ::std::option::Option<unsafe extern "C" fn()>,
        __parent: ::std::option::Option<unsafe extern "C" fn()>,
        __child: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GStaticMutex {
    pub mutex: *mut GMutex,
    pub unused: pthread_mutex_t,
}
#[test]
fn bindgen_test_layout_GStaticMutex() {
    assert_eq!(
        ::std::mem::size_of::<GStaticMutex>(),
        56usize,
        concat!("Size of: ", stringify!(GStaticMutex))
    );
    assert_eq!(
        ::std::mem::align_of::<GStaticMutex>(),
        8usize,
        concat!("Alignment of ", stringify!(GStaticMutex))
    );
    fn test_field_mutex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<GStaticMutex>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mutex) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(GStaticMutex),
                "::",
                stringify!(mutex)
            )
        );
    }
    test_field_mutex();
    fn test_field_unused() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<GStaticMutex>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(GStaticMutex),
                "::",
                stringify!(unused)
            )
        );
    }
    test_field_unused();
}
extern "C" {
    pub fn g_static_mutex_init(mutex: *mut GStaticMutex);
}
extern "C" {
    pub fn g_static_mutex_free(mutex: *mut GStaticMutex);
}
extern "C" {
    pub fn g_static_mutex_get_mutex_impl(mutex: *mut GStaticMutex) -> *mut GMutex;
}
pub type GStaticRecMutex = _GStaticRecMutex;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GStaticRecMutex {
    pub mutex: GStaticMutex,
    pub depth: guint,
    pub unused: _GStaticRecMutex__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GStaticRecMutex__bindgen_ty_1 {
    pub owner: pthread_t,
    pub dummy: gdouble,
}
#[test]
fn bindgen_test_layout__GStaticRecMutex__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_GStaticRecMutex__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_GStaticRecMutex__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_GStaticRecMutex__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_GStaticRecMutex__bindgen_ty_1))
    );
    fn test_field_owner() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GStaticRecMutex__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).owner) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GStaticRecMutex__bindgen_ty_1),
                "::",
                stringify!(owner)
            )
        );
    }
    test_field_owner();
    fn test_field_dummy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GStaticRecMutex__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GStaticRecMutex__bindgen_ty_1),
                "::",
                stringify!(dummy)
            )
        );
    }
    test_field_dummy();
}
#[test]
fn bindgen_test_layout__GStaticRecMutex() {
    assert_eq!(
        ::std::mem::size_of::<_GStaticRecMutex>(),
        72usize,
        concat!("Size of: ", stringify!(_GStaticRecMutex))
    );
    assert_eq!(
        ::std::mem::align_of::<_GStaticRecMutex>(),
        8usize,
        concat!("Alignment of ", stringify!(_GStaticRecMutex))
    );
    fn test_field_mutex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GStaticRecMutex>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mutex) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GStaticRecMutex),
                "::",
                stringify!(mutex)
            )
        );
    }
    test_field_mutex();
    fn test_field_depth() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GStaticRecMutex>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).depth) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_GStaticRecMutex),
                "::",
                stringify!(depth)
            )
        );
    }
    test_field_depth();
    fn test_field_unused() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GStaticRecMutex>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_GStaticRecMutex),
                "::",
                stringify!(unused)
            )
        );
    }
    test_field_unused();
}
extern "C" {
    pub fn g_static_rec_mutex_init(mutex: *mut GStaticRecMutex);
}
extern "C" {
    pub fn g_static_rec_mutex_lock(mutex: *mut GStaticRecMutex);
}
extern "C" {
    pub fn g_static_rec_mutex_trylock(mutex: *mut GStaticRecMutex) -> gboolean;
}
extern "C" {
    pub fn g_static_rec_mutex_unlock(mutex: *mut GStaticRecMutex);
}
extern "C" {
    pub fn g_static_rec_mutex_lock_full(mutex: *mut GStaticRecMutex, depth: guint);
}
extern "C" {
    pub fn g_static_rec_mutex_unlock_full(mutex: *mut GStaticRecMutex) -> guint;
}
extern "C" {
    pub fn g_static_rec_mutex_free(mutex: *mut GStaticRecMutex);
}
pub type GStaticRWLock = _GStaticRWLock;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GStaticRWLock {
    pub mutex: GStaticMutex,
    pub read_cond: *mut GCond,
    pub write_cond: *mut GCond,
    pub read_counter: guint,
    pub have_writer: gboolean,
    pub want_to_read: guint,
    pub want_to_write: guint,
}
#[test]
fn bindgen_test_layout__GStaticRWLock() {
    assert_eq!(
        ::std::mem::size_of::<_GStaticRWLock>(),
        88usize,
        concat!("Size of: ", stringify!(_GStaticRWLock))
    );
    assert_eq!(
        ::std::mem::align_of::<_GStaticRWLock>(),
        8usize,
        concat!("Alignment of ", stringify!(_GStaticRWLock))
    );
    fn test_field_mutex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GStaticRWLock>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mutex) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GStaticRWLock),
                "::",
                stringify!(mutex)
            )
        );
    }
    test_field_mutex();
    fn test_field_read_cond() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GStaticRWLock>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).read_cond) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_GStaticRWLock),
                "::",
                stringify!(read_cond)
            )
        );
    }
    test_field_read_cond();
    fn test_field_write_cond() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GStaticRWLock>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).write_cond) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_GStaticRWLock),
                "::",
                stringify!(write_cond)
            )
        );
    }
    test_field_write_cond();
    fn test_field_read_counter() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GStaticRWLock>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).read_counter) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_GStaticRWLock),
                "::",
                stringify!(read_counter)
            )
        );
    }
    test_field_read_counter();
    fn test_field_have_writer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GStaticRWLock>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).have_writer) as usize - ptr as usize
            },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(_GStaticRWLock),
                "::",
                stringify!(have_writer)
            )
        );
    }
    test_field_have_writer();
    fn test_field_want_to_read() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GStaticRWLock>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).want_to_read) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_GStaticRWLock),
                "::",
                stringify!(want_to_read)
            )
        );
    }
    test_field_want_to_read();
    fn test_field_want_to_write() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GStaticRWLock>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).want_to_write) as usize - ptr as usize
            },
            84usize,
            concat!(
                "Offset of field: ",
                stringify!(_GStaticRWLock),
                "::",
                stringify!(want_to_write)
            )
        );
    }
    test_field_want_to_write();
}
extern "C" {
    pub fn g_static_rw_lock_init(lock: *mut GStaticRWLock);
}
extern "C" {
    pub fn g_static_rw_lock_reader_lock(lock: *mut GStaticRWLock);
}
extern "C" {
    pub fn g_static_rw_lock_reader_trylock(lock: *mut GStaticRWLock) -> gboolean;
}
extern "C" {
    pub fn g_static_rw_lock_reader_unlock(lock: *mut GStaticRWLock);
}
extern "C" {
    pub fn g_static_rw_lock_writer_lock(lock: *mut GStaticRWLock);
}
extern "C" {
    pub fn g_static_rw_lock_writer_trylock(lock: *mut GStaticRWLock) -> gboolean;
}
extern "C" {
    pub fn g_static_rw_lock_writer_unlock(lock: *mut GStaticRWLock);
}
extern "C" {
    pub fn g_static_rw_lock_free(lock: *mut GStaticRWLock);
}
extern "C" {
    pub fn g_private_new(notify: GDestroyNotify) -> *mut GPrivate;
}
pub type GStaticPrivate = _GStaticPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GStaticPrivate {
    pub index: guint,
}
#[test]
fn bindgen_test_layout__GStaticPrivate() {
    assert_eq!(
        ::std::mem::size_of::<_GStaticPrivate>(),
        4usize,
        concat!("Size of: ", stringify!(_GStaticPrivate))
    );
    assert_eq!(
        ::std::mem::align_of::<_GStaticPrivate>(),
        4usize,
        concat!("Alignment of ", stringify!(_GStaticPrivate))
    );
    fn test_field_index() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GStaticPrivate>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_GStaticPrivate),
                "::",
                stringify!(index)
            )
        );
    }
    test_field_index();
}
extern "C" {
    pub fn g_static_private_init(private_key: *mut GStaticPrivate);
}
extern "C" {
    pub fn g_static_private_get(private_key: *mut GStaticPrivate) -> gpointer;
}
extern "C" {
    pub fn g_static_private_set(
        private_key: *mut GStaticPrivate,
        data: gpointer,
        notify: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_static_private_free(private_key: *mut GStaticPrivate);
}
extern "C" {
    pub fn g_once_init_enter_impl(location: *mut gsize) -> gboolean;
}
extern "C" {
    pub fn g_thread_init(vtable: gpointer);
}
extern "C" {
    pub fn g_thread_init_with_errorcheck_mutexes(vtable: gpointer);
}
extern "C" {
    pub fn g_thread_get_initialized() -> gboolean;
}
extern "C" {
    pub static mut g_threads_got_initialized: gboolean;
}
extern "C" {
    pub fn g_mutex_new() -> *mut GMutex;
}
extern "C" {
    pub fn g_mutex_free(mutex: *mut GMutex);
}
extern "C" {
    pub fn g_cond_new() -> *mut GCond;
}
extern "C" {
    pub fn g_cond_free(cond: *mut GCond);
}
extern "C" {
    pub fn g_cond_timed_wait(
        cond: *mut GCond,
        mutex: *mut GMutex,
        timeval: *mut GTimeVal,
    ) -> gboolean;
}
pub type GAsyncQueue_autoptr = *mut GAsyncQueue;
pub type GAsyncQueue_listautoptr = *mut GList;
pub type GAsyncQueue_slistautoptr = *mut GSList;
pub type GAsyncQueue_queueautoptr = *mut GQueue;
pub type GBookmarkFile_autoptr = *mut GBookmarkFile;
pub type GBookmarkFile_listautoptr = *mut GList;
pub type GBookmarkFile_slistautoptr = *mut GSList;
pub type GBookmarkFile_queueautoptr = *mut GQueue;
pub type GBytes_autoptr = *mut GBytes;
pub type GBytes_listautoptr = *mut GList;
pub type GBytes_slistautoptr = *mut GSList;
pub type GBytes_queueautoptr = *mut GQueue;
pub type GChecksum_autoptr = *mut GChecksum;
pub type GChecksum_listautoptr = *mut GList;
pub type GChecksum_slistautoptr = *mut GSList;
pub type GChecksum_queueautoptr = *mut GQueue;
pub type GDateTime_autoptr = *mut GDateTime;
pub type GDateTime_listautoptr = *mut GList;
pub type GDateTime_slistautoptr = *mut GSList;
pub type GDateTime_queueautoptr = *mut GQueue;
pub type GDate_autoptr = *mut GDate;
pub type GDate_listautoptr = *mut GList;
pub type GDate_slistautoptr = *mut GSList;
pub type GDate_queueautoptr = *mut GQueue;
pub type GDir_autoptr = *mut GDir;
pub type GDir_listautoptr = *mut GList;
pub type GDir_slistautoptr = *mut GSList;
pub type GDir_queueautoptr = *mut GQueue;
pub type GError_autoptr = *mut GError;
pub type GError_listautoptr = *mut GList;
pub type GError_slistautoptr = *mut GSList;
pub type GError_queueautoptr = *mut GQueue;
pub type GHashTable_autoptr = *mut GHashTable;
pub type GHashTable_listautoptr = *mut GList;
pub type GHashTable_slistautoptr = *mut GSList;
pub type GHashTable_queueautoptr = *mut GQueue;
pub type GHmac_autoptr = *mut GHmac;
pub type GHmac_listautoptr = *mut GList;
pub type GHmac_slistautoptr = *mut GSList;
pub type GHmac_queueautoptr = *mut GQueue;
pub type GIOChannel_autoptr = *mut GIOChannel;
pub type GIOChannel_listautoptr = *mut GList;
pub type GIOChannel_slistautoptr = *mut GSList;
pub type GIOChannel_queueautoptr = *mut GQueue;
pub type GKeyFile_autoptr = *mut GKeyFile;
pub type GKeyFile_listautoptr = *mut GList;
pub type GKeyFile_slistautoptr = *mut GSList;
pub type GKeyFile_queueautoptr = *mut GQueue;
pub type GList_autoptr = *mut GList;
pub type GList_listautoptr = *mut GList;
pub type GList_slistautoptr = *mut GSList;
pub type GList_queueautoptr = *mut GQueue;
pub type GArray_autoptr = *mut GArray;
pub type GArray_listautoptr = *mut GList;
pub type GArray_slistautoptr = *mut GSList;
pub type GArray_queueautoptr = *mut GQueue;
pub type GPtrArray_autoptr = *mut GPtrArray;
pub type GPtrArray_listautoptr = *mut GList;
pub type GPtrArray_slistautoptr = *mut GSList;
pub type GPtrArray_queueautoptr = *mut GQueue;
pub type GByteArray_autoptr = *mut GByteArray;
pub type GByteArray_listautoptr = *mut GList;
pub type GByteArray_slistautoptr = *mut GSList;
pub type GByteArray_queueautoptr = *mut GQueue;
pub type GMainContext_autoptr = *mut GMainContext;
pub type GMainContext_listautoptr = *mut GList;
pub type GMainContext_slistautoptr = *mut GSList;
pub type GMainContext_queueautoptr = *mut GQueue;
pub type GMainContextPusher_autoptr = *mut GMainContextPusher;
pub type GMainContextPusher_listautoptr = *mut GList;
pub type GMainContextPusher_slistautoptr = *mut GSList;
pub type GMainContextPusher_queueautoptr = *mut GQueue;
pub type GMainLoop_autoptr = *mut GMainLoop;
pub type GMainLoop_listautoptr = *mut GList;
pub type GMainLoop_slistautoptr = *mut GSList;
pub type GMainLoop_queueautoptr = *mut GQueue;
pub type GSource_autoptr = *mut GSource;
pub type GSource_listautoptr = *mut GList;
pub type GSource_slistautoptr = *mut GSList;
pub type GSource_queueautoptr = *mut GQueue;
pub type GMappedFile_autoptr = *mut GMappedFile;
pub type GMappedFile_listautoptr = *mut GList;
pub type GMappedFile_slistautoptr = *mut GSList;
pub type GMappedFile_queueautoptr = *mut GQueue;
pub type GMarkupParseContext_autoptr = *mut GMarkupParseContext;
pub type GMarkupParseContext_listautoptr = *mut GList;
pub type GMarkupParseContext_slistautoptr = *mut GSList;
pub type GMarkupParseContext_queueautoptr = *mut GQueue;
pub type GNode_autoptr = *mut GNode;
pub type GNode_listautoptr = *mut GList;
pub type GNode_slistautoptr = *mut GSList;
pub type GNode_queueautoptr = *mut GQueue;
pub type GOptionContext_autoptr = *mut GOptionContext;
pub type GOptionContext_listautoptr = *mut GList;
pub type GOptionContext_slistautoptr = *mut GSList;
pub type GOptionContext_queueautoptr = *mut GQueue;
pub type GOptionGroup_autoptr = *mut GOptionGroup;
pub type GOptionGroup_listautoptr = *mut GList;
pub type GOptionGroup_slistautoptr = *mut GSList;
pub type GOptionGroup_queueautoptr = *mut GQueue;
pub type GPatternSpec_autoptr = *mut GPatternSpec;
pub type GPatternSpec_listautoptr = *mut GList;
pub type GPatternSpec_slistautoptr = *mut GSList;
pub type GPatternSpec_queueautoptr = *mut GQueue;
pub type GQueue_autoptr = *mut GQueue;
pub type GQueue_listautoptr = *mut GList;
pub type GQueue_slistautoptr = *mut GSList;
pub type GQueue_queueautoptr = *mut GQueue;
pub type GRand_autoptr = *mut GRand;
pub type GRand_listautoptr = *mut GList;
pub type GRand_slistautoptr = *mut GSList;
pub type GRand_queueautoptr = *mut GQueue;
pub type GRegex_autoptr = *mut GRegex;
pub type GRegex_listautoptr = *mut GList;
pub type GRegex_slistautoptr = *mut GSList;
pub type GRegex_queueautoptr = *mut GQueue;
pub type GMatchInfo_autoptr = *mut GMatchInfo;
pub type GMatchInfo_listautoptr = *mut GList;
pub type GMatchInfo_slistautoptr = *mut GSList;
pub type GMatchInfo_queueautoptr = *mut GQueue;
pub type GScanner_autoptr = *mut GScanner;
pub type GScanner_listautoptr = *mut GList;
pub type GScanner_slistautoptr = *mut GSList;
pub type GScanner_queueautoptr = *mut GQueue;
pub type GSequence_autoptr = *mut GSequence;
pub type GSequence_listautoptr = *mut GList;
pub type GSequence_slistautoptr = *mut GSList;
pub type GSequence_queueautoptr = *mut GQueue;
pub type GSList_autoptr = *mut GSList;
pub type GSList_listautoptr = *mut GList;
pub type GSList_slistautoptr = *mut GSList;
pub type GSList_queueautoptr = *mut GQueue;
pub type GString_autoptr = *mut GString;
pub type GString_listautoptr = *mut GList;
pub type GString_slistautoptr = *mut GSList;
pub type GString_queueautoptr = *mut GQueue;
pub type GStringChunk_autoptr = *mut GStringChunk;
pub type GStringChunk_listautoptr = *mut GList;
pub type GStringChunk_slistautoptr = *mut GSList;
pub type GStringChunk_queueautoptr = *mut GQueue;
pub type GThread_autoptr = *mut GThread;
pub type GThread_listautoptr = *mut GList;
pub type GThread_slistautoptr = *mut GSList;
pub type GThread_queueautoptr = *mut GQueue;
pub type GMutexLocker_autoptr = *mut GMutexLocker;
pub type GMutexLocker_listautoptr = *mut GList;
pub type GMutexLocker_slistautoptr = *mut GSList;
pub type GMutexLocker_queueautoptr = *mut GQueue;
pub type GRecMutexLocker_autoptr = *mut GRecMutexLocker;
pub type GRecMutexLocker_listautoptr = *mut GList;
pub type GRecMutexLocker_slistautoptr = *mut GSList;
pub type GRecMutexLocker_queueautoptr = *mut GQueue;
pub type GRWLockWriterLocker_autoptr = *mut GRWLockWriterLocker;
pub type GRWLockWriterLocker_listautoptr = *mut GList;
pub type GRWLockWriterLocker_slistautoptr = *mut GSList;
pub type GRWLockWriterLocker_queueautoptr = *mut GQueue;
pub type GRWLockReaderLocker_autoptr = *mut GRWLockReaderLocker;
pub type GRWLockReaderLocker_listautoptr = *mut GList;
pub type GRWLockReaderLocker_slistautoptr = *mut GSList;
pub type GRWLockReaderLocker_queueautoptr = *mut GQueue;
pub type GTimer_autoptr = *mut GTimer;
pub type GTimer_listautoptr = *mut GList;
pub type GTimer_slistautoptr = *mut GSList;
pub type GTimer_queueautoptr = *mut GQueue;
pub type GTimeZone_autoptr = *mut GTimeZone;
pub type GTimeZone_listautoptr = *mut GList;
pub type GTimeZone_slistautoptr = *mut GSList;
pub type GTimeZone_queueautoptr = *mut GQueue;
pub type GTree_autoptr = *mut GTree;
pub type GTree_listautoptr = *mut GList;
pub type GTree_slistautoptr = *mut GSList;
pub type GTree_queueautoptr = *mut GQueue;
pub type GVariant_autoptr = *mut GVariant;
pub type GVariant_listautoptr = *mut GList;
pub type GVariant_slistautoptr = *mut GSList;
pub type GVariant_queueautoptr = *mut GQueue;
pub type GVariantBuilder_autoptr = *mut GVariantBuilder;
pub type GVariantBuilder_listautoptr = *mut GList;
pub type GVariantBuilder_slistautoptr = *mut GSList;
pub type GVariantBuilder_queueautoptr = *mut GQueue;
pub type GVariantIter_autoptr = *mut GVariantIter;
pub type GVariantIter_listautoptr = *mut GList;
pub type GVariantIter_slistautoptr = *mut GSList;
pub type GVariantIter_queueautoptr = *mut GQueue;
pub type GVariantDict_autoptr = *mut GVariantDict;
pub type GVariantDict_listautoptr = *mut GList;
pub type GVariantDict_slistautoptr = *mut GSList;
pub type GVariantDict_queueautoptr = *mut GQueue;
pub type GVariantType_autoptr = *mut GVariantType;
pub type GVariantType_listautoptr = *mut GList;
pub type GVariantType_slistautoptr = *mut GSList;
pub type GVariantType_queueautoptr = *mut GQueue;
pub type GRefString_autoptr = *mut GRefString;
pub type GRefString_listautoptr = *mut GList;
pub type GRefString_slistautoptr = *mut GSList;
pub type GRefString_queueautoptr = *mut GQueue;
pub const GModuleFlags_G_MODULE_BIND_LAZY: GModuleFlags = 1;
pub const GModuleFlags_G_MODULE_BIND_LOCAL: GModuleFlags = 2;
pub const GModuleFlags_G_MODULE_BIND_MASK: GModuleFlags = 3;
#[doc = " GModuleFlags:"]
#[doc = " @G_MODULE_BIND_LAZY: specifies that symbols are only resolved when"]
#[doc = "     needed. The default action is to bind all symbols when the module"]
#[doc = "     is loaded."]
#[doc = " @G_MODULE_BIND_LOCAL: specifies that symbols in the module should"]
#[doc = "     not be added to the global name space. The default action on most"]
#[doc = "     platforms is to place symbols in the module in the global name space,"]
#[doc = "     which may cause conflicts with existing symbols."]
#[doc = " @G_MODULE_BIND_MASK: mask for all flags."]
#[doc = ""]
#[doc = " Flags passed to g_module_open()."]
#[doc = " Note that these flags are not supported on all platforms."]
pub type GModuleFlags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GModule {
    _unused: [u8; 0],
}
pub type GModule = _GModule;
pub type GModuleCheckInit =
    ::std::option::Option<unsafe extern "C" fn(module: *mut GModule) -> *const gchar>;
pub type GModuleUnload = ::std::option::Option<unsafe extern "C" fn(module: *mut GModule)>;
extern "C" {
    pub fn g_module_supported() -> gboolean;
}
extern "C" {
    pub fn g_module_open(file_name: *const gchar, flags: GModuleFlags) -> *mut GModule;
}
extern "C" {
    pub fn g_module_close(module: *mut GModule) -> gboolean;
}
extern "C" {
    pub fn g_module_make_resident(module: *mut GModule);
}
extern "C" {
    pub fn g_module_error() -> *const gchar;
}
extern "C" {
    pub fn g_module_symbol(
        module: *mut GModule,
        symbol_name: *const gchar,
        symbol: *mut gpointer,
    ) -> gboolean;
}
extern "C" {
    pub fn g_module_name(module: *mut GModule) -> *const gchar;
}
extern "C" {
    pub fn g_module_build_path(directory: *const gchar, module_name: *const gchar) -> *mut gchar;
}
#[doc = "< Specifies using the CPU for OSD processing."]
#[doc = "Works with RGBA data only"]
pub const NvOSD_Mode_MODE_CPU: NvOSD_Mode = 0;
#[doc = "< Specifies using the GPU for OSD processing."]
#[doc = "Currently not implemented."]
pub const NvOSD_Mode_MODE_GPU: NvOSD_Mode = 1;
#[doc = "< Specifies the NVIDIA hardware engine"]
#[doc = "for rectangle drawing and masking."]
#[doc = "This mode works with both YUV and RGB data."]
#[doc = "It does not consider alpha parameter."]
#[doc = "Not applicable to drawing text."]
pub const NvOSD_Mode_MODE_HW: NvOSD_Mode = 2;
#[doc = " Defines modes used to overlay boxes and text."]
pub type NvOSD_Mode = ::std::os::raw::c_uint;
#[doc = " Specifies an arrow head only at start = 0."]
pub const NvOSD_Arrow_Head_Direction_START_HEAD: NvOSD_Arrow_Head_Direction = 0;
#[doc = " Specifies an arrow head only at end = 1."]
pub const NvOSD_Arrow_Head_Direction_END_HEAD: NvOSD_Arrow_Head_Direction = 1;
#[doc = " Specifies arrow heads at both start and end = 2."]
pub const NvOSD_Arrow_Head_Direction_BOTH_HEAD: NvOSD_Arrow_Head_Direction = 2;
#[doc = " Specifies arrow head positions."]
pub type NvOSD_Arrow_Head_Direction = ::std::os::raw::c_uint;
#[doc = " Holds unclipped bounding box coordinates of the object."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvBbox_Coords {
    #[doc = "< Holds the box's left coordinate"]
    #[doc = "in pixels."]
    pub left: f32,
    #[doc = "< Holds the box's top coordinate"]
    #[doc = "in pixels."]
    pub top: f32,
    #[doc = "< Holds the box's width in pixels."]
    pub width: f32,
    #[doc = "< Holds the box's height in pixels."]
    pub height: f32,
}
#[test]
fn bindgen_test_layout__NvBbox_Coords() {
    assert_eq!(
        ::std::mem::size_of::<_NvBbox_Coords>(),
        16usize,
        concat!("Size of: ", stringify!(_NvBbox_Coords))
    );
    assert_eq!(
        ::std::mem::align_of::<_NvBbox_Coords>(),
        4usize,
        concat!("Alignment of ", stringify!(_NvBbox_Coords))
    );
    fn test_field_left() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvBbox_Coords>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).left) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvBbox_Coords),
                "::",
                stringify!(left)
            )
        );
    }
    test_field_left();
    fn test_field_top() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvBbox_Coords>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).top) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvBbox_Coords),
                "::",
                stringify!(top)
            )
        );
    }
    test_field_top();
    fn test_field_width() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvBbox_Coords>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvBbox_Coords),
                "::",
                stringify!(width)
            )
        );
    }
    test_field_width();
    fn test_field_height() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvBbox_Coords>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvBbox_Coords),
                "::",
                stringify!(height)
            )
        );
    }
    test_field_height();
}
#[doc = " Holds unclipped bounding box coordinates of the object."]
pub type NvBbox_Coords = _NvBbox_Coords;
#[doc = " Holds the color parameters of the box or text to be overlayed."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvOSD_ColorParams {
    #[doc = "< Holds the red component of color."]
    #[doc = "Value must be in the range 0.0-1.0."]
    pub red: f64,
    #[doc = "< Holds the green component of color."]
    #[doc = "Value must be in the range 0.0-1.0."]
    pub green: f64,
    #[doc = "< Holds the blue component of color."]
    #[doc = "Value must be in the range 0.0-1.0."]
    pub blue: f64,
    #[doc = "< Holds the alpha component of color."]
    #[doc = "Value must be in the range 0.0-1.0."]
    pub alpha: f64,
}
#[test]
fn bindgen_test_layout__NvOSD_ColorParams() {
    assert_eq!(
        ::std::mem::size_of::<_NvOSD_ColorParams>(),
        32usize,
        concat!("Size of: ", stringify!(_NvOSD_ColorParams))
    );
    assert_eq!(
        ::std::mem::align_of::<_NvOSD_ColorParams>(),
        8usize,
        concat!("Alignment of ", stringify!(_NvOSD_ColorParams))
    );
    fn test_field_red() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvOSD_ColorParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).red) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvOSD_ColorParams),
                "::",
                stringify!(red)
            )
        );
    }
    test_field_red();
    fn test_field_green() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvOSD_ColorParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).green) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvOSD_ColorParams),
                "::",
                stringify!(green)
            )
        );
    }
    test_field_green();
    fn test_field_blue() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvOSD_ColorParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).blue) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvOSD_ColorParams),
                "::",
                stringify!(blue)
            )
        );
    }
    test_field_blue();
    fn test_field_alpha() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvOSD_ColorParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).alpha) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvOSD_ColorParams),
                "::",
                stringify!(alpha)
            )
        );
    }
    test_field_alpha();
}
#[doc = " Holds the color parameters of the box or text to be overlayed."]
pub type NvOSD_ColorParams = _NvOSD_ColorParams;
#[doc = " Holds the font parameters of the text to be overlayed."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvOSD_FontParams {
    #[doc = "< Holds a pointer to the string containing"]
    #[doc = "the font name. To display a list of"]
    #[doc = "supported fonts, run the fc-list command."]
    pub font_name: *mut ::std::os::raw::c_char,
    #[doc = "< Holds the size of the font."]
    pub font_size: ::std::os::raw::c_uint,
    #[doc = "< Holds the font color."]
    pub font_color: NvOSD_ColorParams,
}
#[test]
fn bindgen_test_layout__NvOSD_FontParams() {
    assert_eq!(
        ::std::mem::size_of::<_NvOSD_FontParams>(),
        48usize,
        concat!("Size of: ", stringify!(_NvOSD_FontParams))
    );
    assert_eq!(
        ::std::mem::align_of::<_NvOSD_FontParams>(),
        8usize,
        concat!("Alignment of ", stringify!(_NvOSD_FontParams))
    );
    fn test_field_font_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvOSD_FontParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).font_name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvOSD_FontParams),
                "::",
                stringify!(font_name)
            )
        );
    }
    test_field_font_name();
    fn test_field_font_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvOSD_FontParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).font_size) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvOSD_FontParams),
                "::",
                stringify!(font_size)
            )
        );
    }
    test_field_font_size();
    fn test_field_font_color() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvOSD_FontParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).font_color) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvOSD_FontParams),
                "::",
                stringify!(font_color)
            )
        );
    }
    test_field_font_color();
}
#[doc = " Holds the font parameters of the text to be overlayed."]
pub type NvOSD_FontParams = _NvOSD_FontParams;
#[doc = " Holds parameters of text to be overlayed."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvOSD_TextParams {
    #[doc = "< Holds the text to be overlayed."]
    pub display_text: *mut ::std::os::raw::c_char,
    #[doc = "< Holds the text's horizontal offset from"]
    #[doc = "the top left pixel of the frame."]
    pub x_offset: ::std::os::raw::c_uint,
    #[doc = "< Holds the text's vertical offset from the"]
    #[doc = "top left pixel of the frame."]
    pub y_offset: ::std::os::raw::c_uint,
    #[doc = "< Holds the font parameters of the text"]
    #[doc = "to be overlaid."]
    pub font_params: NvOSD_FontParams,
    #[doc = "< Holds a Boolean; true if the text has a"]
    #[doc = "background color."]
    pub set_bg_clr: ::std::os::raw::c_int,
    #[doc = "< Holds the text's background color, if"]
    #[doc = "specified."]
    pub text_bg_clr: NvOSD_ColorParams,
}
#[test]
fn bindgen_test_layout__NvOSD_TextParams() {
    assert_eq!(
        ::std::mem::size_of::<_NvOSD_TextParams>(),
        104usize,
        concat!("Size of: ", stringify!(_NvOSD_TextParams))
    );
    assert_eq!(
        ::std::mem::align_of::<_NvOSD_TextParams>(),
        8usize,
        concat!("Alignment of ", stringify!(_NvOSD_TextParams))
    );
    fn test_field_display_text() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvOSD_TextParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).display_text) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvOSD_TextParams),
                "::",
                stringify!(display_text)
            )
        );
    }
    test_field_display_text();
    fn test_field_x_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvOSD_TextParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x_offset) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvOSD_TextParams),
                "::",
                stringify!(x_offset)
            )
        );
    }
    test_field_x_offset();
    fn test_field_y_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvOSD_TextParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y_offset) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvOSD_TextParams),
                "::",
                stringify!(y_offset)
            )
        );
    }
    test_field_y_offset();
    fn test_field_font_params() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvOSD_TextParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).font_params) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvOSD_TextParams),
                "::",
                stringify!(font_params)
            )
        );
    }
    test_field_font_params();
    fn test_field_set_bg_clr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvOSD_TextParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_bg_clr) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvOSD_TextParams),
                "::",
                stringify!(set_bg_clr)
            )
        );
    }
    test_field_set_bg_clr();
    fn test_field_text_bg_clr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvOSD_TextParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).text_bg_clr) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvOSD_TextParams),
                "::",
                stringify!(text_bg_clr)
            )
        );
    }
    test_field_text_bg_clr();
}
#[doc = " Holds parameters of text to be overlayed."]
pub type NvOSD_TextParams = _NvOSD_TextParams;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvOSD_Color_info {
    pub id: ::std::os::raw::c_int,
    pub color: NvOSD_ColorParams,
}
#[test]
fn bindgen_test_layout__NvOSD_Color_info() {
    assert_eq!(
        ::std::mem::size_of::<_NvOSD_Color_info>(),
        40usize,
        concat!("Size of: ", stringify!(_NvOSD_Color_info))
    );
    assert_eq!(
        ::std::mem::align_of::<_NvOSD_Color_info>(),
        8usize,
        concat!("Alignment of ", stringify!(_NvOSD_Color_info))
    );
    fn test_field_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvOSD_Color_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvOSD_Color_info),
                "::",
                stringify!(id)
            )
        );
    }
    test_field_id();
    fn test_field_color() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvOSD_Color_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).color) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvOSD_Color_info),
                "::",
                stringify!(color)
            )
        );
    }
    test_field_color();
}
pub type NvOSD_Color_info = _NvOSD_Color_info;
#[doc = " Holds the box parameters of the box to be overlayed."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvOSD_RectParams {
    #[doc = "< Holds the box's left coordinate"]
    #[doc = "in pixels."]
    pub left: f32,
    #[doc = "< Holds the box's top coordinate"]
    #[doc = "in pixels."]
    pub top: f32,
    #[doc = "< Holds the box's width in pixels."]
    pub width: f32,
    #[doc = "< Holds the box's height in pixels."]
    pub height: f32,
    #[doc = "< Holds the box's border width in pixels."]
    pub border_width: ::std::os::raw::c_uint,
    pub border_color: NvOSD_ColorParams,
    #[doc = "< Holds a Boolean; true if the box has a"]
    #[doc = "background color."]
    pub has_bg_color: ::std::os::raw::c_uint,
    #[doc = "< Holds a field reserved for future use."]
    pub reserved: ::std::os::raw::c_uint,
    #[doc = "< Holds the box's background color."]
    pub bg_color: NvOSD_ColorParams,
    pub has_color_info: ::std::os::raw::c_int,
    pub color_id: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__NvOSD_RectParams() {
    assert_eq!(
        ::std::mem::size_of::<_NvOSD_RectParams>(),
        104usize,
        concat!("Size of: ", stringify!(_NvOSD_RectParams))
    );
    assert_eq!(
        ::std::mem::align_of::<_NvOSD_RectParams>(),
        8usize,
        concat!("Alignment of ", stringify!(_NvOSD_RectParams))
    );
    fn test_field_left() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvOSD_RectParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).left) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvOSD_RectParams),
                "::",
                stringify!(left)
            )
        );
    }
    test_field_left();
    fn test_field_top() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvOSD_RectParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).top) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvOSD_RectParams),
                "::",
                stringify!(top)
            )
        );
    }
    test_field_top();
    fn test_field_width() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvOSD_RectParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvOSD_RectParams),
                "::",
                stringify!(width)
            )
        );
    }
    test_field_width();
    fn test_field_height() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvOSD_RectParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvOSD_RectParams),
                "::",
                stringify!(height)
            )
        );
    }
    test_field_height();
    fn test_field_border_width() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvOSD_RectParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).border_width) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvOSD_RectParams),
                "::",
                stringify!(border_width)
            )
        );
    }
    test_field_border_width();
    fn test_field_border_color() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvOSD_RectParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).border_color) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvOSD_RectParams),
                "::",
                stringify!(border_color)
            )
        );
    }
    test_field_border_color();
    fn test_field_has_bg_color() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvOSD_RectParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).has_bg_color) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvOSD_RectParams),
                "::",
                stringify!(has_bg_color)
            )
        );
    }
    test_field_has_bg_color();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvOSD_RectParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvOSD_RectParams),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
    fn test_field_bg_color() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvOSD_RectParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bg_color) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvOSD_RectParams),
                "::",
                stringify!(bg_color)
            )
        );
    }
    test_field_bg_color();
    fn test_field_has_color_info() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvOSD_RectParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).has_color_info) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvOSD_RectParams),
                "::",
                stringify!(has_color_info)
            )
        );
    }
    test_field_has_color_info();
    fn test_field_color_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvOSD_RectParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).color_id) as usize - ptr as usize
            },
            100usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvOSD_RectParams),
                "::",
                stringify!(color_id)
            )
        );
    }
    test_field_color_id();
}
#[doc = " Holds the box parameters of the box to be overlayed."]
pub type NvOSD_RectParams = _NvOSD_RectParams;
#[doc = " Holds the mask parameters of the segment to be overlayed"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvOSD_MaskParams {
    pub data: *mut f32,
    #[doc = " Mask data"]
    pub size: ::std::os::raw::c_uint,
    #[doc = " Mask size"]
    pub threshold: f32,
    #[doc = " Threshold for binarization"]
    pub width: ::std::os::raw::c_uint,
    #[doc = " Mask width"]
    pub height: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout__NvOSD_MaskParams() {
    assert_eq!(
        ::std::mem::size_of::<_NvOSD_MaskParams>(),
        24usize,
        concat!("Size of: ", stringify!(_NvOSD_MaskParams))
    );
    assert_eq!(
        ::std::mem::align_of::<_NvOSD_MaskParams>(),
        8usize,
        concat!("Alignment of ", stringify!(_NvOSD_MaskParams))
    );
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvOSD_MaskParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvOSD_MaskParams),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvOSD_MaskParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvOSD_MaskParams),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_threshold() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvOSD_MaskParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).threshold) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvOSD_MaskParams),
                "::",
                stringify!(threshold)
            )
        );
    }
    test_field_threshold();
    fn test_field_width() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvOSD_MaskParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvOSD_MaskParams),
                "::",
                stringify!(width)
            )
        );
    }
    test_field_width();
    fn test_field_height() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvOSD_MaskParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvOSD_MaskParams),
                "::",
                stringify!(height)
            )
        );
    }
    test_field_height();
}
#[doc = " Holds the mask parameters of the segment to be overlayed"]
pub type NvOSD_MaskParams = _NvOSD_MaskParams;
#[doc = " Holds the box parameters of a line to be overlayed."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvOSD_LineParams {
    #[doc = "< Holds the box's left coordinate"]
    #[doc = "in pixels."]
    pub x1: ::std::os::raw::c_uint,
    #[doc = "< Holds the box's top coordinate"]
    #[doc = "in pixels."]
    pub y1: ::std::os::raw::c_uint,
    #[doc = "< Holds the box's width in pixels."]
    pub x2: ::std::os::raw::c_uint,
    #[doc = "< Holds the box's height in pixels."]
    pub y2: ::std::os::raw::c_uint,
    #[doc = "< Holds the box's border width in pixels."]
    pub line_width: ::std::os::raw::c_uint,
    #[doc = "< Holds the box's border color."]
    pub line_color: NvOSD_ColorParams,
}
#[test]
fn bindgen_test_layout__NvOSD_LineParams() {
    assert_eq!(
        ::std::mem::size_of::<_NvOSD_LineParams>(),
        56usize,
        concat!("Size of: ", stringify!(_NvOSD_LineParams))
    );
    assert_eq!(
        ::std::mem::align_of::<_NvOSD_LineParams>(),
        8usize,
        concat!("Alignment of ", stringify!(_NvOSD_LineParams))
    );
    fn test_field_x1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvOSD_LineParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x1) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvOSD_LineParams),
                "::",
                stringify!(x1)
            )
        );
    }
    test_field_x1();
    fn test_field_y1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvOSD_LineParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y1) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvOSD_LineParams),
                "::",
                stringify!(y1)
            )
        );
    }
    test_field_y1();
    fn test_field_x2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvOSD_LineParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x2) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvOSD_LineParams),
                "::",
                stringify!(x2)
            )
        );
    }
    test_field_x2();
    fn test_field_y2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvOSD_LineParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y2) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvOSD_LineParams),
                "::",
                stringify!(y2)
            )
        );
    }
    test_field_y2();
    fn test_field_line_width() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvOSD_LineParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).line_width) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvOSD_LineParams),
                "::",
                stringify!(line_width)
            )
        );
    }
    test_field_line_width();
    fn test_field_line_color() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvOSD_LineParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).line_color) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvOSD_LineParams),
                "::",
                stringify!(line_color)
            )
        );
    }
    test_field_line_color();
}
#[doc = " Holds the box parameters of a line to be overlayed."]
pub type NvOSD_LineParams = _NvOSD_LineParams;
#[doc = " Holds arrow parameters to be overlaid."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvOSD_ArrowParams {
    #[doc = "< Holds the start horizontal coordinate in pixels."]
    pub x1: ::std::os::raw::c_uint,
    #[doc = "< Holds the start vertical coordinate in pixels."]
    pub y1: ::std::os::raw::c_uint,
    #[doc = "< Holds the end horizontal coordinate in pixels."]
    pub x2: ::std::os::raw::c_uint,
    #[doc = "< Holds the end vertical coordinate in pixels."]
    pub y2: ::std::os::raw::c_uint,
    #[doc = "< Holds the arrow shaft width in pixels."]
    pub arrow_width: ::std::os::raw::c_uint,
    pub arrow_head: NvOSD_Arrow_Head_Direction,
    pub arrow_color: NvOSD_ColorParams,
    #[doc = "< Reserved for future use; currently"]
    #[doc = "for internal use only."]
    pub reserved: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout__NvOSD_ArrowParams() {
    assert_eq!(
        ::std::mem::size_of::<_NvOSD_ArrowParams>(),
        64usize,
        concat!("Size of: ", stringify!(_NvOSD_ArrowParams))
    );
    assert_eq!(
        ::std::mem::align_of::<_NvOSD_ArrowParams>(),
        8usize,
        concat!("Alignment of ", stringify!(_NvOSD_ArrowParams))
    );
    fn test_field_x1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvOSD_ArrowParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x1) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvOSD_ArrowParams),
                "::",
                stringify!(x1)
            )
        );
    }
    test_field_x1();
    fn test_field_y1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvOSD_ArrowParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y1) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvOSD_ArrowParams),
                "::",
                stringify!(y1)
            )
        );
    }
    test_field_y1();
    fn test_field_x2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvOSD_ArrowParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x2) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvOSD_ArrowParams),
                "::",
                stringify!(x2)
            )
        );
    }
    test_field_x2();
    fn test_field_y2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvOSD_ArrowParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y2) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvOSD_ArrowParams),
                "::",
                stringify!(y2)
            )
        );
    }
    test_field_y2();
    fn test_field_arrow_width() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvOSD_ArrowParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).arrow_width) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvOSD_ArrowParams),
                "::",
                stringify!(arrow_width)
            )
        );
    }
    test_field_arrow_width();
    fn test_field_arrow_head() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvOSD_ArrowParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).arrow_head) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvOSD_ArrowParams),
                "::",
                stringify!(arrow_head)
            )
        );
    }
    test_field_arrow_head();
    fn test_field_arrow_color() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvOSD_ArrowParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).arrow_color) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvOSD_ArrowParams),
                "::",
                stringify!(arrow_color)
            )
        );
    }
    test_field_arrow_color();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvOSD_ArrowParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvOSD_ArrowParams),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[doc = " Holds arrow parameters to be overlaid."]
pub type NvOSD_ArrowParams = _NvOSD_ArrowParams;
#[doc = " Holds circle parameters to be overlayed."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvOSD_CircleParams {
    #[doc = "< Holds the start horizontal coordinate in pixels."]
    pub xc: ::std::os::raw::c_uint,
    #[doc = "< Holds the start vertical coordinate in pixels."]
    pub yc: ::std::os::raw::c_uint,
    #[doc = "< Holds the radius of circle in pixels."]
    pub radius: ::std::os::raw::c_uint,
    pub circle_color: NvOSD_ColorParams,
    pub has_bg_color: ::std::os::raw::c_uint,
    pub bg_color: NvOSD_ColorParams,
    #[doc = "< Reserved for future use; currently"]
    #[doc = "for internal use only."]
    pub reserved: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout__NvOSD_CircleParams() {
    assert_eq!(
        ::std::mem::size_of::<_NvOSD_CircleParams>(),
        96usize,
        concat!("Size of: ", stringify!(_NvOSD_CircleParams))
    );
    assert_eq!(
        ::std::mem::align_of::<_NvOSD_CircleParams>(),
        8usize,
        concat!("Alignment of ", stringify!(_NvOSD_CircleParams))
    );
    fn test_field_xc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvOSD_CircleParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).xc) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvOSD_CircleParams),
                "::",
                stringify!(xc)
            )
        );
    }
    test_field_xc();
    fn test_field_yc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvOSD_CircleParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).yc) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvOSD_CircleParams),
                "::",
                stringify!(yc)
            )
        );
    }
    test_field_yc();
    fn test_field_radius() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvOSD_CircleParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).radius) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvOSD_CircleParams),
                "::",
                stringify!(radius)
            )
        );
    }
    test_field_radius();
    fn test_field_circle_color() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvOSD_CircleParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).circle_color) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvOSD_CircleParams),
                "::",
                stringify!(circle_color)
            )
        );
    }
    test_field_circle_color();
    fn test_field_has_bg_color() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvOSD_CircleParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).has_bg_color) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvOSD_CircleParams),
                "::",
                stringify!(has_bg_color)
            )
        );
    }
    test_field_has_bg_color();
    fn test_field_bg_color() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvOSD_CircleParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bg_color) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvOSD_CircleParams),
                "::",
                stringify!(bg_color)
            )
        );
    }
    test_field_bg_color();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvOSD_CircleParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvOSD_CircleParams),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[doc = " Holds circle parameters to be overlayed."]
pub type NvOSD_CircleParams = _NvOSD_CircleParams;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvBufSurfaceParams {
    _unused: [u8; 0],
}
#[doc = " Holds metadata for a frame in a batch."]
pub type NvDsFrameMeta = _NvDsFrameMeta;
#[doc = " classifier meta list"]
pub type NvDsClassifierMetaList = GList;
#[doc = " user meta list"]
pub type NvDsUserMetaList = GList;
#[doc = " FP32 data type"]
pub const NvDsDataType_NvDsDataType_FP32: NvDsDataType = 0;
#[doc = " UINT8 data type"]
pub const NvDsDataType_NvDsDataType_UINT8: NvDsDataType = 1;
#[doc = " INT8 data type"]
pub const NvDsDataType_NvDsDataType_INT8: NvDsDataType = 2;
#[doc = " UINT32 data type"]
pub const NvDsDataType_NvDsDataType_UINT32: NvDsDataType = 3;
#[doc = " INT32 data type"]
pub const NvDsDataType_NvDsDataType_INT32: NvDsDataType = 4;
#[doc = " FP16 data type"]
pub const NvDsDataType_NvDsDataType_FP16: NvDsDataType = 5;
#[doc = " Data type used for model in infer"]
pub type NvDsDataType = ::std::os::raw::c_uint;
#[doc = " Full frames"]
pub const NvDsUnitType_NvDsUnitType_FullFrame: NvDsUnitType = 0;
#[doc = " Region of Interests (ROIs)"]
pub const NvDsUnitType_NvDsUnitType_ROI: NvDsUnitType = 1;
#[doc = " object mode"]
pub const NvDsUnitType_NvDsUnitType_Object: NvDsUnitType = 2;
#[doc = " Unit Type Fullframe/ROI/Crop Objects"]
pub type NvDsUnitType = ::std::os::raw::c_uint;
#[doc = " Holds Information about ROI Metadata"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvDsRoiMeta {
    pub roi: NvOSD_RectParams,
    #[doc = " currently not being used"]
    pub roi_polygon: [[guint; 2usize]; 8usize],
    pub converted_buffer: *mut NvBufSurfaceParams,
    pub frame_meta: *mut NvDsFrameMeta,
    #[doc = " Ratio by which the frame/ROI crop was scaled in horizontal direction"]
    #[doc = " Required when scaling co-ordinates/sizes in metadata"]
    #[doc = " back to input resolution."]
    pub scale_ratio_x: gdouble,
    #[doc = " Ratio by which the frame/ROI crop was scaled in vertical direction"]
    #[doc = " Required when scaling co-ordinates/sizes in metadata"]
    #[doc = " back to input resolution."]
    pub scale_ratio_y: gdouble,
    #[doc = " offsets in horizontal direction while scaling"]
    pub offset_left: gdouble,
    #[doc = " offsets in vertical direction while scaling"]
    pub offset_top: gdouble,
    #[doc = " Holds a pointer to a list of pointers of type @ref NvDsClassifierMeta."]
    pub classifier_meta_list: *mut NvDsClassifierMetaList,
    #[doc = " Holds a pointer to a list of pointers of type @ref NvDsUserMeta."]
    pub roi_user_meta_list: *mut NvDsUserMetaList,
}
#[test]
fn bindgen_test_layout_NvDsRoiMeta() {
    assert_eq!(
        ::std::mem::size_of::<NvDsRoiMeta>(),
        232usize,
        concat!("Size of: ", stringify!(NvDsRoiMeta))
    );
    assert_eq!(
        ::std::mem::align_of::<NvDsRoiMeta>(),
        8usize,
        concat!("Alignment of ", stringify!(NvDsRoiMeta))
    );
    fn test_field_roi() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NvDsRoiMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).roi) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NvDsRoiMeta),
                "::",
                stringify!(roi)
            )
        );
    }
    test_field_roi();
    fn test_field_roi_polygon() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NvDsRoiMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).roi_polygon) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(NvDsRoiMeta),
                "::",
                stringify!(roi_polygon)
            )
        );
    }
    test_field_roi_polygon();
    fn test_field_converted_buffer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NvDsRoiMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).converted_buffer) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(NvDsRoiMeta),
                "::",
                stringify!(converted_buffer)
            )
        );
    }
    test_field_converted_buffer();
    fn test_field_frame_meta() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NvDsRoiMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).frame_meta) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(NvDsRoiMeta),
                "::",
                stringify!(frame_meta)
            )
        );
    }
    test_field_frame_meta();
    fn test_field_scale_ratio_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NvDsRoiMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).scale_ratio_x) as usize - ptr as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(NvDsRoiMeta),
                "::",
                stringify!(scale_ratio_x)
            )
        );
    }
    test_field_scale_ratio_x();
    fn test_field_scale_ratio_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NvDsRoiMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).scale_ratio_y) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(NvDsRoiMeta),
                "::",
                stringify!(scale_ratio_y)
            )
        );
    }
    test_field_scale_ratio_y();
    fn test_field_offset_left() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NvDsRoiMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).offset_left) as usize - ptr as usize
            },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(NvDsRoiMeta),
                "::",
                stringify!(offset_left)
            )
        );
    }
    test_field_offset_left();
    fn test_field_offset_top() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NvDsRoiMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).offset_top) as usize - ptr as usize
            },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(NvDsRoiMeta),
                "::",
                stringify!(offset_top)
            )
        );
    }
    test_field_offset_top();
    fn test_field_classifier_meta_list() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NvDsRoiMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).classifier_meta_list) as usize - ptr as usize
            },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(NvDsRoiMeta),
                "::",
                stringify!(classifier_meta_list)
            )
        );
    }
    test_field_classifier_meta_list();
    fn test_field_roi_user_meta_list() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NvDsRoiMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).roi_user_meta_list) as usize - ptr as usize
            },
            224usize,
            concat!(
                "Offset of field: ",
                stringify!(NvDsRoiMeta),
                "::",
                stringify!(roi_user_meta_list)
            )
        );
    }
    test_field_roi_user_meta_list();
}
pub type NvDsFrameMetaList = GList;
pub type NvDsObjectMetaList = GList;
pub type NvDisplayMetaList = GList;
pub type NvDsLabelInfoList = GList;
pub type NvDsMetaList = GList;
pub type NvDsElementMeta = ::std::os::raw::c_void;
#[doc = " \\brief  Defines the type of a callback to copy metadata."]
#[doc = ""]
#[doc = " The callback is passed pointers to source metadata. It allocates the"]
#[doc = " required memory, copies the content from the source metadata and returns"]
#[doc = " a pointer to the destination."]
#[doc = ""]
#[doc = " @param[in]  data         A pointer to the source metadata."]
#[doc = " @param[in]  user_data    A pointer to user-specific data."]
pub type NvDsMetaCopyFunc =
    ::std::option::Option<unsafe extern "C" fn(data: gpointer, user_data: gpointer) -> gpointer>;
#[doc = " \\brief  Defines the type of a callback to free metadata."]
#[doc = ""]
#[doc = " The callback is passed a pointer to metadata created by NvDsMetaCopyFunc()."]
#[doc = " It frees the metadata and"]
#[doc = " any other resources that the metadata uses."]
#[doc = ""]
#[doc = " @param[in]  data         A pointer to the metadata to be freed."]
#[doc = " @param[in]  user_data    A pointer to user-specific data."]
pub type NvDsMetaReleaseFunc =
    ::std::option::Option<unsafe extern "C" fn(data: gpointer, user_data: gpointer)>;
pub const NvDsMetaType_NVDS_INVALID_META: NvDsMetaType = -1;
#[doc = " Specifies metadata type for formed batch."]
pub const NvDsMetaType_NVDS_BATCH_META: NvDsMetaType = 1;
#[doc = " Specifies metadata type for frame."]
pub const NvDsMetaType_NVDS_FRAME_META: NvDsMetaType = 2;
#[doc = " Specifies metadata type for a detected object."]
pub const NvDsMetaType_NVDS_OBJ_META: NvDsMetaType = 3;
#[doc = " Specifies metadata type for display."]
pub const NvDsMetaType_NVDS_DISPLAY_META: NvDsMetaType = 4;
#[doc = " Specifies metadata type for an object classifier."]
pub const NvDsMetaType_NVDS_CLASSIFIER_META: NvDsMetaType = 5;
#[doc = " Specifies metadata type for a label assigned by a classifier."]
pub const NvDsMetaType_NVDS_LABEL_INFO_META: NvDsMetaType = 6;
#[doc = " Reserved for internal use."]
pub const NvDsMetaType_NVDS_USER_META: NvDsMetaType = 7;
#[doc = " Specifies metadata type for a payload generated by a message converter."]
pub const NvDsMetaType_NVDS_PAYLOAD_META: NvDsMetaType = 8;
#[doc = " Specifies metadata type for a payload generated by a message broker."]
pub const NvDsMetaType_NVDS_EVENT_MSG_META: NvDsMetaType = 9;
#[doc = " Specifies metadata type for an optical flow."]
pub const NvDsMetaType_NVDS_OPTICAL_FLOW_META: NvDsMetaType = 10;
#[doc = " Specifies metadata type for a latency measurement."]
pub const NvDsMetaType_NVDS_LATENCY_MEASUREMENT_META: NvDsMetaType = 11;
#[doc = " Specifies metadata type for raw inference output attached by Gst-nvinfer."]
#[doc = "@see NvDsInferTensorMeta for details."]
pub const NvDsMetaType_NVDSINFER_TENSOR_OUTPUT_META: NvDsMetaType = 12;
#[doc = " Specifies metadata type for segmentation model output attached by"]
#[doc = "Gst-nvinfer. @see NvDsInferSegmentationMeta for details."]
pub const NvDsMetaType_NVDSINFER_SEGMENTATION_META: NvDsMetaType = 13;
#[doc = " Specifies metadata type for JPEG-encoded object crops."]
#[doc = " See the deepstream-image-meta-test app for details."]
pub const NvDsMetaType_NVDS_CROP_IMAGE_META: NvDsMetaType = 14;
#[doc = " metadata type to be set for tracking previous frames"]
pub const NvDsMetaType_NVDS_TRACKER_PAST_FRAME_META: NvDsMetaType = 15;
#[doc = " Specifies metadata type for formed audio batch."]
pub const NvDsMetaType_NVDS_AUDIO_BATCH_META: NvDsMetaType = 16;
#[doc = " Specifies metadata type for audio frame."]
pub const NvDsMetaType_NVDS_AUDIO_FRAME_META: NvDsMetaType = 17;
#[doc = " Specifies metadata type for preprocess scale&converted ROIs attached by Gst-nvdspreprocess."]
#[doc = "@see NvDsPreProcessFrameMeta for details."]
pub const NvDsMetaType_NVDS_PREPROCESS_FRAME_META: NvDsMetaType = 18;
#[doc = " Specifies metadata type for preprocess batch level attached by Gst-nvdspreprocess."]
#[doc = "@see NvDsPreProcessBatchMeta for details."]
pub const NvDsMetaType_NVDS_PREPROCESS_BATCH_META: NvDsMetaType = 19;
#[doc = " Specifies user defined custom message blob to be part of payload generated"]
pub const NvDsMetaType_NVDS_CUSTOM_MSG_BLOB: NvDsMetaType = 20;
#[doc = " Reserved field"]
pub const NvDsMetaType_NVDS_RESERVED_META: NvDsMetaType = 4095;
#[doc = " Specifies the start of a range of enum values that represent types of"]
#[doc = " NVIDIA-defined Gst metas. The range is from NVDS_GST_CUSTOM_META to"]
#[doc = " NVDS_GST_CUSTOM_META+4096, inclusive."]
pub const NvDsMetaType_NVDS_GST_CUSTOM_META: NvDsMetaType = 4096;
#[doc = " Start adding user specific meta types from here */"]
#[doc = " Specifies the start of a range of enum values that represent custom"]
#[doc = " (application-specific) Gst meta types. A custom meta type may be assigned"]
#[doc = " any enum value equal to or larger than this."]
#[doc = ""]
#[doc = " Such Gst metas may be attached by GStreamer plugins upstream from"]
#[doc = " Gst-nvstreammux. They may have any contents that is a superset of"]
#[doc = " the metadata in an @ref NvDsFrameMeta."]
pub const NvDsMetaType_NVDS_START_USER_META: NvDsMetaType = 8193;
#[doc = " Start adding user specific meta types from here */"]
#[doc = " Specifies the start of a range of enum values that represent custom"]
#[doc = " (application-specific) Gst meta types. A custom meta type may be assigned"]
#[doc = " any enum value equal to or larger than this."]
#[doc = ""]
#[doc = " Such Gst metas may be attached by GStreamer plugins upstream from"]
#[doc = " Gst-nvstreammux. They may have any contents that is a superset of"]
#[doc = " the metadata in an @ref NvDsFrameMeta."]
pub const NvDsMetaType_NVDS_FORCE32_META: NvDsMetaType = 2147483647;
#[doc = " Specifies the type of metadata. All metadata types are subtypes of"]
#[doc = " @ref NvDsMetaType. Members that represent NVIDIA-defined types are"]
#[doc = " in the range from @ref NVDS_BATCH_META to @ref NVDS_START_USER_META."]
#[doc = " User-defined types may be assigned values greater than or equal to"]
#[doc = " @ref NVDS_START_USER_META."]
pub type NvDsMetaType = ::std::os::raw::c_int;
#[doc = " Holds unclipped positional bounding box coordinates of the object processed"]
#[doc = " by the component."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvDsComp_BboxInfo {
    pub org_bbox_coords: NvBbox_Coords,
}
#[test]
fn bindgen_test_layout__NvDsComp_BboxInfo() {
    assert_eq!(
        ::std::mem::size_of::<_NvDsComp_BboxInfo>(),
        16usize,
        concat!("Size of: ", stringify!(_NvDsComp_BboxInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_NvDsComp_BboxInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(_NvDsComp_BboxInfo))
    );
    fn test_field_org_bbox_coords() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsComp_BboxInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).org_bbox_coords) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsComp_BboxInfo),
                "::",
                stringify!(org_bbox_coords)
            )
        );
    }
    test_field_org_bbox_coords();
}
#[doc = " Holds unclipped positional bounding box coordinates of the object processed"]
#[doc = " by the component."]
pub type NvDsComp_BboxInfo = _NvDsComp_BboxInfo;
#[doc = " Holds information about a given metadata pool."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvDsMetaPool {
    pub meta_type: NvDsMetaType,
    pub max_elements_in_pool: guint,
    pub element_size: guint,
    pub num_empty_elements: guint,
    pub num_full_elements: guint,
    pub empty_list: *mut NvDsMetaList,
    pub full_list: *mut NvDsMetaList,
    pub copy_func: NvDsMetaCopyFunc,
    pub release_func: NvDsMetaReleaseFunc,
}
#[test]
fn bindgen_test_layout__NvDsMetaPool() {
    assert_eq!(
        ::std::mem::size_of::<_NvDsMetaPool>(),
        56usize,
        concat!("Size of: ", stringify!(_NvDsMetaPool))
    );
    assert_eq!(
        ::std::mem::align_of::<_NvDsMetaPool>(),
        8usize,
        concat!("Alignment of ", stringify!(_NvDsMetaPool))
    );
    fn test_field_meta_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsMetaPool>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).meta_type) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsMetaPool),
                "::",
                stringify!(meta_type)
            )
        );
    }
    test_field_meta_type();
    fn test_field_max_elements_in_pool() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsMetaPool>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).max_elements_in_pool) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsMetaPool),
                "::",
                stringify!(max_elements_in_pool)
            )
        );
    }
    test_field_max_elements_in_pool();
    fn test_field_element_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsMetaPool>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).element_size) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsMetaPool),
                "::",
                stringify!(element_size)
            )
        );
    }
    test_field_element_size();
    fn test_field_num_empty_elements() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsMetaPool>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).num_empty_elements) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsMetaPool),
                "::",
                stringify!(num_empty_elements)
            )
        );
    }
    test_field_num_empty_elements();
    fn test_field_num_full_elements() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsMetaPool>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).num_full_elements) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsMetaPool),
                "::",
                stringify!(num_full_elements)
            )
        );
    }
    test_field_num_full_elements();
    fn test_field_empty_list() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsMetaPool>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).empty_list) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsMetaPool),
                "::",
                stringify!(empty_list)
            )
        );
    }
    test_field_empty_list();
    fn test_field_full_list() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsMetaPool>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).full_list) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsMetaPool),
                "::",
                stringify!(full_list)
            )
        );
    }
    test_field_full_list();
    fn test_field_copy_func() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsMetaPool>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).copy_func) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsMetaPool),
                "::",
                stringify!(copy_func)
            )
        );
    }
    test_field_copy_func();
    fn test_field_release_func() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsMetaPool>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).release_func) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsMetaPool),
                "::",
                stringify!(release_func)
            )
        );
    }
    test_field_release_func();
}
#[doc = " Holds information about a given metadata pool."]
pub type NvDsMetaPool = _NvDsMetaPool;
#[doc = " Holds information about base metadata of a given metadata type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvDsBaseMeta {
    #[doc = " Holds a pointer to batch_meta @ref NvDsBatchMeta."]
    pub batch_meta: *mut _NvDsBatchMeta,
    #[doc = " Holds the metadata type of this metadata element."]
    pub meta_type: NvDsMetaType,
    #[doc = " Holds a pointer to a user context."]
    pub uContext: *mut ::std::os::raw::c_void,
    #[doc = " Holds a user-defined copy function. The function is called to copy"]
    #[doc = "or transform metadata from one buffer to another. @a meta_data and"]
    #[doc = "@a user_data are passed as arguments."]
    pub copy_func: NvDsMetaCopyFunc,
    #[doc = " Holds a user-defined release function. The function is called"]
    #[doc = "when @a meta_data is to be released."]
    pub release_func: NvDsMetaReleaseFunc,
}
#[test]
fn bindgen_test_layout__NvDsBaseMeta() {
    assert_eq!(
        ::std::mem::size_of::<_NvDsBaseMeta>(),
        40usize,
        concat!("Size of: ", stringify!(_NvDsBaseMeta))
    );
    assert_eq!(
        ::std::mem::align_of::<_NvDsBaseMeta>(),
        8usize,
        concat!("Alignment of ", stringify!(_NvDsBaseMeta))
    );
    fn test_field_batch_meta() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsBaseMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).batch_meta) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsBaseMeta),
                "::",
                stringify!(batch_meta)
            )
        );
    }
    test_field_batch_meta();
    fn test_field_meta_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsBaseMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).meta_type) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsBaseMeta),
                "::",
                stringify!(meta_type)
            )
        );
    }
    test_field_meta_type();
    fn test_field_uContext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsBaseMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uContext) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsBaseMeta),
                "::",
                stringify!(uContext)
            )
        );
    }
    test_field_uContext();
    fn test_field_copy_func() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsBaseMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).copy_func) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsBaseMeta),
                "::",
                stringify!(copy_func)
            )
        );
    }
    test_field_copy_func();
    fn test_field_release_func() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsBaseMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).release_func) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsBaseMeta),
                "::",
                stringify!(release_func)
            )
        );
    }
    test_field_release_func();
}
#[doc = " Holds information about base metadata of a given metadata type."]
pub type NvDsBaseMeta = _NvDsBaseMeta;
#[doc = " Holds information about a formed batch containing frames from different"]
#[doc = " sources."]
#[doc = " NOTE: Both Video and Audio metadata uses the same NvDsBatchMeta type."]
#[doc = " NOTE: Audio batch metadata is formed within nvinferaudio plugin"]
#[doc = " and will not be corresponding to any one buffer output from nvinferaudio."]
#[doc = " The NvDsBatchMeta for audio is attached to the last input buffer"]
#[doc = " when the audio batch buffering reach configurable threshold"]
#[doc = " (audio frame length) and this is when inference output is available."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvDsBatchMeta {
    pub base_meta: NvDsBaseMeta,
    #[doc = " Holds the maximum number of frames in the batch."]
    pub max_frames_in_batch: guint,
    #[doc = " Holds the number of frames now in the batch."]
    pub num_frames_in_batch: guint,
    #[doc = " Holds a pointer to a pool of pointers of type @ref NvDsFrameMeta,"]
    #[doc = "representing a pool of frame metas."]
    pub frame_meta_pool: *mut NvDsMetaPool,
    #[doc = " Holds a pointer to a pool of pointers of type NvDsObjMeta,"]
    #[doc = "representing a pool of object metas."]
    pub obj_meta_pool: *mut NvDsMetaPool,
    #[doc = " Holds a pointer to a pool of pointers of type @ref NvDsClassifierMeta,"]
    #[doc = "representing a pool of classifier metas."]
    pub classifier_meta_pool: *mut NvDsMetaPool,
    #[doc = " Holds a pointer to a pool of pointers of type @ref NvDsDisplayMeta,"]
    #[doc = "representing a pool of display metas."]
    pub display_meta_pool: *mut NvDsMetaPool,
    #[doc = " Holds a pointer to a pool of pointers of type @ref NvDsUserMeta,"]
    #[doc = "representing a pool of user metas."]
    pub user_meta_pool: *mut NvDsMetaPool,
    #[doc = " Holds a pointer to a pool of pointers of type @ref NvDsLabelInfo,"]
    #[doc = "representing a pool of label metas."]
    pub label_info_meta_pool: *mut NvDsMetaPool,
    #[doc = " Holds a pointer to a list of pointers of type NvDsFrameMeta"]
    #[doc = "or NvDsAudioFrameMeta (when the batch represent audio batch),"]
    #[doc = "representing frame metas used in the current batch."]
    pub frame_meta_list: *mut NvDsFrameMetaList,
    #[doc = " Holds a pointer to a list of pointers of type NvDsUserMeta,"]
    #[doc = "representing user metas in the current batch."]
    pub batch_user_meta_list: *mut NvDsUserMetaList,
    #[doc = " Holds a lock to be set before accessing metadata to avoid"]
    #[doc = "simultaneous update by multiple components."]
    pub meta_mutex: GRecMutex,
    #[doc = " Holds an array of user-specific batch information."]
    pub misc_batch_info: [gint64; 4usize],
    #[doc = " For internal use."]
    pub reserved: [gint64; 4usize],
}
#[test]
fn bindgen_test_layout__NvDsBatchMeta() {
    assert_eq!(
        ::std::mem::size_of::<_NvDsBatchMeta>(),
        192usize,
        concat!("Size of: ", stringify!(_NvDsBatchMeta))
    );
    assert_eq!(
        ::std::mem::align_of::<_NvDsBatchMeta>(),
        8usize,
        concat!("Alignment of ", stringify!(_NvDsBatchMeta))
    );
    fn test_field_base_meta() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsBatchMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base_meta) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsBatchMeta),
                "::",
                stringify!(base_meta)
            )
        );
    }
    test_field_base_meta();
    fn test_field_max_frames_in_batch() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsBatchMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).max_frames_in_batch) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsBatchMeta),
                "::",
                stringify!(max_frames_in_batch)
            )
        );
    }
    test_field_max_frames_in_batch();
    fn test_field_num_frames_in_batch() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsBatchMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).num_frames_in_batch) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsBatchMeta),
                "::",
                stringify!(num_frames_in_batch)
            )
        );
    }
    test_field_num_frames_in_batch();
    fn test_field_frame_meta_pool() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsBatchMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).frame_meta_pool) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsBatchMeta),
                "::",
                stringify!(frame_meta_pool)
            )
        );
    }
    test_field_frame_meta_pool();
    fn test_field_obj_meta_pool() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsBatchMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).obj_meta_pool) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsBatchMeta),
                "::",
                stringify!(obj_meta_pool)
            )
        );
    }
    test_field_obj_meta_pool();
    fn test_field_classifier_meta_pool() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsBatchMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).classifier_meta_pool) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsBatchMeta),
                "::",
                stringify!(classifier_meta_pool)
            )
        );
    }
    test_field_classifier_meta_pool();
    fn test_field_display_meta_pool() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsBatchMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).display_meta_pool) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsBatchMeta),
                "::",
                stringify!(display_meta_pool)
            )
        );
    }
    test_field_display_meta_pool();
    fn test_field_user_meta_pool() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsBatchMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).user_meta_pool) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsBatchMeta),
                "::",
                stringify!(user_meta_pool)
            )
        );
    }
    test_field_user_meta_pool();
    fn test_field_label_info_meta_pool() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsBatchMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).label_info_meta_pool) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsBatchMeta),
                "::",
                stringify!(label_info_meta_pool)
            )
        );
    }
    test_field_label_info_meta_pool();
    fn test_field_frame_meta_list() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsBatchMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).frame_meta_list) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsBatchMeta),
                "::",
                stringify!(frame_meta_list)
            )
        );
    }
    test_field_frame_meta_list();
    fn test_field_batch_user_meta_list() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsBatchMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).batch_user_meta_list) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsBatchMeta),
                "::",
                stringify!(batch_user_meta_list)
            )
        );
    }
    test_field_batch_user_meta_list();
    fn test_field_meta_mutex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsBatchMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).meta_mutex) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsBatchMeta),
                "::",
                stringify!(meta_mutex)
            )
        );
    }
    test_field_meta_mutex();
    fn test_field_misc_batch_info() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsBatchMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).misc_batch_info) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsBatchMeta),
                "::",
                stringify!(misc_batch_info)
            )
        );
    }
    test_field_misc_batch_info();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsBatchMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsBatchMeta),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[doc = " Holds information about a formed batch containing frames from different"]
#[doc = " sources."]
#[doc = " NOTE: Both Video and Audio metadata uses the same NvDsBatchMeta type."]
#[doc = " NOTE: Audio batch metadata is formed within nvinferaudio plugin"]
#[doc = " and will not be corresponding to any one buffer output from nvinferaudio."]
#[doc = " The NvDsBatchMeta for audio is attached to the last input buffer"]
#[doc = " when the audio batch buffering reach configurable threshold"]
#[doc = " (audio frame length) and this is when inference output is available."]
pub type NvDsBatchMeta = _NvDsBatchMeta;
#[doc = " Holds metadata for a frame in a batch."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvDsFrameMeta {
    #[doc = " Holds the base metadata for the frame."]
    pub base_meta: NvDsBaseMeta,
    #[doc = " Holds the pad or port index of the Gst-streammux plugin for the frame"]
    #[doc = "in the batch."]
    pub pad_index: guint,
    #[doc = " Holds the location of the frame in the batch. The frame's"]
    #[doc = "@ref NvBufSurfaceParams are at index @a batch_id in the @a surfaceList"]
    #[doc = "array of @ref NvBufSurface."]
    pub batch_id: guint,
    #[doc = " Holds the current frame number of the source."]
    pub frame_num: gint,
    #[doc = " Holds the presentation timestamp (PTS) of the frame."]
    pub buf_pts: guint64,
    #[doc = " Holds the ntp timestamp."]
    pub ntp_timestamp: guint64,
    #[doc = " Holds the source IDof the frame in the batch, e.g. the camera ID."]
    #[doc = "It need not be in sequential order."]
    pub source_id: guint,
    #[doc = " Holds the number of surfaces in the frame, required in case of"]
    #[doc = "multiple surfaces in the frame."]
    pub num_surfaces_per_frame: gint,
    pub source_frame_width: guint,
    pub source_frame_height: guint,
    pub surface_type: guint,
    pub surface_index: guint,
    #[doc = " Holds the number of object meta elements attached to current frame."]
    pub num_obj_meta: guint,
    #[doc = " Holds a Boolean indicating whether inference is performed on the frame."]
    pub bInferDone: gboolean,
    #[doc = " Holds a pointer to a list of pointers of type @ref NvDsObjectMeta"]
    #[doc = "in use for the frame."]
    pub obj_meta_list: *mut NvDsObjectMetaList,
    #[doc = " Holds a pointer to a list of pointers of type @ref NvDsDisplayMeta"]
    #[doc = "in use for the frame."]
    pub display_meta_list: *mut NvDisplayMetaList,
    #[doc = " Holds a pointer to a list of pointers of type @ref NvDsUserMeta"]
    #[doc = "in use for the frame."]
    pub frame_user_meta_list: *mut NvDsUserMetaList,
    #[doc = " Holds additional user-defined frame information."]
    pub misc_frame_info: [gint64; 4usize],
    pub pipeline_width: guint,
    pub pipeline_height: guint,
    #[doc = " For internal use."]
    pub reserved: [gint64; 4usize],
}
#[test]
fn bindgen_test_layout__NvDsFrameMeta() {
    assert_eq!(
        ::std::mem::size_of::<_NvDsFrameMeta>(),
        200usize,
        concat!("Size of: ", stringify!(_NvDsFrameMeta))
    );
    assert_eq!(
        ::std::mem::align_of::<_NvDsFrameMeta>(),
        8usize,
        concat!("Alignment of ", stringify!(_NvDsFrameMeta))
    );
    fn test_field_base_meta() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsFrameMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base_meta) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsFrameMeta),
                "::",
                stringify!(base_meta)
            )
        );
    }
    test_field_base_meta();
    fn test_field_pad_index() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsFrameMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pad_index) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsFrameMeta),
                "::",
                stringify!(pad_index)
            )
        );
    }
    test_field_pad_index();
    fn test_field_batch_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsFrameMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).batch_id) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsFrameMeta),
                "::",
                stringify!(batch_id)
            )
        );
    }
    test_field_batch_id();
    fn test_field_frame_num() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsFrameMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).frame_num) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsFrameMeta),
                "::",
                stringify!(frame_num)
            )
        );
    }
    test_field_frame_num();
    fn test_field_buf_pts() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsFrameMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).buf_pts) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsFrameMeta),
                "::",
                stringify!(buf_pts)
            )
        );
    }
    test_field_buf_pts();
    fn test_field_ntp_timestamp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsFrameMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ntp_timestamp) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsFrameMeta),
                "::",
                stringify!(ntp_timestamp)
            )
        );
    }
    test_field_ntp_timestamp();
    fn test_field_source_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsFrameMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).source_id) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsFrameMeta),
                "::",
                stringify!(source_id)
            )
        );
    }
    test_field_source_id();
    fn test_field_num_surfaces_per_frame() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsFrameMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).num_surfaces_per_frame) as usize - ptr as usize
            },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsFrameMeta),
                "::",
                stringify!(num_surfaces_per_frame)
            )
        );
    }
    test_field_num_surfaces_per_frame();
    fn test_field_source_frame_width() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsFrameMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).source_frame_width) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsFrameMeta),
                "::",
                stringify!(source_frame_width)
            )
        );
    }
    test_field_source_frame_width();
    fn test_field_source_frame_height() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsFrameMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).source_frame_height) as usize - ptr as usize
            },
            84usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsFrameMeta),
                "::",
                stringify!(source_frame_height)
            )
        );
    }
    test_field_source_frame_height();
    fn test_field_surface_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsFrameMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).surface_type) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsFrameMeta),
                "::",
                stringify!(surface_type)
            )
        );
    }
    test_field_surface_type();
    fn test_field_surface_index() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsFrameMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).surface_index) as usize - ptr as usize
            },
            92usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsFrameMeta),
                "::",
                stringify!(surface_index)
            )
        );
    }
    test_field_surface_index();
    fn test_field_num_obj_meta() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsFrameMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).num_obj_meta) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsFrameMeta),
                "::",
                stringify!(num_obj_meta)
            )
        );
    }
    test_field_num_obj_meta();
    fn test_field_bInferDone() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsFrameMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bInferDone) as usize - ptr as usize
            },
            100usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsFrameMeta),
                "::",
                stringify!(bInferDone)
            )
        );
    }
    test_field_bInferDone();
    fn test_field_obj_meta_list() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsFrameMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).obj_meta_list) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsFrameMeta),
                "::",
                stringify!(obj_meta_list)
            )
        );
    }
    test_field_obj_meta_list();
    fn test_field_display_meta_list() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsFrameMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).display_meta_list) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsFrameMeta),
                "::",
                stringify!(display_meta_list)
            )
        );
    }
    test_field_display_meta_list();
    fn test_field_frame_user_meta_list() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsFrameMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).frame_user_meta_list) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsFrameMeta),
                "::",
                stringify!(frame_user_meta_list)
            )
        );
    }
    test_field_frame_user_meta_list();
    fn test_field_misc_frame_info() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsFrameMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).misc_frame_info) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsFrameMeta),
                "::",
                stringify!(misc_frame_info)
            )
        );
    }
    test_field_misc_frame_info();
    fn test_field_pipeline_width() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsFrameMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pipeline_width) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsFrameMeta),
                "::",
                stringify!(pipeline_width)
            )
        );
    }
    test_field_pipeline_width();
    fn test_field_pipeline_height() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsFrameMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pipeline_height) as usize - ptr as usize
            },
            164usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsFrameMeta),
                "::",
                stringify!(pipeline_height)
            )
        );
    }
    test_field_pipeline_height();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsFrameMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsFrameMeta),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[doc = " Holds metadata for an object in the frame."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvDsObjectMeta {
    pub base_meta: NvDsBaseMeta,
    #[doc = " Holds a pointer to the parent @ref NvDsObjectMeta. Set to NULL if"]
    #[doc = "no parent exists."]
    pub parent: *mut _NvDsObjectMeta,
    #[doc = " Holds a unique component ID that identifies the metadata"]
    #[doc = "in this structure."]
    pub unique_component_id: gint,
    #[doc = " Holds the index of the object class inferred by the primary"]
    #[doc = "detector/classifier."]
    pub class_id: gint,
    #[doc = " Holds a unique ID for tracking the object. @ref UNTRACKED_OBJECT_ID"]
    #[doc = "indicates that the object has not been tracked."]
    pub object_id: guint64,
    #[doc = " Holds a structure containing bounding box parameters of the object when"]
    #[doc = "detected by detector."]
    pub detector_bbox_info: NvDsComp_BboxInfo,
    #[doc = " Holds a structure containing bounding box coordinates of the object when"]
    #[doc = " processed by tracker."]
    pub tracker_bbox_info: NvDsComp_BboxInfo,
    #[doc = " Holds a confidence value for the object, set by the inference"]
    #[doc = "component. confidence will be set to -0.1, if \"Group Rectangles\" mode of"]
    #[doc = "clustering is chosen since the algorithm does not preserve confidence"]
    #[doc = "values. Also, for objects found by tracker and not inference component,"]
    #[doc = "confidence will be set to -0.1"]
    pub confidence: gfloat,
    #[doc = " Holds a confidence value for the object set by nvdcf_tracker."]
    #[doc = " tracker_confidence will be set to -0.1 for KLT and IOU tracker"]
    pub tracker_confidence: gfloat,
    #[doc = " Holds a structure containing positional parameters of the object"]
    #[doc = " processed by the last component that updates it in the pipeline."]
    #[doc = " e.g. If the tracker component is after the detector component in the"]
    #[doc = " pipeline then positinal parameters are from tracker component."]
    #[doc = " Positional parameters are clipped so that they do not fall outside frame"]
    #[doc = " boundary. Can also be used to overlay borders or semi-transparent boxes on"]
    #[doc = " objects. @see NvOSD_RectParams."]
    pub rect_params: NvOSD_RectParams,
    #[doc = " Holds mask parameters for the object. This mask is overlayed on object"]
    #[doc = " @see NvOSD_MaskParams."]
    pub mask_params: NvOSD_MaskParams,
    #[doc = " Holds text describing the object. This text can be overlayed on the"]
    #[doc = "standard text that identifies the object. @see NvOSD_TextParams."]
    pub text_params: NvOSD_TextParams,
    #[doc = " Holds a string describing the class of the detected object."]
    pub obj_label: [gchar; 128usize],
    #[doc = " Holds a pointer to a list of pointers of type @ref NvDsClassifierMeta."]
    pub classifier_meta_list: *mut NvDsClassifierMetaList,
    #[doc = " Holds a pointer to a list of pointers of type @ref NvDsUserMeta."]
    pub obj_user_meta_list: *mut NvDsUserMetaList,
    #[doc = " Holds additional user-defined object information."]
    pub misc_obj_info: [gint64; 4usize],
    #[doc = " For internal use."]
    pub reserved: [gint64; 4usize],
}
#[test]
fn bindgen_test_layout__NvDsObjectMeta() {
    assert_eq!(
        ::std::mem::size_of::<_NvDsObjectMeta>(),
        544usize,
        concat!("Size of: ", stringify!(_NvDsObjectMeta))
    );
    assert_eq!(
        ::std::mem::align_of::<_NvDsObjectMeta>(),
        8usize,
        concat!("Alignment of ", stringify!(_NvDsObjectMeta))
    );
    fn test_field_base_meta() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsObjectMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base_meta) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsObjectMeta),
                "::",
                stringify!(base_meta)
            )
        );
    }
    test_field_base_meta();
    fn test_field_parent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsObjectMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsObjectMeta),
                "::",
                stringify!(parent)
            )
        );
    }
    test_field_parent();
    fn test_field_unique_component_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsObjectMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unique_component_id) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsObjectMeta),
                "::",
                stringify!(unique_component_id)
            )
        );
    }
    test_field_unique_component_id();
    fn test_field_class_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsObjectMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).class_id) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsObjectMeta),
                "::",
                stringify!(class_id)
            )
        );
    }
    test_field_class_id();
    fn test_field_object_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsObjectMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).object_id) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsObjectMeta),
                "::",
                stringify!(object_id)
            )
        );
    }
    test_field_object_id();
    fn test_field_detector_bbox_info() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsObjectMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).detector_bbox_info) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsObjectMeta),
                "::",
                stringify!(detector_bbox_info)
            )
        );
    }
    test_field_detector_bbox_info();
    fn test_field_tracker_bbox_info() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsObjectMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tracker_bbox_info) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsObjectMeta),
                "::",
                stringify!(tracker_bbox_info)
            )
        );
    }
    test_field_tracker_bbox_info();
    fn test_field_confidence() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsObjectMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).confidence) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsObjectMeta),
                "::",
                stringify!(confidence)
            )
        );
    }
    test_field_confidence();
    fn test_field_tracker_confidence() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsObjectMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tracker_confidence) as usize - ptr as usize
            },
            100usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsObjectMeta),
                "::",
                stringify!(tracker_confidence)
            )
        );
    }
    test_field_tracker_confidence();
    fn test_field_rect_params() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsObjectMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rect_params) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsObjectMeta),
                "::",
                stringify!(rect_params)
            )
        );
    }
    test_field_rect_params();
    fn test_field_mask_params() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsObjectMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mask_params) as usize - ptr as usize
            },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsObjectMeta),
                "::",
                stringify!(mask_params)
            )
        );
    }
    test_field_mask_params();
    fn test_field_text_params() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsObjectMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).text_params) as usize - ptr as usize
            },
            232usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsObjectMeta),
                "::",
                stringify!(text_params)
            )
        );
    }
    test_field_text_params();
    fn test_field_obj_label() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsObjectMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).obj_label) as usize - ptr as usize
            },
            336usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsObjectMeta),
                "::",
                stringify!(obj_label)
            )
        );
    }
    test_field_obj_label();
    fn test_field_classifier_meta_list() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsObjectMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).classifier_meta_list) as usize - ptr as usize
            },
            464usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsObjectMeta),
                "::",
                stringify!(classifier_meta_list)
            )
        );
    }
    test_field_classifier_meta_list();
    fn test_field_obj_user_meta_list() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsObjectMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).obj_user_meta_list) as usize - ptr as usize
            },
            472usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsObjectMeta),
                "::",
                stringify!(obj_user_meta_list)
            )
        );
    }
    test_field_obj_user_meta_list();
    fn test_field_misc_obj_info() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsObjectMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).misc_obj_info) as usize - ptr as usize
            },
            480usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsObjectMeta),
                "::",
                stringify!(misc_obj_info)
            )
        );
    }
    test_field_misc_obj_info();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsObjectMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            512usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsObjectMeta),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[doc = " Holds metadata for an object in the frame."]
pub type NvDsObjectMeta = _NvDsObjectMeta;
#[doc = " Holds classifier metadata for an object."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvDsClassifierMeta {
    pub base_meta: NvDsBaseMeta,
    #[doc = " Holds the number of outputs/labels produced by the classifier."]
    pub num_labels: guint,
    #[doc = " Holds a unique component ID for the classifier metadata."]
    pub unique_component_id: gint,
    #[doc = " Holds a pointer to a list of pointers of type @ref NvDsLabelInfo."]
    pub label_info_list: *mut NvDsLabelInfoList,
    #[doc = " Holds the type of the classifier."]
    pub classifier_type: *const gchar,
}
#[test]
fn bindgen_test_layout__NvDsClassifierMeta() {
    assert_eq!(
        ::std::mem::size_of::<_NvDsClassifierMeta>(),
        64usize,
        concat!("Size of: ", stringify!(_NvDsClassifierMeta))
    );
    assert_eq!(
        ::std::mem::align_of::<_NvDsClassifierMeta>(),
        8usize,
        concat!("Alignment of ", stringify!(_NvDsClassifierMeta))
    );
    fn test_field_base_meta() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsClassifierMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base_meta) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsClassifierMeta),
                "::",
                stringify!(base_meta)
            )
        );
    }
    test_field_base_meta();
    fn test_field_num_labels() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsClassifierMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).num_labels) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsClassifierMeta),
                "::",
                stringify!(num_labels)
            )
        );
    }
    test_field_num_labels();
    fn test_field_unique_component_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsClassifierMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unique_component_id) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsClassifierMeta),
                "::",
                stringify!(unique_component_id)
            )
        );
    }
    test_field_unique_component_id();
    fn test_field_label_info_list() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsClassifierMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).label_info_list) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsClassifierMeta),
                "::",
                stringify!(label_info_list)
            )
        );
    }
    test_field_label_info_list();
    fn test_field_classifier_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsClassifierMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).classifier_type) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsClassifierMeta),
                "::",
                stringify!(classifier_type)
            )
        );
    }
    test_field_classifier_type();
}
#[doc = " Holds classifier metadata for an object."]
pub type NvDsClassifierMeta = _NvDsClassifierMeta;
#[doc = " Holds label metadata for the classifier."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvDsLabelInfo {
    pub base_meta: NvDsBaseMeta,
    #[doc = " Holds the number of classes of the given label."]
    pub num_classes: guint,
    #[doc = " Holds an string describing the label of the classified object."]
    pub result_label: [gchar; 128usize],
    #[doc = " Holds a pointer to the result label if its length exceeds MAX_LABEL_SIZE bytes."]
    pub pResult_label: *mut gchar,
    #[doc = " Holds the class UD of the best result."]
    pub result_class_id: guint,
    #[doc = " Holds the label ID in case there are multiple label classifiers."]
    pub label_id: guint,
    #[doc = " Holds the probability of best result."]
    pub result_prob: gfloat,
}
#[test]
fn bindgen_test_layout__NvDsLabelInfo() {
    assert_eq!(
        ::std::mem::size_of::<_NvDsLabelInfo>(),
        200usize,
        concat!("Size of: ", stringify!(_NvDsLabelInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_NvDsLabelInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(_NvDsLabelInfo))
    );
    fn test_field_base_meta() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsLabelInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base_meta) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsLabelInfo),
                "::",
                stringify!(base_meta)
            )
        );
    }
    test_field_base_meta();
    fn test_field_num_classes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsLabelInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).num_classes) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsLabelInfo),
                "::",
                stringify!(num_classes)
            )
        );
    }
    test_field_num_classes();
    fn test_field_result_label() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsLabelInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).result_label) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsLabelInfo),
                "::",
                stringify!(result_label)
            )
        );
    }
    test_field_result_label();
    fn test_field_pResult_label() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsLabelInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pResult_label) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsLabelInfo),
                "::",
                stringify!(pResult_label)
            )
        );
    }
    test_field_pResult_label();
    fn test_field_result_class_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsLabelInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).result_class_id) as usize - ptr as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsLabelInfo),
                "::",
                stringify!(result_class_id)
            )
        );
    }
    test_field_result_class_id();
    fn test_field_label_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsLabelInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).label_id) as usize - ptr as usize
            },
            188usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsLabelInfo),
                "::",
                stringify!(label_id)
            )
        );
    }
    test_field_label_id();
    fn test_field_result_prob() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsLabelInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).result_prob) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsLabelInfo),
                "::",
                stringify!(result_prob)
            )
        );
    }
    test_field_result_prob();
}
#[doc = " Holds label metadata for the classifier."]
pub type NvDsLabelInfo = _NvDsLabelInfo;
#[doc = " Holds display metadata that the user can specify in the frame."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvDsDisplayMeta {
    pub base_meta: NvDsBaseMeta,
    #[doc = " Holds the number of rectangles described."]
    pub num_rects: guint,
    #[doc = " Holds the number of labels (strings) described."]
    pub num_labels: guint,
    #[doc = " Holds the number of lines described."]
    pub num_lines: guint,
    #[doc = " Holds the number of arrows described."]
    pub num_arrows: guint,
    #[doc = " Holds the number of circles described."]
    pub num_circles: guint,
    #[doc = " Holds an array of positional parameters for rectangles."]
    #[doc = "Used to overlay borders or semi-transparent rectangles,"]
    #[doc = "as required by the application. @see NvOSD_RectParams."]
    pub rect_params: [NvOSD_RectParams; 16usize],
    #[doc = " Holds an array of text parameters for user-defined strings that can be"]
    #[doc = "overlayed using this structure. @see NvOSD_TextParams."]
    pub text_params: [NvOSD_TextParams; 16usize],
    #[doc = " Holds an array of line parameters that the user can use to draw polygons"]
    #[doc = "in the frame, e.g. to show a RoI in the frame. @see NvOSD_LineParams."]
    pub line_params: [NvOSD_LineParams; 16usize],
    #[doc = " Holds an array of arrow parameters that the user can use to draw arrows"]
    #[doc = "in the frame. @see NvOSD_ArrowParams"]
    pub arrow_params: [NvOSD_ArrowParams; 16usize],
    #[doc = " Holds an array of circle parameters that the user can use to draw circles"]
    #[doc = "in the frame. @see NvOSD_CircleParams"]
    pub circle_params: [NvOSD_CircleParams; 16usize],
    #[doc = " Holds an array of user-defined OSD metadata."]
    pub misc_osd_data: [gint64; 4usize],
    #[doc = " For internal use."]
    pub reserved: [gint64; 4usize],
}
#[test]
fn bindgen_test_layout_NvDsDisplayMeta() {
    assert_eq!(
        ::std::mem::size_of::<NvDsDisplayMeta>(),
        6912usize,
        concat!("Size of: ", stringify!(NvDsDisplayMeta))
    );
    assert_eq!(
        ::std::mem::align_of::<NvDsDisplayMeta>(),
        8usize,
        concat!("Alignment of ", stringify!(NvDsDisplayMeta))
    );
    fn test_field_base_meta() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NvDsDisplayMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base_meta) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(NvDsDisplayMeta),
                "::",
                stringify!(base_meta)
            )
        );
    }
    test_field_base_meta();
    fn test_field_num_rects() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NvDsDisplayMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).num_rects) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(NvDsDisplayMeta),
                "::",
                stringify!(num_rects)
            )
        );
    }
    test_field_num_rects();
    fn test_field_num_labels() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NvDsDisplayMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).num_labels) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(NvDsDisplayMeta),
                "::",
                stringify!(num_labels)
            )
        );
    }
    test_field_num_labels();
    fn test_field_num_lines() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NvDsDisplayMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).num_lines) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(NvDsDisplayMeta),
                "::",
                stringify!(num_lines)
            )
        );
    }
    test_field_num_lines();
    fn test_field_num_arrows() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NvDsDisplayMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).num_arrows) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(NvDsDisplayMeta),
                "::",
                stringify!(num_arrows)
            )
        );
    }
    test_field_num_arrows();
    fn test_field_num_circles() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NvDsDisplayMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).num_circles) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(NvDsDisplayMeta),
                "::",
                stringify!(num_circles)
            )
        );
    }
    test_field_num_circles();
    fn test_field_rect_params() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NvDsDisplayMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rect_params) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(NvDsDisplayMeta),
                "::",
                stringify!(rect_params)
            )
        );
    }
    test_field_rect_params();
    fn test_field_text_params() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NvDsDisplayMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).text_params) as usize - ptr as usize
            },
            1728usize,
            concat!(
                "Offset of field: ",
                stringify!(NvDsDisplayMeta),
                "::",
                stringify!(text_params)
            )
        );
    }
    test_field_text_params();
    fn test_field_line_params() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NvDsDisplayMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).line_params) as usize - ptr as usize
            },
            3392usize,
            concat!(
                "Offset of field: ",
                stringify!(NvDsDisplayMeta),
                "::",
                stringify!(line_params)
            )
        );
    }
    test_field_line_params();
    fn test_field_arrow_params() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NvDsDisplayMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).arrow_params) as usize - ptr as usize
            },
            4288usize,
            concat!(
                "Offset of field: ",
                stringify!(NvDsDisplayMeta),
                "::",
                stringify!(arrow_params)
            )
        );
    }
    test_field_arrow_params();
    fn test_field_circle_params() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NvDsDisplayMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).circle_params) as usize - ptr as usize
            },
            5312usize,
            concat!(
                "Offset of field: ",
                stringify!(NvDsDisplayMeta),
                "::",
                stringify!(circle_params)
            )
        );
    }
    test_field_circle_params();
    fn test_field_misc_osd_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NvDsDisplayMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).misc_osd_data) as usize - ptr as usize
            },
            6848usize,
            concat!(
                "Offset of field: ",
                stringify!(NvDsDisplayMeta),
                "::",
                stringify!(misc_osd_data)
            )
        );
    }
    test_field_misc_osd_data();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<NvDsDisplayMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            6880usize,
            concat!(
                "Offset of field: ",
                stringify!(NvDsDisplayMeta),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[doc = " Holds user metadata."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NvDsUserMeta {
    pub base_meta: NvDsBaseMeta,
    #[doc = " Holds a pointer to user data to be attached."]
    #[doc = "See the deepstream-user-metadata-test example for usage."]
    pub user_meta_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__NvDsUserMeta() {
    assert_eq!(
        ::std::mem::size_of::<_NvDsUserMeta>(),
        48usize,
        concat!("Size of: ", stringify!(_NvDsUserMeta))
    );
    assert_eq!(
        ::std::mem::align_of::<_NvDsUserMeta>(),
        8usize,
        concat!("Alignment of ", stringify!(_NvDsUserMeta))
    );
    fn test_field_base_meta() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsUserMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base_meta) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsUserMeta),
                "::",
                stringify!(base_meta)
            )
        );
    }
    test_field_base_meta();
    fn test_field_user_meta_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NvDsUserMeta>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).user_meta_data) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_NvDsUserMeta),
                "::",
                stringify!(user_meta_data)
            )
        );
    }
    test_field_user_meta_data();
}
#[doc = " Holds user metadata."]
pub type NvDsUserMeta = _NvDsUserMeta;
extern "C" {
    #[doc = " Acquires a lock before updating metadata."]
    #[doc = ""]
    #[doc = " @param[in] batch_meta    A pointer to the NvDsBatchMeta structure"]
    #[doc = "                          to be locked."]
    pub fn nvds_acquire_meta_lock(batch_meta: *mut NvDsBatchMeta);
}
extern "C" {
    #[doc = " Releases the lock after updating metadata."]
    #[doc = ""]
    #[doc = " @param[in] batch_meta    A pointer to NvDsBatchMeta structure to be unlocked."]
    pub fn nvds_release_meta_lock(batch_meta: *mut NvDsBatchMeta);
}
extern "C" {
    #[doc = " Creates a batch metadata structure for a batch of specified size."]
    #[doc = ""]
    #[doc = " @param[in] max_batch_size    The maximum number of frames in the batch."]
    #[doc = " @ return  A pointer to the created structure."]
    pub fn nvds_create_batch_meta(max_batch_size: guint) -> *mut NvDsBatchMeta;
}
extern "C" {
    #[doc = " Destroys a batch metadata structure."]
    #[doc = ""]
    #[doc = " @param[in] batch_meta    A pointer to batch metadata structure"]
    #[doc = "                          to be destroyed."]
    #[doc = " @returns  True if the object was successfully destroyed, or false otherwise."]
    pub fn nvds_destroy_batch_meta(batch_meta: *mut NvDsBatchMeta) -> gboolean;
}
extern "C" {
    #[doc = " \\brief  Acquires a frame meta from a batch's frame meta pool."]
    #[doc = ""]
    #[doc = " You must acquire a frame meta before you can fill it with frame metadata."]
    #[doc = ""]
    #[doc = " @param[in] batch_meta    A pointer to batch meta from which to acquire"]
    #[doc = "                          a frame meta."]
    #[doc = ""]
    #[doc = " @return  A pointer to the acquired frame meta."]
    pub fn nvds_acquire_frame_meta_from_pool(batch_meta: *mut NvDsBatchMeta) -> *mut NvDsFrameMeta;
}
extern "C" {
    #[doc = " Adds a frame meta to a batch meta."]
    #[doc = ""]
    #[doc = " @param[in] batch_meta    A pointer to the NvDsBatchMeta to which"]
    #[doc = "                          @a frame_meta is to be added."]
    #[doc = " @param[in] frame_meta    A pointer to a frame meta to be added to"]
    #[doc = "                          @a batch_meta."]
    pub fn nvds_add_frame_meta_to_batch(
        batch_meta: *mut NvDsBatchMeta,
        frame_meta: *mut NvDsFrameMeta,
    );
}
extern "C" {
    #[doc = " Removes a frame meta from a batch meta."]
    #[doc = ""]
    #[doc = " @param[in] batch_meta    A pointer to the batch meta from which @a frame_meta"]
    #[doc = "                          is to be removed."]
    #[doc = " @param[in] frame_meta    A pointer to the frame meta to be removed from"]
    #[doc = "                          @a batch_meta."]
    pub fn nvds_remove_frame_meta_from_batch(
        batch_meta: *mut NvDsBatchMeta,
        frame_meta: *mut NvDsFrameMeta,
    );
}
extern "C" {
    #[doc = " @brief  Acquires an object meta from a batch meta's object meta pool."]
    #[doc = ""]
    #[doc = " You must acquire an object meta before you can fill it with object metadata."]
    #[doc = ""]
    #[doc = " @param[in] batch_meta    A pointer to the batch meta from which to acquire"]
    #[doc = "                          an object meta."]
    #[doc = ""]
    #[doc = " @return  A pointer to the acquired object meta."]
    pub fn nvds_acquire_obj_meta_from_pool(batch_meta: *mut NvDsBatchMeta) -> *mut NvDsObjectMeta;
}
extern "C" {
    #[doc = " @brief  Adds an object meta to a frame meta."]
    #[doc = ""]
    #[doc = " You must acquire the object meta with nvds_acquire_object_meta_from_pool()"]
    #[doc = " and fill it with metadata before you add to to the frame meta."]
    #[doc = ""]
    #[doc = " @param[in] frame_meta    A pointer to the frame meta to which @a obj_meta"]
    #[doc = "                          is to be added."]
    #[doc = " @param[in] obj_meta      A pointer to an object meta to be added to @a frame_meta."]
    #[doc = " @param[in] obj_parent    A pointer to the this object meta's parent object meta."]
    #[doc = "                          This pointer is stored in @a obj_meta->parent."]
    pub fn nvds_add_obj_meta_to_frame(
        frame_meta: *mut NvDsFrameMeta,
        obj_meta: *mut NvDsObjectMeta,
        obj_parent: *mut NvDsObjectMeta,
    );
}
extern "C" {
    #[doc = " Removes an object meta from the frame meta to which it is attached."]
    #[doc = ""]
    #[doc = " @param[in] frame_meta    A pointer to frame meta from which @a obj_meta"]
    #[doc = "                          is to be removed."]
    #[doc = " @param[in] obj_meta      A pointer to the object meta to be removed from"]
    #[doc = "                          @a frame_meta."]
    pub fn nvds_remove_obj_meta_from_frame(
        frame_meta: *mut NvDsFrameMeta,
        obj_meta: *mut NvDsObjectMeta,
    );
}
extern "C" {
    #[doc = " @brief  Acquires a classifier meta from a batch meta's classifier meta pool."]
    #[doc = ""]
    #[doc = " You must acquire a classifier meta from the classifier meta pool before you"]
    #[doc = " can fill it with classifier metadata."]
    #[doc = ""]
    #[doc = " @param[in] batch_meta    A pointer to the batch meta from which to acquire"]
    #[doc = "                          a classifier meta."]
    #[doc = ""]
    #[doc = " @return  The classifier meta acquired from the batch meta's"]
    #[doc = "  classifier meta pool."]
    pub fn nvds_acquire_classifier_meta_from_pool(
        batch_meta: *mut NvDsBatchMeta,
    ) -> *mut NvDsClassifierMeta;
}
extern "C" {
    #[doc = " @brief  Adds a classifier meta to the appropriate roi meta."]
    #[doc = ""]
    #[doc = " You must acquire a classifier meta with"]
    #[doc = " nvds_acquire_classifier_meta_from_pool() and fill it with"]
    #[doc = " classifier metadata before you add it to the roi metadata."]
    #[doc = ""]
    #[doc = " @param[in] roi_meta          A pointer to the roi meta to which"]
    #[doc = "                              @a classifier_meta is to be added."]
    #[doc = " @param[in] classifier_meta   A pointer to the classifier meta to be added"]
    #[doc = "                              to @a roi_meta."]
    pub fn nvds_add_classifier_meta_to_roi(
        roi_meta: *mut NvDsRoiMeta,
        classifier_meta: *mut NvDsClassifierMeta,
    );
}
extern "C" {
    #[doc = " Removes a classifier meta from the roi meta to which it is attached."]
    #[doc = ""]
    #[doc = " @param[in] roi_meta          A pointer to the roi meta from which"]
    #[doc = "                              @a classifier_meta is to be removed."]
    #[doc = " @param[in] classifier_meta   A pointer to the classifier meta to be removed"]
    #[doc = "                              from @a roi_meta."]
    pub fn nvds_remove_classifier_meta_from_roi(
        roi_meta: *mut NvDsRoiMeta,
        classifier_meta: *mut NvDsClassifierMeta,
    );
}
extern "C" {
    #[doc = " @brief  Adds a classifier meta to the appropriate object meta."]
    #[doc = ""]
    #[doc = " You must acquire a classifier meta with"]
    #[doc = " nvds_acquire_classifier_meta_from_pool() and fill it with"]
    #[doc = " classifier metadata before you add it to the object metadata."]
    #[doc = ""]
    #[doc = " @param[in] obj_meta          A pointer to the object meta to which"]
    #[doc = "                              @a classifier_meta is to be added."]
    #[doc = " @param[in] classifier_meta   A pointer to the classifier meta to be added"]
    #[doc = "                              to @a obj_meta."]
    pub fn nvds_add_classifier_meta_to_object(
        obj_meta: *mut NvDsObjectMeta,
        classifier_meta: *mut NvDsClassifierMeta,
    );
}
extern "C" {
    #[doc = " Removes a classifier meta from the object meta to which it is attached."]
    #[doc = ""]
    #[doc = " @param[in] obj_meta          A pointer to the object meta from which"]
    #[doc = "                              @a classifier_meta is to be removed."]
    #[doc = " @param[in] classifier_meta   A pointer to the classifier meta to be removed"]
    #[doc = "                              from @a obj_meta."]
    pub fn nvds_remove_classifier_meta_from_obj(
        obj_meta: *mut NvDsObjectMeta,
        classifier_meta: *mut NvDsClassifierMeta,
    );
}
extern "C" {
    #[doc = " @brief  Acquires a display meta from a batch meta's display meta pool."]
    #[doc = ""]
    #[doc = " You must acquire a display meta before you can fill it with display metadata."]
    #[doc = ""]
    #[doc = " @param[in] batch_meta    A pointer to the batch meta from which to acquire"]
    #[doc = "                          a display meta."]
    #[doc = ""]
    #[doc = " @return  The display meta acquired from the batch meta's display meta pool."]
    pub fn nvds_acquire_display_meta_from_pool(
        batch_meta: *mut NvDsBatchMeta,
    ) -> *mut NvDsDisplayMeta;
}
extern "C" {
    #[doc = " @brief  Adds a display meta to the appropriate frame meta."]
    #[doc = ""]
    #[doc = " You must acquire a display meta with nvds_)acquire_display_meta_from_pool()"]
    #[doc = " and fill it with display metadata before you can add it to the frame meta."]
    #[doc = ""]
    #[doc = " @param[in] frame_meta    A pointer to frame meta to which @a display_meta"]
    #[doc = "                          is to be added."]
    #[doc = " @param[in] display_meta  A pointer to the display meta to be added to"]
    #[doc = "                          @a frame_meta."]
    pub fn nvds_add_display_meta_to_frame(
        frame_meta: *mut NvDsFrameMeta,
        display_meta: *mut NvDsDisplayMeta,
    );
}
extern "C" {
    #[doc = " Removes a display meta from the frame meta to which it is attached."]
    #[doc = ""]
    #[doc = " @param[in] frame_meta    A pointer to the frame meta from which"]
    #[doc = "                          @a display_meta is to be removed."]
    #[doc = " @param[in] display_meta  A pointer to the display meta to be removed from"]
    #[doc = "                          @a frame_meta."]
    pub fn nvds_remove_display_meta_from_frame(
        frame_meta: *mut NvDsFrameMeta,
        display_meta: *mut NvDsDisplayMeta,
    );
}
extern "C" {
    #[doc = " @brief  Acquires a label info meta from a batch meta's label info meta pool."]
    #[doc = ""]
    #[doc = " You must acquire a label info meta before you can fill it and add it to a"]
    #[doc = " classifier meta."]
    #[doc = ""]
    #[doc = " @param[in] batch_meta    A pointer to the batch meta from which to acquire"]
    #[doc = "                          a label info meta."]
    #[doc = ""]
    #[doc = " @return  The label info meta acquired from the batch meta's"]
    #[doc = "  label info meta pool."]
    pub fn nvds_acquire_label_info_meta_from_pool(
        batch_meta: *mut NvDsBatchMeta,
    ) -> *mut NvDsLabelInfo;
}
extern "C" {
    #[doc = " Adds a label info meta to a classifier meta."]
    #[doc = ""]
    #[doc = " @param[in] classifier_meta   A pointer to the classifier meta to which"]
    #[doc = "                              @a label_info_meta is to be added."]
    #[doc = " @param[in] label_info_meta   A pointer to the label info meta to be added"]
    #[doc = "                              to @a classifier_meta."]
    pub fn nvds_add_label_info_meta_to_classifier(
        classifier_meta: *mut NvDsClassifierMeta,
        label_info_meta: *mut NvDsLabelInfo,
    );
}
extern "C" {
    #[doc = " Removes a label info meta from the classifier meta to which it is attached."]
    #[doc = ""]
    #[doc = " @param[in] classifier_meta   A pointer to the classifier meta from which"]
    #[doc = "                              @a label_info_meta is to be removed."]
    #[doc = " @param[in] label_info_meta   A pointer to the label info meta to be removed"]
    #[doc = "                              from @a classifier_meta."]
    pub fn nvds_remove_label_info_meta_from_classifier(
        classifier_meta: *mut NvDsClassifierMeta,
        label_info_meta: *mut NvDsLabelInfo,
    );
}
extern "C" {
    #[doc = " Add a user meta to a batch meta."]
    #[doc = ""]
    #[doc = " @param[in] batch_meta    A pointer to batch meta to which @a user_meta"]
    #[doc = "                          is to be added."]
    #[doc = " @param[in] user_meta     A pointer to a user meta to be added to"]
    #[doc = "                          @a batch_meta."]
    pub fn nvds_add_user_meta_to_batch(
        batch_meta: *mut NvDsBatchMeta,
        user_meta: *mut NvDsUserMeta,
    );
}
extern "C" {
    #[doc = " Add a user meta to a frame meta."]
    #[doc = ""]
    #[doc = " @param[in] frame_meta    A pointer to the frame meta to which @a user_meta"]
    #[doc = "                          is to be added."]
    #[doc = " @param[in] user_meta     A pointer to a user meta to be added to"]
    #[doc = "                          @a frame_meta."]
    pub fn nvds_add_user_meta_to_frame(
        frame_meta: *mut NvDsFrameMeta,
        user_meta: *mut NvDsUserMeta,
    );
}
extern "C" {
    #[doc = " Add a user meta user to an roi meta."]
    #[doc = ""]
    #[doc = " @param[in] roi_meta      A pointer to the roi meta to which @a user_meta"]
    #[doc = "                          is to be added."]
    #[doc = " @param[in] user_meta     A pointer to the user meta to be added to"]
    #[doc = "                          @a roi_meta."]
    pub fn nvds_add_user_meta_to_roi(roi_meta: *mut NvDsRoiMeta, user_meta: *mut NvDsUserMeta);
}
extern "C" {
    #[doc = " Add a user meta user to an object meta."]
    #[doc = ""]
    #[doc = " @param[in] obj_meta      A pointer to the object meta to which @a user_meta"]
    #[doc = "                          is to be added."]
    #[doc = " @param[in] user_meta     A pointer to the user meta to be added to"]
    #[doc = "                          @a obj_meta."]
    pub fn nvds_add_user_meta_to_obj(obj_meta: *mut NvDsObjectMeta, user_meta: *mut NvDsUserMeta);
}
extern "C" {
    #[doc = " @brief  Acquires a user meta from a batch meta's user meta pool."]
    #[doc = ""]
    #[doc = " You must acquire a user meta before you can fill it with user metdata and"]
    #[doc = " add it to a batch, frame, or object meta (call nvds_add_user_data_to_batch(),"]
    #[doc = "  nvds_add_user_data_to_frame(), or nvds_add_user_data_to_obj())."]
    #[doc = ""]
    #[doc = " @param[in] batch_meta    A pointer to the batch meta from which to acquire"]
    #[doc = "                          a user meta."]
    pub fn nvds_acquire_user_meta_from_pool(batch_meta: *mut NvDsBatchMeta) -> *mut NvDsUserMeta;
}
extern "C" {
    #[doc = " Removes a user meta from a batch meta to which it is attached."]
    #[doc = ""]
    #[doc = " @param[in] batch_meta    A pointer to the batch meta from which @a user_meta"]
    #[doc = "                          is to be removed."]
    #[doc = " @param[in] user_meta     A pointer to the user meta to be removed from"]
    #[doc = "                          @a batch_meta."]
    #[doc = ""]
    #[doc = " returns acquired @ref NvDsUserMeta pointer from user meta pool"]
    pub fn nvds_remove_user_meta_from_batch(
        batch_meta: *mut NvDsBatchMeta,
        user_meta: *mut NvDsUserMeta,
    );
}
extern "C" {
    #[doc = " Removes a user meta from a frame meta to which it is attached."]
    #[doc = ""]
    #[doc = " @param[in] frame_meta    A pointer to the frame meta from which @a user_meta"]
    #[doc = "                          is to be removed."]
    #[doc = " @param[in] user_meta     A pointer to the user meta to be removed from"]
    #[doc = "                          @a frame_meta."]
    pub fn nvds_remove_user_meta_from_frame(
        frame_meta: *mut NvDsFrameMeta,
        user_meta: *mut NvDsUserMeta,
    );
}
extern "C" {
    #[doc = " Removes a user meta from an roi meta to which it is attached."]
    #[doc = ""]
    #[doc = " @param[in] roi_meta      A pointer to the roi meta from which @a user_meta"]
    #[doc = "                          is to be removed."]
    #[doc = " @param[in] user_meta     A pointer to the user to be removed from"]
    #[doc = "                          @a roi_meta."]
    pub fn nvds_remove_user_meta_from_roi(obj_meta: *mut NvDsRoiMeta, user_meta: *mut NvDsUserMeta);
}
extern "C" {
    #[doc = " Removes a user meta from an object meta to which it is attached."]
    #[doc = ""]
    #[doc = " @param[in] obj_meta      A pointer to the object meta from which @a user_meta"]
    #[doc = "                          is to be removed."]
    #[doc = " @param[in] user_meta     A pointer to the user to be removed from"]
    #[doc = "                          @a obj_meta."]
    pub fn nvds_remove_user_meta_from_object(
        obj_meta: *mut NvDsObjectMeta,
        user_meta: *mut NvDsUserMeta,
    );
}
extern "C" {
    #[doc = " A debugging function; prints current metadata information available after"]
    #[doc = " inference. This function should be called after inference."]
    #[doc = ""]
    #[doc = " @param[in] batch_meta    A pointer to a batch meta from which to"]
    #[doc = "                          print information."]
    #[doc = " @return"]
    pub fn nvds_get_current_metadata_info(batch_meta: *mut NvDsBatchMeta) -> gboolean;
}
extern "C" {
    #[doc = " @brief  Copies or transforms meta data from one buffer to another."]
    #[doc = ""]
    #[doc = " @param[in] data      A pointer to a batch meta (of type @ref NvDsBatchMeta),"]
    #[doc = "                      cast to @c gpointer."]
    #[doc = " @param[in] user_data Currently not in use and should be set to NULL."]
    #[doc = ""]
    #[doc = " @return A pointer to a metadata structure, to be cast to type NvDsBatchMeta."]
    pub fn nvds_batch_meta_copy_func(data: gpointer, user_data: gpointer) -> gpointer;
}
extern "C" {
    #[doc = " Releases metadata from a batch meta."]
    #[doc = ""]
    #[doc = " @param[in] data      A pointer to a batch meta (type @ref NvDsBatchMeta),"]
    #[doc = "                      cast to @c gpointer."]
    #[doc = " @param[in] user_data Currently not in use and should be set to NULL."]
    pub fn nvds_batch_meta_release_func(data: gpointer, user_data: gpointer);
}
extern "C" {
    #[doc = " Returns a pointer to a specified frame meta in the frame meta list."]
    #[doc = ""]
    #[doc = " @param[in] frame_meta_list   A pointer to a list of pointers to frame metas."]
    #[doc = " @param[in] index             The index of the frame meta to be returned."]
    #[doc = ""]
    #[doc = " @return  A pointer to the @a index'th frame meta in the frame meta list."]
    pub fn nvds_get_nth_frame_meta(
        frame_meta_list: *mut NvDsFrameMetaList,
        index: guint,
    ) -> *mut NvDsFrameMeta;
}
extern "C" {
    #[doc = " Removes all of the frame metadata attached to a batch meta."]
    #[doc = ""]
    #[doc = " @param[in] batch_meta    A pointer to the batch whose frame meta list"]
    #[doc = "                          is to be cleared."]
    #[doc = " @param[in] meta_list     A pointer to the frame meta list to be cleared."]
    pub fn nvds_clear_frame_meta_list(
        batch_meta: *mut NvDsBatchMeta,
        meta_list: *mut NvDsFrameMetaList,
    );
}
extern "C" {
    #[doc = " Removes all the object metadata attached to a frame meta."]
    #[doc = ""]
    #[doc = " @param[in] frame_meta    A pointer to the frame meta whose object meta list"]
    #[doc = "                          is to be cleared."]
    #[doc = " @param[in] meta_list     A pointer to the object meta list to be cleared."]
    pub fn nvds_clear_obj_meta_list(
        frame_meta: *mut NvDsFrameMeta,
        meta_list: *mut NvDsObjectMetaList,
    );
}
extern "C" {
    #[doc = " Removes all of the classifier metadata attached to an object meta."]
    #[doc = ""]
    #[doc = " @param[in] obj_meta A pointer to @ref NvDsObjectMeta from which @a"]
    #[doc = "            NvDsClassifierMetaList needs to be cleared"]
    #[doc = " @param[in] meta_list A pointer to @ref NvDsClassifierMetaList which needs to"]
    #[doc = "            be cleared"]
    pub fn nvds_clear_classifier_meta_list(
        obj_meta: *mut NvDsObjectMeta,
        meta_list: *mut NvDsClassifierMetaList,
    );
}
extern "C" {
    #[doc = " Removes all of the label info metadata attached to a classifier meta."]
    #[doc = ""]
    #[doc = " @param[in] classifier_meta   A pointer to the classifier meta whose"]
    #[doc = "                              label info meta list is to be cleared."]
    #[doc = " @param[in] meta_list         A pointer to the label info meta list to be"]
    #[doc = "                              cleared."]
    pub fn nvds_clear_label_info_meta_list(
        classifier_meta: *mut NvDsClassifierMeta,
        meta_list: *mut NvDsLabelInfoList,
    );
}
extern "C" {
    #[doc = " Removes all of the display metadata attached to a frame meta."]
    #[doc = ""]
    #[doc = " @param[in] frame_meta    A pointer to the frame meta whose display meta list"]
    #[doc = "                          is to be cleared."]
    #[doc = " @param[in] meta_list     A pointer to the display meta list to be cleared."]
    pub fn nvds_clear_display_meta_list(
        frame_meta: *mut NvDsFrameMeta,
        meta_list: *mut NvDisplayMetaList,
    );
}
extern "C" {
    #[doc = " Removes all of the user metadata attached to the batch meta."]
    #[doc = ""]
    #[doc = " @param[in] batch_meta    A pointer to the batch meta whose"]
    #[doc = "                          user meta list is to be cleared."]
    #[doc = " @param[in] meta_list     A pointer to the user meta list to be"]
    #[doc = "            cleared"]
    pub fn nvds_clear_batch_user_meta_list(
        batch_meta: *mut NvDsBatchMeta,
        meta_list: *mut NvDsUserMetaList,
    );
}
extern "C" {
    #[doc = " Removes all of the user metadata attached to the frame meta."]
    #[doc = ""]
    #[doc = " @param[in] frame_meta    A pointer to the frame meta whose"]
    #[doc = "                          user meta list is to be cleared."]
    #[doc = " @param[in] meta_list     A pointer to the user meta list to be cleared."]
    pub fn nvds_clear_frame_user_meta_list(
        frame_meta: *mut NvDsFrameMeta,
        meta_list: *mut NvDsUserMetaList,
    );
}
extern "C" {
    #[doc = " Removes all of the user metadata attached to an object meta."]
    #[doc = ""]
    #[doc = " @param[in] object_meta   A pointer to the object meta whose"]
    #[doc = "                          user meta list is to be cleared."]
    #[doc = " @param[in] meta_list     A pointer to the user meta list to be cleared."]
    pub fn nvds_clear_obj_user_meta_list(
        object_meta: *mut NvDsObjectMeta,
        meta_list: *mut NvDsUserMetaList,
    );
}
extern "C" {
    #[doc = " Removes all of the metadata elements attached to a metadata list."]
    #[doc = ""]
    #[doc = " @param[in] batch_meta    A pointer to a batch meta."]
    #[doc = " @param[in] meta_list     A pointer to meta list to be cleared."]
    #[doc = " @param[in] meta_pool     A pointer to the meta pool that contains"]
    #[doc = "                          @a meta_list."]
    #[doc = " @return  A pointer to the updated meta list."]
    pub fn nvds_clear_meta_list(
        batch_meta: *mut NvDsBatchMeta,
        meta_list: *mut NvDsMetaList,
        meta_pool: *mut NvDsMetaPool,
    ) -> *mut NvDsMetaList;
}
extern "C" {
    #[doc = " \\brief  Makes a deep copy of a frame meta to another frame meta."]
    #[doc = ""]
    #[doc = " @param[in] src_frame_meta    A pointer to the source frame meta."]
    #[doc = " @param[in] dst_frame_meta    A pointer to the destination frame meta."]
    pub fn nvds_copy_frame_meta(
        src_frame_meta: *mut NvDsFrameMeta,
        dst_frame_meta: *mut NvDsFrameMeta,
    );
}
extern "C" {
    #[doc = " \\brief  Makes a deep copy of an object meta to another object meta."]
    #[doc = ""]
    #[doc = " @param[in] src_object_meta   A pointer to the source object meta."]
    #[doc = " @param[in] dst_object_meta   A pointer to the destination object meta."]
    pub fn nvds_copy_obj_meta(
        src_object_meta: *mut NvDsObjectMeta,
        dst_object_meta: *mut NvDsObjectMeta,
    );
}
extern "C" {
    #[doc = " \\brief  Makes a deep copy of a classifier meta to another classifier meta."]
    #[doc = ""]
    #[doc = " @param[in] src_classifier_meta   A pointer to the source classifier meta."]
    #[doc = " @param[in] dst_classifier_meta A pointer to the destination classifier meta."]
    pub fn nvds_copy_classifier_meta(
        src_classifier_meta: *mut NvDsClassifierMeta,
        dst_classifier_meta: *mut NvDsClassifierMeta,
    );
}
extern "C" {
    #[doc = " \\brief  Makes a deep copy of a label info meta to another label info meta."]
    #[doc = ""]
    #[doc = " @param[in] src_label_info    A pointer to the source label info meta."]
    #[doc = " @param[in] dst_label_info    A pointer to the destination label info meta."]
    pub fn nvds_copy_label_info_meta(
        src_label_info: *mut NvDsLabelInfo,
        dst_label_info: *mut NvDsLabelInfo,
    );
}
extern "C" {
    #[doc = " \\brief  Makes a deep copy of a display meta to another display meta."]
    #[doc = ""]
    #[doc = " @param[in] src_display_meta  A pointer to the source display meta."]
    #[doc = " @param[in] dst_display_meta  A pointer to destination display meta."]
    pub fn nvds_copy_display_meta(
        src_display_meta: *mut NvDsDisplayMeta,
        dst_display_meta: *mut NvDsDisplayMeta,
    );
}
extern "C" {
    #[doc = " \\brief  Makes a deep copy of a user meta list to the user meta list"]
    #[doc = " in a specified batch meta."]
    #[doc = ""]
    #[doc = " @param[in] src_user_meta_list    A pointer to the source user meta list."]
    #[doc = " @param[in] dst_batch_meta        A pointer to the destination batch meta."]
    pub fn nvds_copy_batch_user_meta_list(
        src_user_meta_list: *mut NvDsUserMetaList,
        dst_batch_meta: *mut NvDsBatchMeta,
    );
}
extern "C" {
    #[doc = " \\brief  Makes a deep copy of a source user meta list to the user meta list"]
    #[doc = " in a specified frame meta."]
    #[doc = ""]
    #[doc = " @param[in] src_user_meta_list    A pointer to the source user meta list."]
    #[doc = " @param[in] dst_frame_meta        A pointer to the destination frame meta."]
    pub fn nvds_copy_frame_user_meta_list(
        src_user_meta_list: *mut NvDsUserMetaList,
        dst_frame_meta: *mut NvDsFrameMeta,
    );
}
extern "C" {
    #[doc = " \\brief  Makes a deep copy of a source user meta list to the user meta list"]
    #[doc = " in a specified object meta."]
    #[doc = ""]
    #[doc = " @param[in] src_user_meta_list    A pointer to the source user meta list."]
    #[doc = " @param[in] dst_object_meta       A pointer to the destination object meta."]
    pub fn nvds_copy_obj_user_meta_list(
        src_user_meta_list: *mut NvDsUserMetaList,
        dst_object_meta: *mut NvDsObjectMeta,
    );
}
extern "C" {
    #[doc = " \\brief  Makes a deep copy of a source display meta list to the"]
    #[doc = "  display meta list in a specified frame meta."]
    #[doc = ""]
    #[doc = " @param[in] src_display_meta_list A pointer to the source display meta list."]
    #[doc = " @param[in] dst_frame_meta        A pointer to the destination frame meta."]
    pub fn nvds_copy_display_meta_list(
        src_display_meta_list: *mut NvDisplayMetaList,
        dst_frame_meta: *mut NvDsFrameMeta,
    );
}
extern "C" {
    #[doc = " \\brief  Makes a deep copy of a source frame meta list to the frame meta list"]
    #[doc = "  in a specified batch meta."]
    #[doc = ""]
    #[doc = " @param[in] src_frame_meta_list   A pointer to the source frame meta list."]
    #[doc = " @param[in] dst_batch_meta        A pointer to the destination batch meta."]
    pub fn nvds_copy_frame_meta_list(
        src_frame_meta_list: *mut NvDsFrameMetaList,
        dst_batch_meta: *mut NvDsBatchMeta,
    );
}
extern "C" {
    #[doc = " \\brief  Makes a deep copy of a source object meta list to the"]
    #[doc = "  object meta list in a specified frame meta."]
    #[doc = ""]
    #[doc = " @param[in] src_obj_meta_list A pointer to the source object meta list."]
    #[doc = " @param[in] dst_frame_meta    A pointer to the destination frame meta."]
    pub fn nvds_copy_obj_meta_list(
        src_obj_meta_list: *mut NvDsObjectMetaList,
        dst_frame_meta: *mut NvDsFrameMeta,
    );
}
extern "C" {
    #[doc = " \\brief  Makes a deep copy of a source classifier meta list to the"]
    #[doc = "  classifier meta list in a specified object meta."]
    #[doc = ""]
    #[doc = " @param[in] src_classifier_meta_list  A pointer to the source"]
    #[doc = "                                      classifier meta list."]
    #[doc = " @param[in] dst_object_meta           A pointer to the destination"]
    #[doc = "                                      object meta."]
    pub fn nvds_copy_classification_list(
        src_classifier_meta_list: *mut NvDsClassifierMetaList,
        dst_object_meta: *mut NvDsObjectMeta,
    );
}
extern "C" {
    #[doc = " \\brief  Makes a deep copy of a source label info meta list to the"]
    #[doc = "  label info meta list in a specified classifier meta."]
    #[doc = ""]
    #[doc = " @param[in] src_label_info_list   A pointer to the source"]
    #[doc = "                                  label info meta list."]
    #[doc = " @param[in] dst_classifier_meta   A pointer to the destination"]
    #[doc = "                                  classifier meta."]
    pub fn nvds_copy_label_info_list(
        src_label_info_list: *mut NvDsLabelInfoList,
        dst_classifier_meta: *mut NvDsClassifierMeta,
    );
}
extern "C" {
    #[doc = " Generates a unique user metadata type from a specified string describing"]
    #[doc = " user-specific metadata."]
    #[doc = ""]
    #[doc = " @param[in] meta_descriptor   A pointer to a string describing user-specific"]
    #[doc = "                              metadata. The string must be in the format"]
    #[doc = "                              @a ORG_NAME.COMPONENT_NAME.METADATA_DESCRIPTION,"]
    #[doc = "                              e.g. @c NVIDIA.NVINFER.TENSOR_METADATA."]
    pub fn nvds_get_user_meta_type(meta_descriptor: *mut gchar) -> NvDsMetaType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
pub type __uint128_t = u128;
